# Setting up project structure

In order to start larger scale development, as well as to use Visual Studio for CMake project development for baremetal platforms, it is wise to set up your project in a certain way.

To understand how to approach this, first a bit of information on how CMake projects are structured, and how Visual Studio integrates CMake projects.

## CMake project structure

When using `CMake`, there is a root `CMakeLists.txt`, that acts as the starting point for `CMake`. Normally, this is at the root directory of your project. In our case, for now, this is in tutorial/00-build.
Each directory that is part of the `CMake` structure, will have a `CMakeLists.txt` file.
When building, we normally build out of tree, as we did before. This means there is a specific directory, we used `cmake-build` before, that is used to store all intermediate files used and generated by CMake. These files could be makefiles generated by CMake, but also contain object files etc.
The third directory tree is the target binary tree, in our case `output`, where all libaries and executables will be stored.
This will normally hold executable files (.exe or .elf for example), as well as dynamic or shared libraries (.dll or .so files).
In our case, we will also store static libraries (.lib or .a) there.
For our specific case, we wish to create kernel images from executables, so we will add a fourth tree named `deploy`.

![Initial project structure](images/project-structure-initial.png)

We will slightly change this structure, to allow for more projects to be built, and also to enable easy integration with Visual Studio.

- First of all, we'll create multiple build directories, e.g. one for debug builds, one for release builds.
- We will move the custom scripting folder to the project root directory
- We will move the toolchain file to the root directory
- We will create a new directory `code` at root level, with subdirectories `applications` and `libraries` underneath which we will add our applications and libraries.
For now, there will be no subdirectories, but we will add `CMakeLists.txt` files in each directory for preparation.
- We will leave the tutorial directory in place, and leave the 00-build directory as is (to ensure we can still build our previous project as before), but will also populate the tutorial directory with `CMakeLists.txt` to prepare for new tutorial projects.
- We will also add a CMakeLists.txt in the root directory

![Initial project structure](images/project-structure-target.png)

In order to explain how to populate the new structure, let's start setting up a new application named `demo`, which we will later extend.

![Initial project structure](images/project-structure-new-project.png)

### Root CMakeLists.txt

The root `CMakeLists.txt` is the starting point for CMake. 
It contains all global definitions and settings, such as the path to the custom CMake scripts, definition of base output directory, and later on also general compiler settings etc.
It is common practice to create a main project in this file, in order for the toolchain to be processed.

For now, we'll start with the following contents:

```cmake
cmake_minimum_required(VERSION 3.18)

message(STATUS "CMake ${CMAKE_VERSION}")

set(SCRIPTS_DIR "" CACHE STRING "CMake scripts path")

if ("${SCRIPTS_DIR}" STREQUAL "")
    set(SCRIPTS_DIR "${CMAKE_SOURCE_DIR}/cmake" CACHE STRING "CMake scripts path" FORCE)
endif()

list(APPEND CMAKE_MODULE_PATH ${SCRIPTS_DIR})

if("${CMAKE_BUILD_TYPE}" STREQUAL "")
    set(CMAKE_BUILD_TYPE Debug)
endif()
if(${CMAKE_BUILD_TYPE} STREQUAL "Debug")
    set(CONFIG_DIR Debug)
elseif(
    ${CMAKE_BUILD_TYPE} STREQUAL "Release" OR
    ${CMAKE_BUILD_TYPE} STREQUAL "MinSizeRel" OR 
    ${CMAKE_BUILD_TYPE} STREQUAL "RelWithDebInfo")
        set(CONFIG_DIR Release)
else()
    message(FATAL_ERROR "Invalid build type: " ${CMAKE_BUILD_TYPE})
endif()

set(DEPLOYMENT_DIR "${CMAKE_SOURCE_DIR}/deploy" CACHE STRING "Deployment directory")
set(OUTPUT_BASE_DIR "${CMAKE_SOURCE_DIR}/output" CACHE STRING "Output directory")
set(OUTPUT_BIN_DIR "${OUTPUT_BASE_DIR}/${CONFIG_DIR}/bin")
set(OUTPUT_LIB_DIR "${OUTPUT_BASE_DIR}/${CONFIG_DIR}/lib")

project(baremetal
    DESCRIPTION "Baremetal overall project")

add_subdirectory(code)

```

Explanation:
- As before we start with the minimum CMake version required
- We then print the current CMake version
- We define a cached variables for the script path, and set it to the cmake scripts directory. We then add this path to the `CMAKE_MODULE_PATH`.
- Different is the way we defined the directory for the build configuration. 
We set the `CMAKE_BUILD_TYPE` to Debug if it is not set, and then depending on the build configuration set the directory to either Debug (for Debug) or Release (for Release, MinSizeRel or RelWithDebInfo).
- We then define the variables for the common deployment directory `DEPLOYMENT_DIR` (for image files) and the common output directory OUTPUT_BASE_DIR` (for built libraries and executables). Both variables will also be stored in the cache.
- New is that we define two variable to hold the output library path `OUTPUT_LIB_DIR` and output executable path `OUTPUT_BIN_DIR`.
- Lastly, we include the `CMakeList.txt` file in the code directory.

### Intermediate directory CMakeLists.txt

The CMakeLists.txt files in the code, applications, and libraries directories simply print the current path, and then include the next level `CMakeLists.txt` files:

code:
```cmake
message(STATUS "\n**********************************************************************************\n")
message(STATUS "\n## In directory: ${CMAKE_CURRENT_SOURCE_DIR}")

add_subdirectory(applications)
add_subdirectory(libraries)
```

code/applications:
```cmake
message(STATUS "\n**********************************************************************************\n")
message(STATUS "\n## In directory: ${CMAKE_CURRENT_SOURCE_DIR}")

add_subdirectory(demo)
```

code/libraries:
```cmake
message(STATUS "\n**********************************************************************************\n")
message(STATUS "\n## In directory: ${CMAKE_CURRENT_SOURCE_DIR}")

```

In the end the demo project `CMakeLists.txt` file is included, which is a normal project file.

### Project CMakeLists.txt

The `CMakeLists.txt` file in `code/applications/demo` defines our application:

```cmake
project(demo
    DESCRIPTION "Demo application"
    LANGUAGES CXX ASM)

message(STATUS "\n**********************************************************************************\n")
message(STATUS "\n## In directory: ${CMAKE_CURRENT_SOURCE_DIR}")

message("\n** Setting up ${PROJECT_NAME} **\n")

include(functions)

set(PROJECT_TARGET_NAME ${PROJECT_NAME}.elf)

set(PROJECT_COMPILE_DEFINITIONS_CXX_PRIVATE )
set(PROJECT_COMPILE_DEFINITIONS_CXX_PUBLIC )

set(PROJECT_COMPILE_OPTIONS_CXX_PRIVATE
    -Wall -O2 -ffreestanding -nostdinc -nostdlib -nostartfiles
    )
set(PROJECT_COMPILE_OPTIONS_CXX_PUBLIC )

set(PROJECT_INCLUDE_DIRS_PRIVATE )
set(PROJECT_INCLUDE_DIRS_PUBLIC )

set(PROJECT_LINK_OPTIONS ${CMAKE_EXE_LINKER_FLAGS} -nostdlib -nostartfiles -T ${CMAKE_CURRENT_SOURCE_DIR}/link.ld)

set(PROJECT_DEPENDENCIES )

set(PROJECT_LIBS
    ${PROJECT_DEPENDENCIES}
    )
set(PROJECT_SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/src/main.cpp
    )

set(PROJECT_INCLUDES_PUBLIC )
set(PROJECT_INCLUDES_PRIVATE )

if (CMAKE_HOST_UNIX)
    set(START_GROUP -Wl,--start-group)
    set(END_GROUP -Wl,--end-group)
endif()

add_executable(${PROJECT_NAME} ${PROJECT_SOURCES} ${PROJECT_INCLUDES_PUBLIC} ${PROJECT_INCLUDES_PRIVATE})

target_link_libraries(${PROJECT_NAME} ${START_GROUP} ${PROJECT_LIBS} ${END_GROUP})
target_include_directories(${PROJECT_NAME} PRIVATE ${PROJECT_INCLUDE_DIRS_PRIVATE})
target_include_directories(${PROJECT_NAME} PUBLIC  ${PROJECT_INCLUDE_DIRS_PUBLIC})
target_compile_definitions(${PROJECT_NAME} PRIVATE ${PROJECT_COMPILE_DEFINITIONS_CXX_PRIVATE})
target_compile_definitions(${PROJECT_NAME} PUBLIC  ${PROJECT_COMPILE_DEFINITIONS_CXX_PUBLIC})
target_compile_options(${PROJECT_NAME} PRIVATE ${PROJECT_COMPILE_OPTIONS_CXX_PRIVATE})
target_compile_options(${PROJECT_NAME} PUBLIC  ${PROJECT_COMPILE_OPTIONS_CXX_PUBLIC})

list_to_string(PROJECT_LINK_OPTIONS PROJECT_LINK_OPTIONS_STRING)
if (NOT "${PROJECT_LINK_OPTIONS_STRING}" STREQUAL "")
    set_target_properties(${PROJECT_NAME} PROPERTIES LINK_FLAGS "${PROJECT_LINK_OPTIONS_STRING}")
endif()
set_target_properties(${PROJECT_NAME} PROPERTIES OUTPUT_NAME ${PROJECT_TARGET_NAME})
set_target_properties(${PROJECT_NAME} PROPERTIES ARCHIVE_OUTPUT_DIRECTORY ${OUTPUT_LIB_DIR})
set_target_properties(${PROJECT_NAME} PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${OUTPUT_BIN_DIR})

add_subdirectory(create-image)
```

As you can see, it does pretty much the same as the second part in our 00-build project.

- It defines the project, in this case `demo`. Notice that here we specify both C++ and assembly as source languages.
- We print the current directory, and also which project we're going to configure.
- Then we again specift the project target file, the compiler definitions, compiler options, include directories, and linker options.
- We specify which libraries we depend upon, and which libraries we link to.
- We then specify which source and header files are used for this application. Notice that the main.cpp is now in the src subdirectory. This keeps project files and source files separated.
- We define the executable, which files are used to build it, which libraries it links to, which include directories it used, while compiler definitions and options, we again use th same trick to specify the linker options, and then specify the executable name and directories.
- Notice that the directories now use the new variables `OUTPUT_LIB_DIR` and `OUTPUT_BIN_DIR`.
- And finally we include the `CMakeLists.txt` for the image creation project.

The `CMakeLists.txt` file in `code/applications/demo/createimage` defines the project to create the image:

```cmake
project(demo-image
    DESCRIPTION "Kernel image for demo RPI 64 bit bare metal")

message(STATUS "\n**********************************************************************************\n")
message(STATUS "\n## In directory: ${CMAKE_CURRENT_SOURCE_DIR}")

message("\n** Setting up ${PROJECT_NAME} **\n")

set(BAREMETAL_TARGET_KERNEL kernel8)
set(DEPENDENCY demo)
set(IMAGE_NAME ${BAREMETAL_TARGET_KERNEL}.img)

create_image(${PROJECT_NAME} ${IMAGE_NAME} ${DEPENDENCY})
```

Again this is very much like what we saw for `tutorial/00-build/create-image`. The only different is the dependency and the project name.

### Building

As now we have a common structure, it may be helpful to create some scripts to help us build.

#### Configuring CMake

We will create a script for Windows and for Linux to configure the build. They will be placed in the tools directory underneath the root directory:

##### Windows

tools/configure.bat:
```bat
@echo off
rmdir /s /q cmake-build
mkdir cmake-build
pushd cmake-build

cmake .. -G Ninja -DCMAKE_BUILD_TYPE:STRING="Debug" -DCMAKE_TOOLCHAIN_FILE:FILEPATH=../baremetal.toolchain

popd
```

Running the script:
```bat
tools\configure.bat
```

```text
-- CMake 3.27.8
-- TOOLCHAIN_ROOT           D:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf
-- Processor                aarch64
-- Platform tuple           aarch64-none-elf
-- Assembler
-- C compiler               D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-gcc.exe
-- C++ compiler             D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-g++.exe
-- Archiver                 D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-ar.exe
-- Linker                   D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-ld.exe
-- ObjCopy                  D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-objcopy.exe
-- Std include path         D:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1/include
-- CMAKE_EXE_LINKER_FLAGS=
-- Adding to CMAKE_EXE_LINKER_FLAGS -LD:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1
-- TOOLCHAIN_ROOT           D:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf
-- Processor                aarch64
-- Platform tuple           aarch64-none-elf
-- Assembler
-- C compiler               D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-gcc.exe
-- C++ compiler             D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-g++.exe
-- Archiver                 D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-ar.exe
-- Linker                   D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-ld.exe
-- ObjCopy                  D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-objcopy.exe
-- Std include path         D:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1/include
-- CMAKE_EXE_LINKER_FLAGS=   -LD:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1
-- The C compiler identification is GNU 13.2.1
-- The CXX compiler identification is GNU 13.2.1
--
**********************************************************************************

--
## In directory: D:/Projects/baremetal.github/code
--
**********************************************************************************

--
## In directory: D:/Projects/baremetal.github/code/applications
-- The ASM compiler identification is GNU
-- Found assembler: D:/Toolchains/arm-gnu-toolchain-13.2.Rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-gcc.exe
--
**********************************************************************************

--
## In directory: D:/Projects/baremetal.github/code/applications/demo

** Setting up demo **

--
**********************************************************************************

--
## In directory: D:/Projects/baremetal.github/code/applications/demo/create-image

** Setting up demo-image **

-- create_image demo-image kernel8.img demo
-- TARGET_NAME demo.elf
-- generate D:/Projects/baremetal.github/deploy/Debug/demo-image/kernel8.img from D:/Projects/baremetal.github/output/Debug/bin/demo
--
**********************************************************************************

--
## In directory: D:/Projects/baremetal.github/code/libraries
-- Configuring done (1.0s)
-- Generating done (0.0s)
-- Build files have been written to: D:/Projects/baremetal.github/cmake-build
```

##### Linux

tools/configure.sh:
```bash
rm -rf cmake-build/
mkdir cmake-build
pushd cmake-build

cmake .. -G Ninja -DCMAKE_BUILD_TYPE:STRING="Debug" -DCMAKE_TOOLCHAIN_FILE:FILEPATH=../baremetal.toolchain

popd
```

Running the script:
```bat
tools/configure.sh
```

```text
~/repo/baremetal.github/cmake-build ~/repo/baremetal.github
-- CMake 3.25.1
-- TOOLCHAIN_ROOT           /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf
-- Processor                aarch64
-- Platform tuple           aarch64-none-elf
-- Assembler
-- C compiler               /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/bin/aarch64-none-elf-gcc
-- C++ compiler             /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/bin/aarch64-none-elf-g++
-- Archiver                 /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/bin/aarch64-none-elf-ar
-- Linker                   /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/bin/aarch64-none-elf-ld
-- ObjCopy                  /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/bin/aarch64-none-elf-objcopy
-- Std include path         /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1/include
-- CMAKE_EXE_LINKER_FLAGS=
-- Adding to CMAKE_EXE_LINKER_FLAGS -L/opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1
-- TOOLCHAIN_ROOT           /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf
-- Processor                aarch64
-- Platform tuple           aarch64-none-elf
-- Assembler
-- C compiler               /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/bin/aarch64-none-elf-gcc
-- C++ compiler             /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/bin/aarch64-none-elf-g++
-- Archiver                 /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/bin/aarch64-none-elf-ar
-- Linker                   /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/bin/aarch64-none-elf-ld
-- ObjCopy                  /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/bin/aarch64-none-elf-objcopy
-- Std include path         /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1/include
-- CMAKE_EXE_LINKER_FLAGS=   -L/opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1
-- The C compiler identification is GNU 13.2.1
-- The CXX compiler identification is GNU 13.2.1
--
**********************************************************************************

--
## In directory: /home/rene/repo/baremetal.github/code
--
**********************************************************************************

--
## In directory: /home/rene/repo/baremetal.github/code/applications
-- The ASM compiler identification is GNU
-- Found assembler: /opt/toolchains/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/bin/aarch64-none-elf-gcc
--
**********************************************************************************

--
## In directory: /home/rene/repo/baremetal.github/code/applications/demo

** Setting up demo **

--
**********************************************************************************

--
## In directory: /home/rene/repo/baremetal.github/code/applications/demo/create-image

** Setting up demo-image **

-- create_image demo-image kernel8.img demo
-- TARGET_NAME demo.elf
-- generate /home/rene/repo/baremetal.github/deploy/Debug/demo-image/kernel8.img from /home/rene/repo/baremetal.github/output/Debug/bin/demo
--
**********************************************************************************

--
## In directory: /home/rene/repo/baremetal.github/code/libraries
-- Configuring done
-- Generating done
-- Build files have been written to: /home/rene/repo/baremetal.github/cmake-build
~/repo/baremetal.github
```

#### Building a specific target

##### Windows

tools/build-target.bat
```bat
cmake --build cmake-build --target %1
```

##### Linux

tools/build-target.sh
```bash
cmake --build cmake-build --target $1
```

#### Building a specific image

##### Windows

tools/build-image.bat
```bat
cmake --build cmake-build --target %1-image
```

##### Linux

tools/build-image.sh
```bash
cmake --build cmake-build --target $1-image
```

#### Building all targets

##### Windows

tools/build-all.bat
```bat
cmake --build cmake-build
```

Running the build:
```bat
tools\build-all.bat
```

```text
[3/3] Generating D:/Projects/baremetal.github/deploy/Debug/demo-image/kernel8.img
```

##### Linux

tools/build-all.sh
```bash
cmake --build cmake-build
```

Running the build:
```bash
tools/build-all.sh
```

```text
[3/3] Generating /home/rene/repo/baremetal.github/deploy/Debug/demo-image/kernel8.img
```

#### Starting QEMU

##### Windows

Start QEMU listening to UART0

tools/startQEMU-image-uart0.bat
```bat
set thisdir=%~dp0

call build-target %thisdir%\%1
"c:\Program Files\qemu\qemu-system-aarch64.exe" -M raspi3b -kernel %CD%\deploy\Debug\%1-image\kernel8.img -serial stdio -s -S
```

Start QEMU listening to UART1

tools/startQEMU-image-uart1.bat
```bat
set thisdir=%~dp0

call build-target %thisdir%\%1
"c:\Program Files\qemu\qemu-system-aarch64.exe" -M raspi3b -kernel %CD%\deploy\Debug\%1-image\kernel8.img -serial null -serial stdio -s -S
```

Explanation:
- We start QEMU here to emulate Raspberry Pi 3B
- We use the specified image for the kernel. 
- We either listen to the first serial or the second (the first is then set to null).
- We start a gdb server at port 1234
- We do not start the system immediately, but let it wait for gdb.

When starting QEMU on UART0:
```bat
tools\startQEMU-image-uart0.bat demo
```

```text
"c:\Program Files\qemu\qemu-system-aarch64.exe" -M raspi3b -kernel D:\Projects\baremetal.github\deploy\Debug\demo-image\kernel8.img -serial stdio -s -S

(qemu:9828): Gtk-WARNING **: 22:22:56.966: Could not load a pixbuf from icon theme.
This may indicate that pixbuf loaders or the mime database could not be found.
```

##### Linux

Start QEMU listening to UART0

tools/startQEMU-image-uart0.sh
```bash
thisdir=$(dirname "$0")
echo thisdir=$thisdir

echo "$thisdir/build-target.sh $1"
$thisdir/build-target.sh $1

echo qemu-system-aarch64 -M raspi3b -kernel $thisdir/../deploy/Debug/$1-image/kernel8.img -serial stdio -s -S
qemu-system-aarch64 -M raspi3b -kernel $thisdir/../deploy/Debug/$1-image/kernel8.img -serial stdio -s -S
```

Start QEMU listening to UART1

tools/startQEMU-image-uart1.sh
```bash
thisdir=$(dirname "$0")
echo thisdir=$thisdir

echo "$thisdir/build-target.sh $1"
$thisdir/build-target.sh $1

echo qemu-system-aarch64 -M raspi3b -kernel $thisdir/../deploy/Debug/$1-image/kernel8.img -serial null -serial stdio -s -S
qemu-system-aarch64 -M raspi3b -kernel $thisdir/../deploy/Debug/$1-image/kernel8.img -serial null -serial stdio -s -S
```

Explanation:
- We start QEMU here to emulate Raspberry Pi 3B
- We use the specified image for the kernel. 
- We either listen to the first serial or the second (the first is then set to null).
- We start a gdb server at port 1234
- We do not start the system immediately, but let it wait for gdb.

When starting QEMU on UART0:
```bash
tools/startQEMU-image-uart0.sh
```

```text
rootdir=/home/rene/repo/baremetal.github
```

#### Starting GDB

When starting GDB, we need a way to specify GDB to connect to our QEMU gdb server. We do that using a command file:

tools/gdb-commands.txt
```text
target remote localhost:1234
```

##### Windows

tools/startgdb.bat
```bat
D:\Toolchains\arm-gnu-toolchain-13.2.Rel1-mingw-w64-i686-aarch64-none-elf\bin\aarch64-none-elf-gdb.exe -x %CD%\tools\gdb-commands.txt -symbols=%CD%\output\Debug\bin\%1.elf
```

We specify the command file, and also the symbol file to load

Starting GDB:
```bat
tools\startgdb.bat demo
```

```text
D:\Toolchains\arm-gnu-toolchain-13.2.Rel1-mingw-w64-i686-aarch64-none-elf\bin\aarch64-none-elf-gdb.exe -x D:\Projects\baremetal.github\tools\commands.txt -symbols=D:\Projects\baremetal.github\output\Debug\bin\demo.elf
GNU gdb (Arm GNU Toolchain 13.2.rel1 (Build arm-13.7)) 13.2.90.20231008-git
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "--host=i686-w64-mingw32 --target=aarch64-none-elf".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://bugs.linaro.org/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from D:\Projects\baremetal.github\output\Debug\bin\demo.elf...
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x0000000000000000 in ?? ()
```

##### Linux

tools/startgdb.sh
```bash
rootdir=`pwd`
gdb-multiarch -x $rootdir/tools/gdb-commands.txt -symbols=$rootdir/output/Debug/bin/$1.elf
```

We specify the command file, and also the symbol file to load

Starting GDB:
```bat
tools/startgdb.sh demo
```

```text
GNU gdb (Debian 13.1-3) 13.1
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /home/rene/repo/baremetal.github/output/Debug/bin/demo.elf...
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x0000000000000000 in ?? ()
```

## Visual Studio CMake integration

When using Visual Studio, there are two methods to integrate CMake projects.

1. Using `CMakePresets.json`
2. Using `CMakeSettings.json`

For Visual Studio 2019, getting things to work for baremetal development did not go well using `CMakePresets.json`, so we will focus on using `CMakeSettings.json` here.
Maybe later I will give the first option another go.

`CMakeSettings.json` is aa JSON file, containing a section for every platform / build you wish to use. For now, let's just add a baremetal Debug build target:

```cmake
{
  "environments": [ {} ],
  "configurations": [
    {
      "name": "BareMetal-Debug",
      "generator": "Ninja",
      "configurationType": "Debug",
      "buildRoot": "${projectDir}\\cmake-${name}",
      "installRoot": "${projectDir}\\output\\install\\${name}",
      "cmakeCommandArgs": "-DVERSION_NUMBER=\"1.0.0\" -DVERBOSE_BUILD=ON -DBAREMETAL_RPI_TARGET=3 -DBAREMETAL_CONSOLE_UART0=ON",
      "buildCommandArgs": "",
      "ctestCommandArgs": "",
      "cmakeToolchain": "${projectDir}\\baremetal.toolchain",
      "inheritEnvironments": [ "gcc-arm" ]
    }
  ]
}
```

The environments section could contain environment variables common for all build configurations, but is left empty here.
The configurations section will contain an array of build configurations, here consisting of a single configuration.

- `name` is the name of the configuration, which is what you will be able to select in the Configurations dropdown box in Visual Studio. This has to be unique.
- `generator` settings will define how to build a CMake project. This can be one of many, check `cmake --help` for the list. Visual Studio will select `Ninja` as the default for CMake project, which is what we're going to use.
- `configurationType` specifies what kind of build we're going to perform. This is one of the CMake build types (Debug, Release, RelWithDebInfo, MinSizeRel).
- `buildRoot` setting is the cmake build directory to be using. Until now, we've been using `cmake-build`, we'll use `cmake-${name}` here, where `${name}` is the `name` of the configuration, resulting in `cmake-Baremetal-Debug`.
- `installRoot` is not so relevant now, but is the directory root used when executing an install target. We set it to `${projectDir}\\output\\install\\${name}`, in other words it will be in the ouput\install directory, under a subdirectory named after the CMake project we're building.
- `cmakeCommandArgs` will specify the CMake definitions we wish to pass. These variable will be defned in our CMake scrips. We specify the variables as "-DVERSION_NUMBER=\"1.0.0\" -DVERBOSE_BUILD=ON -DBAREMETAL_RPI_TARGET=3 -DBAREMETAL_CONSOLE_UART0=ON", all of which we are not used yet, but will later on.
- `buildCommandArgs` specifies additional parameters to pass on to CMake for building. We are not using any.
- `ctestCommandArgs` specifies additional parameters when running CMake in test mode. As we will not be using CMake for testing, this is empty.
- `cmakeToolchain` specifies the toolchain file to be using. This is important for us, as we use the toolchain file to select our build toolchain for baremetal building. We've places the file in the root directory, so the location is `${projectDir}\\baremetal.toolchain`
- `inheritEnvironments` is used to re-use standard settings from Visual Studio. As we're building for ARM targets and we have a GNU toolchain, it is set to `gcc-arm`

As soon as the `CMakeSettings.json` file is saved, you will see that Visual Studio recognizes it. 
If you were not using Visual Studio yet, you can open the project by first starting Visual Studio 2019, and then selecting "Open a local folder". 

![Visual Studio start screen](images/VisualStudioOpenProject.png)

In the dialog that pops up select the root folder of your project (the folder that contains the `CMakeSettings.json`, `baremetal.toolchain` and main `CMakeLists.txt` file). The click "Select Folder"

![Visual Studio select root folder](images/VisualStudioSelectProjectFolder.png)

Visual Studio will now open your project folder, and start loading `CMakeSettings.json`. After loading, it will select the first configuration in your `CMakeSettings.json` file, in this case "Baremetal-Debug".

Depending on whether you selected to always generate CMake configuration or not, it will also automatically configure your project. If not, you can always force configuration of CMake by selecting `Project->Configure baremetal`.
Notice that baremetal is mentioned here, which is the name of the top level project defined in the main `CMakeLists.txt`.

Sometimes, the configuration does not match the actual state of the `CMakeLists.txt` well (especially when building for multiple different platforms and changing one platform to the other). 
In that case you can click `Project->CMake Cache (Baremetal-Debug Only)->Delete Cache`. Again notice that the select configuration is shown.
This will completely remove the CMake cache for this configuration (`CMakeCache.txt`).

### Configuring CMake

After automatically or manually configuring CMake, the Output panel at the bottom will show the CMake output:

```text
1> CMake generation started for configuration: 'BareMetal-Debug'.
1> Command line: "C:\Windows\system32\cmd.exe" /c "%SYSTEMROOT%\System32\chcp.com 65001 >NUL && "C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\COMMON7\IDE\COMMONEXTENSIONS\MICROSOFT\CMAKE\CMake\bin\cmake.exe"  -G "Ninja"  -DCMAKE_BUILD_TYPE:STRING="Debug" -DCMAKE_INSTALL_PREFIX:PATH="D:\Projects\baremetal.github\output\install\BareMetal-Debug" -DCMAKE_TOOLCHAIN_FILE:FILEPATH="D:\Projects\baremetal.github\baremetal.toolchain" -DVERSION_NUMBER="1.0.0" -DVERBOSE_BUILD=ON -DBAREMETAL_RPI_TARGET=3 -DBAREMETAL_CONSOLE_UART0=ON -DCMAKE_MAKE_PROGRAM="C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\COMMON7\IDE\COMMONEXTENSIONS\MICROSOFT\CMAKE\Ninja\ninja.exe" "D:\Projects\baremetal.github" 2>&1"
1> Working directory: D:\Projects\baremetal.github\cmake-BareMetal-Debug
1> [CMake] -- CMake 3.20.21032501-MSVC_2
1> [CMake] -- TOOLCHAIN_ROOT           D:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf
1> [CMake] -- Processor                aarch64
1> [CMake] -- Platform tuple           aarch64-none-elf
1> [CMake] -- Assembler                
1> [CMake] -- C compiler               D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-gcc.exe
1> [CMake] -- C++ compiler             D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-g++.exe
1> [CMake] -- Archiver                 D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-ar.exe
1> [CMake] -- Linker                   D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-ld.exe
1> [CMake] -- ObjCopy                  D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-objcopy.exe
1> [CMake] -- Std include path         D:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1/include
1> [CMake] -- CMAKE_EXE_LINKER_FLAGS=  
1> [CMake] -- Adding to CMAKE_EXE_LINKER_FLAGS -LD:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1
1> [CMake] -- TOOLCHAIN_ROOT           D:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf
1> [CMake] -- Processor                aarch64
1> [CMake] -- Platform tuple           aarch64-none-elf
1> [CMake] -- Assembler                
1> [CMake] -- C compiler               D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-gcc.exe
1> [CMake] -- C++ compiler             D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-g++.exe
1> [CMake] -- Archiver                 D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-ar.exe
1> [CMake] -- Linker                   D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-ld.exe
1> [CMake] -- ObjCopy                  D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-objcopy.exe
1> [CMake] -- Std include path         D:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1/include
1> [CMake] -- CMAKE_EXE_LINKER_FLAGS=   -LD:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1
1> [CMake] -- The C compiler identification is GNU 13.2.1
1> [CMake] -- The CXX compiler identification is GNU 13.2.1
1> [CMake] -- 
1> [CMake] **********************************************************************************
1> [CMake] 
1> [CMake] -- 
1> [CMake] ## In directory: D:/Projects/baremetal.github/code
1> [CMake] -- 
1> [CMake] **********************************************************************************
1> [CMake] 
1> [CMake] -- 
1> [CMake] ## In directory: D:/Projects/baremetal.github/code/applications
1> [CMake] -- The ASM compiler identification is GNU
1> [CMake] -- Found assembler: D:/Toolchains/arm-gnu-toolchain-13.2.Rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-gcc.exe
1> [CMake] -- 
1> [CMake] **********************************************************************************
1> [CMake] 
1> [CMake] -- 
1> [CMake] ## In directory: D:/Projects/baremetal.github/code/applications/demo
1> [CMake] 
1> [CMake] ** Setting up demo **
1> [CMake] 
1> [CMake] -- 
1> [CMake] **********************************************************************************
1> [CMake] 
1> [CMake] -- 
1> [CMake] ## In directory: D:/Projects/baremetal.github/code/applications/demo/create-image
1> [CMake] 
1> [CMake] ** Setting up demo-image **
1> [CMake] 
1> [CMake] -- create_image demo-image kernel8.img demo
1> [CMake] -- TARGET_NAME demo.elf
1> [CMake] -- generate D:/Projects/baremetal.github/deploy/Debug/demo-image/kernel8.img from D:/Projects/baremetal.github/output/Debug/bin/demo
1> [CMake] -- 
1> [CMake] **********************************************************************************
1> [CMake] 
1> [CMake] -- 
1> [CMake] ## In directory: D:/Projects/baremetal.github/code/libraries
1> [CMake] -- Configuring done
1> [CMake] -- Generating done
1> [CMake] CMake Warning:
1> [CMake]   Manually-specified variables were not used by the project:
1> [CMake] 
1> [CMake]     BAREMETAL_CONSOLE_UART0
1> [CMake]     BAREMETAL_RPI_TARGET
1> [CMake]     VERBOSE_BUILD
1> [CMake]     VERSION_NUMBER
1> [CMake] 
1> [CMake] 
1> [CMake] -- Build files have been written to: D:/Projects/baremetal.github/cmake-BareMetal-Debug
1> Extracted CMake variables.
1> Extracted source files and headers.
1> Extracted code model.
1> Extracted toolchain configurations.
1> Extracted includes paths.
1> CMake generation finished.
```

If the toolchain was already checked, the output will be shorter:

```text
1> CMake generation started for configuration: 'BareMetal-Debug'.
1> Command line: "C:\Windows\system32\cmd.exe" /c "%SYSTEMROOT%\System32\chcp.com 65001 >NUL && "C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\COMMON7\IDE\COMMONEXTENSIONS\MICROSOFT\CMAKE\CMake\bin\cmake.exe"  -G "Ninja"  -DCMAKE_BUILD_TYPE:STRING="Debug" -DCMAKE_INSTALL_PREFIX:PATH="D:\Projects\baremetal.github\output\install\BareMetal-Debug" -DCMAKE_TOOLCHAIN_FILE:FILEPATH="D:\Projects\baremetal.github\baremetal.toolchain" -DVERSION_NUMBER="1.0.0" -DVERBOSE_BUILD=ON -DBAREMETAL_RPI_TARGET=3 -DBAREMETAL_CONSOLE_UART0=ON -DCMAKE_MAKE_PROGRAM="C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\COMMON7\IDE\COMMONEXTENSIONS\MICROSOFT\CMAKE\Ninja\ninja.exe" "D:\Projects\baremetal.github" 2>&1"
1> Working directory: D:\Projects\baremetal.github\cmake-BareMetal-Debug
1> [CMake] -- CMake 3.20.21032501-MSVC_2
1> [CMake] -- TOOLCHAIN_ROOT           D:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf
1> [CMake] -- Processor                aarch64
1> [CMake] -- Platform tuple           aarch64-none-elf
1> [CMake] -- Assembler                D:/Toolchains/arm-gnu-toolchain-13.2.Rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-gcc.exe
1> [CMake] -- C compiler               D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-gcc.exe
1> [CMake] -- C++ compiler             D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-g++.exe
1> [CMake] -- Archiver                 D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-ar.exe
1> [CMake] -- Linker                   D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-ld.exe
1> [CMake] -- ObjCopy                  D:/toolchains/arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/bin/aarch64-none-elf-objcopy.exe
1> [CMake] -- Std include path         D:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1/include
1> [CMake] -- CMAKE_EXE_LINKER_FLAGS=   -LD:\toolchains\arm-gnu-toolchain-13.2.rel1-mingw-w64-i686-aarch64-none-elf/lib/gcc/aarch64-none-elf/13.2.1
1> [CMake] -- 
1> [CMake] **********************************************************************************
1> [CMake] 
1> [CMake] -- 
1> [CMake] ## In directory: D:/Projects/baremetal.github/code
1> [CMake] -- 
1> [CMake] **********************************************************************************
1> [CMake] 
1> [CMake] -- 
1> [CMake] ## In directory: D:/Projects/baremetal.github/code/applications
1> [CMake] -- 
1> [CMake] **********************************************************************************
1> [CMake] 
1> [CMake] -- 
1> [CMake] ## In directory: D:/Projects/baremetal.github/code/applications/demo
1> [CMake] 
1> [CMake] ** Setting up demo **
1> [CMake] 
1> [CMake] -- 
1> [CMake] **********************************************************************************
1> [CMake] 
1> [CMake] -- 
1> [CMake] ## In directory: D:/Projects/baremetal.github/code/applications/demo/create-image
1> [CMake] 
1> [CMake] ** Setting up demo-image **
1> [CMake] 
1> [CMake] -- create_image demo-image kernel8.img demo
1> [CMake] -- TARGET_NAME demo.elf
1> [CMake] -- generate D:/Projects/baremetal.github/deploy/Debug/demo-image/kernel8.img from D:/Projects/baremetal.github/output/Debug/bin/demo
1> [CMake] -- 
1> [CMake] **********************************************************************************
1> [CMake] 
1> [CMake] -- 
1> [CMake] ## In directory: D:/Projects/baremetal.github/code/libraries
1> [CMake] -- Configuring done
1> [CMake] -- Generating done
1> [CMake] -- Build files have been written to: D:/Projects/baremetal.github/cmake-BareMetal-Debug
1> Extracted CMake variables.
1> Extracted source files and headers.
1> Extracted code model.
1> Extracted toolchain configurations.
1> Extracted includes paths.
1> CMake generation finished.
```

After this, the CMake build directory is created, and CMake is configured, much like when you would run `tools\configure.bat` or `tools/configure.sh` on the command line.

### Building

After configuration is done, we can build the project, using `Build->Build All` or `Build->Rebuild All`. This will build or rebuild everything.
Another option is selecting the project to be built in the dropdown box next to the configuration, "Select Startup Items...".

![Select build target](images/VisualStudioSelectBuildTarget.png)

![Select build target](images/VisualStudioBuildTargetSelected.png)

When a build target is selected, it can also be built using `Build->Build <target>` or `Build->Rebuild <target>`

Please be aware that in the current view, `Solution Explorer`, it is not possible to select the `demo-image` target.

![Select build target](images/VisualStudioSolutionExplorer.png)

In order for all possible targets to be built, we need to change the view. 
For this click on the button "Switch between solutions and available views", and then double-click "CMake Targets View".

![Select build target](images/VisualStudioSolutionSwitchView.png)

![Select build target](images/VisualStudioSelectCMakeTargetsView.png)

![Select build target](images/VisualStudioCMakeTargetsView.png)

Going back to Solution Explorer can be done using the same mechanism, but then double-clicking "Folder View".

When in CMake Targets View, you can build a project by right clicking the project (e.g. demo-image (utility target)) and selecting "Build".

Running "Build All" or "Rebuild All" however does build all projects, including demo-image:

```text
>------ Build All started: Project: baremetal, Configuration: BareMetal-Debug ------
  [1/3] Building CXX object code/applications/demo/CMakeFiles/demo.dir/src/main.cpp.obj
  [2/3] Linking CXX executable ..\output\Debug\bin\demo.elf
  [3/3] Generating ../../../../../deploy/Debug/demo-image/kernel8.img

Build All succeeded.
```

As you can see, both `demo.elf` and `kernel8.img` have been built.

### Debugging

As already stated in [Debugging](setting-up-for-development.md#Debugging) it is possible to debug on a real board using a FTDI JTAG adapter. However this is not trivial and will be skipped for now.
So we'll debug the application from Visual Studio using QEMU.

As we've now changed our CMake build directory, we will update all scripts to use `cmake-Baremetal-Debug` instead of `cmake-build`:

- build-all.bat
- build-all.sh
- build-image.bat
- build-image.sh
- build-target.bat
- build-target.sh
- configure.bat
- configure.sh

First, we start QEMU. We could use a QEMU instance on Linux, however, as we are building on Windows, it is logical to use QEMU on Windows.
Starting QEMU will automaticall refresh the build for our image:

```bat
tools\startQEMU-image-uart0.bat demo
```

Now we need to configure Visual Studio to debug our project correctly. This is one of the less practical things in Visual Studio.

For every executable we wish to debug, for every configuration we wish to use, we need to add a section in the file .vs/launch.vs.json.
The .vs folder is not visible inside our project, however it does exist. 
The easiest way to configure our target for debugging is making sure it is selected in the "Select Startup Items..." dropdown, and the selecting `Debug->Debug and Launch Settings for <project>`

Visual Studio will then show the current contents of the file, and select the section that refers to our project:

```text
{
  "version": "0.2.1",
  "defaults": {},
  "configurations": [
    {
      "type": "default",
      "project": "CMakeLists.txt",
      "projectTarget": "demo.elf (D:\\Projects\\baremetal.github\\output\\Debug\\bin\\demo.elf)",
      "name": "demo.elf (D:\\Projects\\baremetal.github\\output\\Debug\\bin\\demo.elf)"
    }
  ]
}
```

The default contents generated by Visual Studio are not completely correct for our purpose, so we'll need to change them:

```text
{
  "version": "0.2.1",
  "defaults": {},
  "configurations": [
    {
      "type": "cppgdb",
      "project": "CMakeLists.txt",
      "projectTarget": "demo.elf (D:\\Projects\\baremetal.github\\output\\Debug\\bin\\demo.elf)",
      "name": "demo.elf (D:\\Projects\\baremetal.github\\output\\Debug\\bin\\demo.elf)",
      "program": "demo.elf",
      "request": "launch",
      "stopAtEntry": false,
      "cwd": "D:\\Projects\\baremetal.github\\output\\Debug\\bin",
      "externalConsole": true,
      "MIMode": "gdb",
      "targetArchitecture": "arm64",
      "miDebuggerServerAddress": "localhost:1234",
      "miDebuggerPath": "D:\\Toolchains\\arm-gnu-toolchain-13.2.Rel1-mingw-w64-i686-aarch64-none-elf\\bin\\aarch64-none-elf-gdb.exe",
      "args": [],
      "env": {}
    }
  ]
}
```

Explanation:
- `type` specifies which kind of debugger we are using. For GDB, this must be `cppgdb`
- `project` specifies the kind of project, which is `CMakeLists.txt` for CMake projects
- `projectTarget` is the selected target, this must be equal to the selected target in the "Select Startup Items..." dropbox box
- `name` is the name of the project, this must be equal to the selected target in the "Select Startup Items..." dropbox box
- `program` is the executable name, in this case `demo.elf`
- `request` is the way the debugger starts the session. As we would like to start our application, we use `launch`
- `stopAtEntry` determines whether the debugger will stop at the first code or not. We set this to `false`, as we will simply put a breakpoint at the first line of code
- `cwd` will be the working directory used for debugging. It is best to select the directory from which the application is loaded, so `D:\\Projects\\baremetal.github\\output\\Debug\\bin`. Notice the double backslashes to excape single ones
- `externalConsole` determines whether a console is created. We set this to `true` so a console is created in the lower panel
- `MIMode` determines which debugger is used, this is set to `gdb`
- `targetArchitecture` specifies which archecture is used on the target. As we are using a 64 bit ARM archittecture, this is set to `arm64`
- `miDebuggerServerAddress` specifies the host and port of the debug server, in this case QEMU. QEMU starts a server on the same machine on port 1234, so we set this to `localhost:1234`
- `miDebuggerPath` specifies the path to the gdb application we are using. We'll use the same one as specified before, which is part of the toolchain. So we specify `D:\\Toolchains\\arm-gnu-toolchain-13.2.Rel1-mingw-w64-i686-aarch64-none-elf\\bin\\aarch64-none-elf-gdb.exe`
- `args` specifies command line arguments for the application being debugged. As our application is baremetal, we have no parameters, so we set it to an empty array `[]`
- `env` specifies a set of key-value pairs of environment variables passed. We set this to the empty set `{}`

Now, when we save .vs\launch.vs.json, we can start debugging.

First we open the source file and set a breakpoint on the first line.
Then we start the debugger by either clicking on the "Selected Startup Item" button, or by selecting Debug->Start Debugging

The program breaks on the first sensible line after the breakpoint, which is actually inside the main function.

![Debug window](images/VisualStudioDebug.png)

In the Output tab, we can also see the output of the debugger:

```text
=thread-group-added,id="i1"
GNU gdb (Arm GNU Toolchain 13.2.rel1 (Build arm-13.7)) 13.2.90.20231008-git
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "--host=i686-w64-mingw32 --target=aarch64-none-elf".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://bugs.linaro.org/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word".
Warning: 'set target-async', an alias for the command 'set mi-async', is deprecated.
Use 'set mi-async'.

=cmd-param-changed,param="pagination",value="off"
0x0000000000000000 in ?? ()

Thread 1 hit Breakpoint 1, main () at ../code/applications/demo/src/main.cpp:3
3	    return 0;
```

You can now step through the code using the normal buttons / keys:

- F5: Run
- F10: Step over
- F11: Step in
- Shift+F11: Step out
- Ctrl+F10: Run to cursor

As there is not much to debug, you cannot really step through the code. You'll find that often you will get a tab `Source Not Available` as you are stepping outside your code. This is annoying sometimes.
Also, you will see that if you run the code using F5, it will keep breaking on the same line. This is because QEMU restarts the application when it ends.
