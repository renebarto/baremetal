# Tutorial 21: I2C {#TUTORIAL_21_I2C}

@tableofcontents

## New tutorial setup {#TUTORIAL_21_I2C_NEW_TUTORIAL_SETUP}

As in the previous tutorial, you will find the code integrated into the CMake structure, in `tutorial/21-i2c`.
In the same way, the project names are adapted to make sure there are no conflicts.

### Tutorial results {#TUTORIAL_21_I2C_NEW_TUTORIAL_SETUP_TUTORIAL_RESULTS}

This tutorial will result in (next to the main project structure):
- a library `output/Debug/lib/baremetal-21.a`
- a library `output/Debug/lib/device-21.a`
- a library `output/Debug/lib/stdlib-21.a`
- an application `output/Debug/bin/21-i2c.elf`
- an image in `deploy/Debug/21-i2c-image`

## What is I2C {#TUTORIAL_21_I2C_WHAT_IS_I2C}

I2C (called IIC or I-square-C) is a very simple serial bus meant for communication on short distance, initially meant for IC to IC communication.
Hence its name `Inter IC Communication` or IIC (I2C).
The bus has a clock signal, named SCL, and a data signal, called SDA. This is why it is also sometimes called Two Wire Communication (TWC).

<img src="images/i2c-single-master-single-slave.png"  alt="I2C bus" width="600"/>

I2C uses the concept of a master and slave. The master is in control of the clock, the slave listens to it.
However the roles of master and slave can be reversed, and there can be multiple masters and slaves, however only one master can exist at any time.
Both SCL and SDA are pulled up with a resistor, meaning the idle state for each signal is high or `1`.

I2C was initially intended to run at a 100 KHz clock, but nowadays can also be run at 400 KHz, 1 MHz, 1.7MHz, 3.4 MHz and 5 MHz.
The baseline is that the bus can run at the highest speed supported by all devices on the bus.

I will not go into all the details of the protocol, as there is a lot of information available, e.g. [Wikipedia](https://en.wikipedia.org/wiki/I%C2%B2C).

However, a few things need to be said to make things clear.

If a master wants to read or write a device, it will create a so-called `start condition`. It will then send the address, which will be acknowldged by the device being addressed, if any.
Then either the master (write) or the addressed slave device (read) will send data, until a `stop condition` is created.
Whether a read or write operation takes place is determined by the R/<u>W</u> bit (Read = 1, Write = 0) in the first byte sent containing the address.
The data sent can be any number of bytes, although most devices only support blocks of up to 256 bytes.
Addresses in I2C are either 7 or 10 bits, using a special pattern for 10 bit addresses:

| Address  | Bit 6 | Bit 5 | Bit 4 | Bit 3 | Bit 2 | Bit 1 | Bit 0 | Address               |
|----------|-------|-------|-------|-------|-------|-------|-------|-----------------------|
| 7 bit    |    A6 |    A5 |    A4 |    A3 |    A2 |    A1 |    A0 | Bit A2-A0 are often selectable in HW, bit A6-A3 are fixed by the device
| reserved |     0 |     0 |     0 |     0 |     X |     X |     X | Reserved addresses, not usable by devices
| 10 bit   |     1 |     1 |     1 |     1 |     0 |    A9 |    A8 | Special pattern A6-A2 = 11110 means 10 bit address, another byte with A7-A0 follows

The way data is read or written in I2C is shown in the image below.

<img src="images/i2c-protocol.png"  alt="I2C message protocol" width="800"/>

Slaves each have a fixed address, which is preprogrammed.

In the original protocol, there were 7 address bits, meaning 128 different addresses, however the first and last 8 addresses in this range are reserved, limiting the number of usable addresses to 112.
The 10 bit address mode, which would mean 1024 addresses, again reserves the same 16 addresses, so the maximum number of different addresses in this case is 1008.
Data is sent or received in chunks of 8 bits, but multiple such chuncks can be sent or received in one message.

Important is the <u>ACK</u>/NACK bit, which is a pause between two bytes.
By pulling the ACK bit low, the slave or master device acknowledges receiving.
If at any time the ack is not given, communication stops.

When scanning for devices on a bus, this is the way to determine whether a device is present at the specified address, simply by reading a single byte from the slave address.

There are many devices on the market supporting I2C, ranging from sensors, EEPROMs, memory modules, real time clocks, hardware monitors, actuators, DACs and ADCs, to displays.
The EDID (Extended Display Identification Data) such as used by HDMI is also I2C based.

Due to the fact that a chip has a preprogrammed address, how do we then support multiple of the same devices?
The answer is simple, we use a multiplexer, which splits up in mostly 8 new busses. One such multiplexer is [TCA9548](pdf/tca9548a.pdf).

Many devices however have extra pins to set the address within a subset, allowing multiple of the same devices to be addressed in parallel.

There are also devices that allow for direct input and output, so GPIO pins can also be controlled through I2C devices.
Two such devices are [MCP23008](pdf/mcp23008.pdf) (8 I/O) and [MCP23017](pdf/mcp23017.pdf) (16 I/O).

It would be nice to be able to control a simple 2 x 20 character display this way, however, as the programming of this device is quite some work, we'll postpone that until the next tutorial.
We'll start with a simpler device, the MCP23017, and control some LEDs from it.

## Actual hardware - MCP23017 {#TUTORIAL_21_I2C_ACTUAL_HARDWARE___MCP23017}

We'll use a circuit as depicted in [this diagram](pdf/MCP23017_LEDs.pdf):

<img src="images/MCP23017_LEDs.png" alt="MCP23017 controlling LEDs" width="1400"/>

You can build your own if you like, if not, just try to follow the tutorial, and look forward to where we will use an off-the-shelf LCD display.
We'll also be creating a stub for I2C, and implement the behaviour of the circuit, so you can at least follow what happens even if you don't have the actual hardware.

Raspberry Pi supports 7 and 10 bit addresses, and between 2 and 7 I2C buses.
The speed supported is either 100 Kbps, 400 Kbps or 1 Mbps.
See [Raspberry Pi I2C](#RASPBERRY_PI_I2C) for more information.

## Faking it - Step 1 {#TUTORIAL_21_I2C_FAKING_IT___STEP_1}

Before really attaching any devices, let's see if we can fake the I2C functionality, so we can debug our code a bit.
We'll do this, as in the previous tutorial for GPIO, by creating a IMemoryAccess instance that handling the access to I2C registers.
As we'll see, we'll also be re-using the GPIO stub due to the fact that we also need to program GPIO to correctly assign the I2C pins.

### BCMRegisters.h {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_BCMREGISTERSH}

First, we need to define register for the I2C devices.

Update the file `code/libraries/baremetal/include/baremetal/BCMRegisters.h`

```cpp
File: code/libraries/baremetal/include/baremetal/BCMRegisters.h
...
469: //---------------------------------------------
470: // Raspberry Pi I2C
471: //---------------------------------------------
472:
473: /// @brief Raspberry Pi I2C bus 0 registers base address.
474: #define RPI_I2C0_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205000)
475: /// @brief Raspberry Pi I2C bus 1 registers base address.
476: #define RPI_I2C1_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00804000)
477:
478: #if BAREMETAL_RPI_TARGET == 3
479: /// @brief Raspberry Pi I2C bus 2 registers base address.
480: #define RPI_I2C2_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00805000)
481: #elif BAREMETAL_RPI_TARGET == 4
482: /// @brief Raspberry Pi I2C bus 3 registers base address.
483: #define RPI_I2C3_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205600)
484: /// @brief Raspberry Pi I2C bus 4 registers base address.
485: #define RPI_I2C4_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205800)
486: /// @brief Raspberry Pi I2C bus 5 registers base address.
487: #define RPI_I2C5_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205A80)
488: /// @brief Raspberry Pi I2C bus 6 registers base address.
489: #define RPI_I2C6_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205C00)
490: #endif
491:
492: /// @brief Raspberry Pi I2C control register (R/W) offset relative to RPI_I2Cx_BASE
493: #define RPI_I2C_C_OFFSET              0x00000000
494: /// @brief Disable BSC (I2C) controller
495: #define RPI_I2C_C_DISABLE             BIT0(15)
496: /// @brief Enable BSC (I2C) controller
497: #define RPI_I2C_C_ENABLE              BIT1(15)
498: /// @brief Disable interrupt on receive 3/4 full
499: #define RPI_I2C_C_INTR_DISABLE        BIT0(10)
500: /// @brief Enable interrupt on receive 3/4 full
501: #define RPI_I2C_C_INTR_ENABLE         BIT1(10)
502: /// @brief Disable interrupt on transmit 3/4 empty
503: #define RPI_I2C_C_INTT_DISABLE        BIT0(9)
504: /// @brief Enable interrupt on receive 3/4 empty
505: #define RPI_I2C_C_INTT_ENABLE         BIT1(9)
506: /// @brief Disable interrupt on transfer done
507: #define RPI_I2C_C_INTD_DISABLE        BIT0(8)
508: /// @brief Enable interrupt on transfer done
509: #define RPI_I2C_C_INTD_ENABLE         BIT1(8)
510: /// @brief Transfer start (start condition)
511: #define RPI_I2C_C_ST                  BIT1(7)
512: /// @brief Clear FIFO
513: #define RPI_I2C_C_CLEAR               BITS(4, 5)
514: /// @brief Write transfer
515: #define RPI_I2C_C_WRITE               BIT0(0)
516: /// @brief Read transfer
517: #define RPI_I2C_C_READ                BIT1(0)
518:
519: /// @brief Raspberry Pi I2C status register (R/W) offset relative to RPI_I2Cx_BASE
520: #define RPI_I2C_S_OFFSET              0x00000004
521: /// @brief Clock stretch timeout
522: #define RPI_I2C_S_CLKT                BIT1(9)
523: /// @brief ACK error
524: #define RPI_I2C_S_ERR                 BIT1(8)
525: /// @brief Receive FIFO full
526: #define RPI_I2C_S_RXF                 BIT1(7)
527: /// @brief Transmit FIFO empty
528: #define RPI_I2C_S_TXE                 BIT1(6)
529: /// @brief Receive FIFO has data
530: #define RPI_I2C_S_RXD                 BIT1(5)
531: /// @brief Transmit FIFO has space
532: #define RPI_I2C_S_TXD                 BIT1(4)
533: /// @brief Receive FIFO is 3/4 full
534: #define RPI_I2C_S_RXR                 BIT1(3)
535: /// @brief Transmit FIFO is 1/4 full
536: #define RPI_I2C_S_TXW                 BIT1(2)
537: /// @brief Transfer is done
538: #define RPI_I2C_S_DONE                BIT1(1)
539: /// @brief Transfer is active
540: #define RPI_I2C_S_TA                  BIT1(0)
541:
542: /// /// @brief Raspberry Pi I2C data length register (R/W) offset relative to RPI_I2Cx_BASE
543: #define RPI_I2C_DLEN_OFFSET           0x00000008
544: /// @brief Raspberry Pi I2C slave address register (R/W) offset relative to RPI_I2Cx_BASE
545: #define RPI_I2C_A_OFFSET              0x0000000C
546: /// @brief Raspberry Pi I2C data FIFO register (R/W) offset relative to RPI_I2Cx_BASE
547: #define RPI_I2C_FIFO_OFFSET           0x00000010
548: /// @brief Raspberry Pi I2C clock divider register (R/W) offset relative to RPI_I2Cx_BASE
549: #define RPI_I2C_DIV_OFFSET            0x00000014
550: /// @brief Raspberry Pi I2C data delay register (R/W) offset relative to RPI_I2Cx_BASE
551: #define RPI_I2C_DEL_OFFSET            0x00000018
552: /// @brief Raspberry Pi I2C clock stretch timeout register (R/W) offset relative to RPI_I2Cx_BASE
553: #define RPI_I2C_CLKT_OFFSET           0x0000001C
554: /// @brief Raspberry Pi I2C register address from base address and offset
555: #define RPI_I2C_REG_ADDRESS(base, offset)   reinterpret_cast<regaddr>((base) + (offset))
556:
```

- Line 473-490: We define the base address for each I2C bus, depending on the model.
Raspberry Pi 3 has buses 0, 1 and 2, Raspberry Pi 4 has bus 0, 1, 3, 4, 5, 6.
As the registers used for Raspberry Pi 5 are different, we'll skip these for now
- Line 492-493: We define the offset relative to the base address for the Control Register.
The actual address is calculated using the `RPI_I2C_REG_ADDRESS` macro
- Line 494-517: We define the bits for the Control Register.
Notice that some bits are defined as BIT0, basically meaning the bit has value 0, defined for clarity
- Line 519-520: We define the offset relative to the base address for the Status Register.
The actual address is calculated using the `RPI_I2C_REG_ADDRESS` macro
- Line 521-540: We define the bits for the Status Register
- Line 542-543: We define the offset relative to the base address for the Data Length Register
- Line 544-545: We define the offset relative to the base address for the Address Register
- Line 546-547: We define the offset relative to the base address for the FIFO Register
- Line 548-549: We define the offset relative to the base address for the Clock Divider Register
- Line 550-551: We define the offset relative to the base address for the Data Delay Register
- Line 552-553: We define the offset relative to the base address for the Clock Stretch Register
- Line 554-555: We define the macro `RPI_I2C_REG_ADDRESS` to calculate the register address from the I2C bus register base address and the relative register offset.
Each block of bus registers has the same shape for Raspberry Pi 3 and 4.

### I2CMaster.h {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_I2CMASTERH}

We'll create a class `I2CMaster` which functions as a master on a I2C bus.

Create the file `code/libraries/baremetal/include/baremetal/I2CMaster.h`

```cpp
File: code/libraries/baremetal/include/baremetal/I2CMaster.h
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : I2CMaster.h
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : I2CMaster
9: //
10: // Description : I2C Master functionality
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39:
40: #pragma once
41:
42: #include <baremetal/BCMRegisters.h>
43: #include <baremetal/IMemoryAccess.h>
44: #include <baremetal/PhysicalGPIOPin.h>
45:
46: /// @file
47: /// I2C Master
48:
49: namespace baremetal
50: {
51:
52: #if BAREMETAL_RPI_TARGET <= 4
53:
54: // Return codes returned by Read/Write as negative value
55: /// @brief Invalid parameter
56: #define I2C_MASTER_INVALID_PARM  1
57: /// @brief Received a NACK
58: #define I2C_MASTER_ERROR_NACK   2
59: /// @brief Received clock stretch timeout
60: #define I2C_MASTER_ERROR_CLKT   3
61: /// @brief Not all data has been sent/received
62: #define I2C_MASTER_DATA_LEFT    4
63: /// @brief Transfer timed out
64: #define I2C_MASTER_TIMEOUT      5
65: /// @brief Bus did not become ready
66: #define I2C_MASTER_BUS_NOT_BUSY 6
67:
68: /// <summary>
69: /// I2C speed selection
70: /// </summary>
71: enum class I2CClockMode
72: {
73:     /// @brief I2C @ 100 KHz
74:     Normal,
75:     /// @brief I2C @ 400 KHz
76:     Fast,
77:     /// @brief I2C @ 1 MHz
78:     FastPlus,
79: };
80:
81: /// <summary>
82: /// Driver for I2C master devices
83: ///
84: /// GPIO pin mapping (Raspberry Pi 3-4)
85: /// bus       | config 0      | config 1      | config 2      | Boards
86: /// :-------: | :-----------: | :-----------: | :-----------: | :-----
87: /// ^         | SDA    SCL    | SDA    SCL    | SDA    SCL    | ^
88: /// 0         | GPIO0  GPIO1  | GPIO28 GPIO29 | GPIO44 GPIO45 | Raspberry Pi 3 / 4
89: /// 1         | GPIO2  GPIO3  |               |               | Raspberry Pi 3 only
90: /// 2         |               |               |               | None
91: /// 3         | GPIO2  GPIO3  | GPIO4  GPIO5  |               | Raspberry Pi 4 only
92: /// 4         | GPIO6  GPIO7  | GPIO8  GPIO9  |               | Raspberry Pi 4 only
93: /// 5         | GPIO10 GPIO11 | GPIO12 GPIO13 |               | Raspberry Pi 4 only
94: /// 6         | GPIO22 GPIO23 |               |               | Raspberry Pi 4 only
95: ///
96: /// GPIO pin mapping (Raspberry Pi 5)
97: /// bus       | config 0      | config 1      | config 2      | Boards
98: /// :-------: | :-----------: | :-----------: | :-----------: | :-----
99: /// ^         | SDA    SCL    | SDA    SCL    | SDA    SCL    | ^
100: /// 0         | GPIO0  GPIO1  | GPIO8  GPIO9  |               | Raspberry Pi 5 only
101: /// 1         | GPIO2  GPIO3  | GPIO10 GPIO11 |               | Raspberry Pi 5 only
102: /// 2         | GPIO4  GPIO5  | GPIO12 GPIO13 |               | Raspberry Pi 5 only
103: /// 3         | GPIO6  GPIO7  | GPIO14 GPIO15 | GPIO22 GPIO23 | Raspberry Pi 5 only
104: /// </summary>
105: class I2CMaster
106: {
107: private:
108:     /// @brief Memory access interface reference for accessing registers.
109:     IMemoryAccess&  m_memoryAccess;
110:     /// @brief I2C bus index
111:     uint8           m_bus;
112:     /// @brief I2C bus base register address
113:     regaddr         m_baseAddress;
114:     /// @brief I2C bus clock rate
115:     I2CClockMode    m_modm_clockMode
116:     /// @brief I2C bus GPIO configuration index used
117:     uint32          m_config;
118:     /// @brief True if class is already initialized
119:     bool            m_isInitialized;
120:
121:     /// @brief GPIO pin for SDA wire
122:     PhysicalGPIOPin m_sdaPin;
123:     /// @brief GPIO pin for SCL wire
124:     PhysicalGPIOPin m_sclPin;
125:
126:     /// @brief Core clock rate used to determine I2C clock rate in Hz
127:     unsigned        m_coreClockRate;
128:     /// @brief I2C clock rate in Hz
129:     unsigned        m_clockSpeed;
130:
131: public:
132:     I2CMaster(IMemoryAccess &memoryAccess = GetMemoryAccess());
133:
134:     virtual ~I2CMaster();
135:
136:     bool IInitialize(uint8 bus, I2CClockMode mode = I2CClockMode::Normal, uint32 config = 0);
137:
138:     void SetClock(unsigned clockRate);
139:     bool Scan(uint16 address);
140:     size_t Read(uint16 address, uint8 &data);
141:     size_t Read(uint16 address, void *buffer, size_t count);
142:     size_t Write(uint16 address, uint8 data);
143:     size_t Write(uint16 address, const void *buffer, size_t count);
144:     size_t WriteReadRepeatedStart(uint16 address, const void *writeBuffer, size_t writeCount, void *readBuffer, size_t readCount);
145:
146: private:
147:     uint32 ReadControlRegister();
148:     void WriteControlRegister(uint32 data);
149:     void StartReadTransfer();
150:     void StartWriteTransfer();
151:     void ClearFIFO();
152:     void WriteAddressRegister(uint8 data);
153:     void WriteDataLengthRegister(uint8 data);
154:     uint32 ReadStatusRegister();
155:     void WriteStatusRegister(uint32 data);
156:     bool HasClockStretchTimeout();
157:     bool HasAck();
158:     bool HasNAck();
159:     bool ReceiveFIFOFull();
160:     bool ReceiveFIFOHasData();
161:     bool ReceiveFIFONeedsReading();
162:     bool TransmitFIFOEmpty();
163:     bool TransmitFIFOHasSpace();
164:     bool TransmitFIFONeedsWriting();
165:     bool TransferDone();
166:     bool TransferActive();
167:     void ClearClockStretchTimeout();
168:     void ClearNAck();
169:     void ClearDone();
170:     void ClearAllStatus();
171:     uint8 ReadFIFORegister();
172:     void WriteFIFORegister(uint8 data);
173: };
174:
175: #else
176:
177: #error RPI 5 not supported yet
178:
179: #endif
180:
181: } // namespace baremetal
```

Notice that the I2C addresses all have type uint16, meaning we are supporting both 7 bit and 10 bit addresses.

- Line 52: We only support Raspberry Pi model 3 and 4 for now, as Raspberry Pi 5 behaves differently
- Line 55-66: We define some error return codes
- Line 68-79: We define the enum `I2CClockMode` to denote the I2C bus clock rates
- Line 81-173: We declare the class `I2CMaster`
  - Line 108-109: We declare a member variable `m_memoryAccess` to access registers
  - Line 110-111: We declare a member variable `m_bus` to hold the I2C bus index
  - Line 112-113: We declare a member variable `m_baseAddress` to hold the I2C bus register base address
  - Line 114-115: We declare a member variable `m_clockMode` to hold the I2C clock rate setting
  - Line 116-117: We declare a member variable `m_config` to hold the configuration used to set GPIO pins for the I2C bus.
This has a direct relationship to the GPIO number used for the two I2C wires
  - Line 118-119: We declare a member variable `m_isInitialized` to guard aginst multiple initialization
  - Line 121-122: We declare a member variable `m_sdaPin` to hold the physical GPIO used for the SDA wire
  - Line 123-124: We declare a member variable `m_sclPin` to hold the physical GPIO used for the SCL wire
  - Line 126-127: We declare a member variable `m_coreClockRate` to hold the SoC core clock rate (in Hz), which is used to derive the I2C clock rate
  - Line 128-129: We declare a member variable `m_clockSpeed` to hold the I2C clock rate (in Hz) set for the specified clock mode
  - Line 132: We declare the constructor, which either takes the singleton `MemoryAccess` instance, or any other passed `IMemoryAccess` instance (for testing)
  - Line 134: We declare the destructor
  - Line 136: We declare the method `Initialize()` to initialize the master for the specified bus, using the specified clock mode and configuration
  - Line 138: We declare the method `SetClock()` to set the I2C clock rate in Hz
  - Line 139: We declate the method `Scan()` to scan a specific address for existence of a I2C device
  - Line 140: We declare a method `Read()` to read a single byte from an I2C device
  - Line 141: We declare a method `Read()` to read one or more bytes from an I2C device
  - Line 142: We declare a method `Write()` to write a single byte to an I2C device
  - Line 143: We declare a method `Write()` to write one of more bytes to an I2C device
  - Line 144: We declare a method `WriteReadRepeatedStart()` which send and receives data until the specific number of bytes is read
  - Line 147: We declare a method `ReadControlRegister()` to read from the I2C Control Register
  - Line 148: We declare a method `WriteControlRegister()` to write to the I2C Control Register
  - Line 149: We declare a method `StartReadTransfer()` to start a data read transfer
  - Line 150: We declare a method `StartWriteTransfer()` to start a data write transfer
  - Line 151: We declare a method `ClearFIFO()` to clear both read and write FIFO
  - Line 152: We declare a method `WriteAddressRegister()` to write to the I2C Address Register
  - Line 153: We declare a method `WriteDataLengthRegister()` to write to the I2C DataLength Register
  - Line 154: We declare a method `ReadStatusRegister()` to read from the I2C Status Register
  - Line 155: We declare a method `WriteStatusRegister()` to write to the I2C Status Register
  - Line 156: We declare a method `HasClockStretchTimeout()` to check whether a Clock Stretch Timeout has occurred
  - Line 157: We declare a method `HasAck()` to check whether an Ack was received
  - Line 158: We declare a method `HasNAck()` to check whether no Ack was received
  - Line 159: We declare a method `ReceiveFIFOFull()` to check whether the receive FIFO is full
  - Line 160: We declare a method `ReceiveFIFOHasData()` to check whether the receive FIFO contains data
  - Line 161: We declare a method `ReceiveFIFONeedsReading()` to check whether the receive FIFO needs reading, i.e. when the receive FIFO is at least 3/4 full
  - Line 162: We declare a method `TransmitFIFOEmpty()` to check whether the transmit FIFO is empty
  - Line 163: We declare a method `TransmitFIFOHasSpace()` to check whether the transmit FIFO has space to write
  - Line 164: We declare a method `TransmitFIFONeedsWriting()` to check whether the transmit FIFO needs writing, i.e. when the transmit FIFO is 1/4 full or less
  - Line 165: We declare a method `TransferDone()` to check whether the transfer is done
  - Line 166: We declare a method `TransferActive()` to check whether there is an active transfer
  - Line 167: We declare a method `ClearClockStretchTimeout()` to clear the Clock Stretch Timeout condition
  - Line 168: We declare a method `ClearNAck()` to clear the NAck condition
  - Line 169: We declare a method `ClearDone()` to clear the done status
  - Line 170: We declare a method `ClearAllStatus()` to clear the clock stretch timeout, NAck condition and done status
  - Line 171: We declare a method `ReadFIFORegister()` to read from the I2C FIFO
  - Line 172: We declare a method `WriteFIFORegister()` to write to the I2C FIFO

### I2CMaster.cpp {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_I2CMASTERCPP}

Let's implement the `I2CMaster` class.

Create the file `code/libraries/baremetal/src/I2CMaster.cpp`

```cpp
File: code/libraries/baremetal/src/I2CMaster.cpp
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : I2CMaster.cpp
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : I2CMaster
9: //
10: // Description : I2C Master functionality
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39: 
40: #include <baremetal/I2CMaster.h>
41: 
42: #include <baremetal/Assert.h>
43: #include <baremetal/Logger.h>
44: #include <baremetal/MachineInfo.h>
45: #include <baremetal/String.h>
46: #include <baremetal/Timer.h>
47: 
48: /// @file
49: /// I2CMaster
50: 
51: using namespace baremetal;
52: 
53: /// @brief Define log name
54: LOG_MODULE("I2CMaster");
55: 
56: /// @brief If defined will trace detailed information on messages send and rece
57: #define TRACE 1
58: 
59: #if BAREMETAL_RPI_TARGET == 3
60: /// @brief Number of I2C buses for RPI 3
61: #define I2C_BUSES           2
62: #else
63: /// @brief Number of I2C buses for RPI 4
64: #define I2C_BUSES           7
65: #endif
66: 
67: /// @brief Total number of different GPIO pin configurations for I2C pins
68: #define I2C_CONFIGURATIONS  3
69: 
70: /// @brief Total number of GPIO pins used for I2C (SCL / SDA)
71: #define I2C_GPIOS           2
72: /// @brief Index of I2C SDA pin
73: #define I2C_GPIO_SDA        0
74: /// @brief Index of I2C SCL pin
75: #define I2C_GPIO_SCL        1
76: 
77: /// @brief Value in configuration table to flag invalid combination
78: #define NONE	{10000, 10000}
79: 
80: /// @brief I2C addresses below RESERVED_ADDRESS_LOW are reserved
81: #define RESERVED_ADDRESS_LOW 0x07
82: /// @brief I2C addresses staring from RESERVED_ADDRESS_HIGH are reserved
83: #define RESERVED_ADDRESS_HIGH 0x78
84: /// @brief Highest 10 bit address
85: #define ADDRESS_10BIT_HIGH 0x3FF
86: 
87: /// @brief GPIO pin configurations for I2C pins. For every bus there are multiple configurations for the two I2C pins
88: static unsigned s_gpioConfig[I2C_BUSES][I2C_CONFIGURATIONS][I2C_GPIOS] =
89: {
90:     // SDA, SCL
91:     {{ 0,  1}, {28, 29}, {44, 45}}, // Alt0, Alt0, Alt1
92:     {{ 2,  3},   NONE,     NONE  }, // Alt0
93: #if BAREMETAL_RPI_TARGET == 4
94:     {  NONE,     NONE,     NONE  }, // unused
95:     {{ 2,  3}, { 4,  5},   NONE  }, // Alt5, Alt5
96:     {{ 6,  7}, { 8,  9},   NONE  }, // Alt5, Alt5
97:     {{10, 11}, {12, 13},   NONE  }, // Alt5, Alt5
98:     {{22, 23},   NONE  ,   NONE  }  // Alt5
99: #endif
100: };
101: 
102: /// @brief I2C register bases addresses for each bus, depening on the RPI model
103: static regaddr s_baseAddress[I2C_BUSES] =
104: {
105:     RPI_I2C0_BASE,
106:     RPI_I2C1_BASE,
107: #if BAREMETAL_RPI_TARGET == 4
108:     0,
109:     RPI_I2C3_BASE,
110:     RPI_I2C4_BASE,
111:     RPI_I2C5_BASE,
112:     RPI_I2C6_BASE,
113: #endif
114: };
115: 
116: /// @brief FIFO register mask. Only one byte can be written at once
117: #define RPI_I2C_FIFO_MASK   0xFF
118: 
119: /// @brief Size of FIFO for both read and write operations
120: #define RPI_I2C_FIFO_SIZE   16
121: 
122: /// @brief Macro to determine GPIO function to be selected for a specific bus and configuration
123: #define ALT_FUNC(bus, config) ((bus) == 0 && (config) == 2          \
124:                                 ? GPIOMode::AlternateFunction1        \
125:                                 : ((bus) < 2                     \
126:                                     ? GPIOMode::AlternateFunction0    \
127:                                     : GPIOMode::AlternateFunction5))
128: 
129: /// <summary>
130: /// Constructor for I2CMaster
131: ///
132: /// The default value for memoryAccess will use the singleton MemoryAccess instance. A different reference to a IMemoryAccess instance can be passed for testing
133: /// </summary>
134: /// <param name="memoryAccess">MemoryAccess instance to be used for register access</param>
135: I2CMaster::I2CMaster(IMemoryAccess &memoryAccess/* = GetMemoryAccess()*/)
136:     : m_memoryAccess{ memoryAccess }
137:     , m_bus{}
138:     , m_baseAddress{}
139:     , m_clockMode{}
140:     , m_config{}
141:     , m_isInitialized{}
142:     , m_sdaPin{memoryAccess}
143:     , m_sclPin{memoryAccess}
144:     , m_coreClockRate{}
145:     , m_clockSpeed{}
146: {
147: }
148: 
149: /// <summary>
150: /// Destructor for I2CMaster
151: /// </summary>
152: I2CMaster::~I2CMaster()
153: {
154:     if (m_isInitialized)
155:     {
156:         m_sdaPin.SetMode(GPIOMode::InputPullUp);
157:         m_sclPin.SetMode(GPIOMode::InputPullUp);
158:     }
159:     m_isInitialized = false;
160:     m_baseAddress = 0;
161: }
162: 
163: /// <summary>
164: /// Initialize the I2CMaster for a specific bus, using the specified configuration index, and setting the clock as specified.
165: /// </summary>
166: /// <param name="bus">Device number (see: comment for I2CMaster class</param>
167: /// <param name="mode">I2C clock rate to be used</param>
168: /// <param name="config">Configuration index to be used. Determines which GPIO pins are to be used for the I2C bus</param>
169: /// <returns></returns>
170: bool I2CMaster::Initialize(uint8 bus, I2CClockMode mode, uint32 config)
171: {
172:     if (m_isInitialized)
173:         return true;
174: 
175:     LOG_INFO("Initialize bus %d, mode %d, config %d", bus, static_cast<int>(mode), config);
176:     if ((bus >= I2C_BUSES) ||
177:         (config >= I2C_CONFIGURATIONS) ||
178:         (s_gpioConfig[bus][config][I2C_GPIO_SDA] >= NUM_GPIO))
179:         return false;
180: 
181:     m_bus = bus;
182:     m_clockMode = mode;
183:     m_config = config;
184:     m_baseAddress = s_baseAddress[m_bus];
185:     m_coreClockRate = GetMachineInfo().GetClockRate(ClockID::CORE);
186: 
187:     assert(m_baseAddress != 0);
188: 
189:     m_sdaPin.AssignPin(s_gpioConfig[m_bus][m_config][I2C_GPIO_SDA]);
190:     m_sdaPin.SetMode(ALT_FUNC(m_bus, m_config));
191: 
192:     m_sclPin.AssignPin(s_gpioConfig[m_bus][m_config][I2C_GPIO_SCL]);
193:     m_sclPin.SetMode(ALT_FUNC(m_bus, m_config));
194: 
195:     assert(m_coreClockRate > 0);
196: 
197:     m_isInitialized = true;
198: 
199:     SetClock(m_clockMode == I2CClockMode::FastPlus ? 1000000 : (m_clockMode == I2CClockMode::Fast ? 400000 : 100000));
200: 
201:     LOG_INFO("Set up bus %d, config %d, base address %08X", bus, config, m_baseAddress);
202:     return true;
203: }
204: 
205: /// <summary>
206: /// Set I2C clock rate
207: /// </summary>
208: /// <param name="clockRate">Clock rate in Hz</param>
209: void I2CMaster::SetClock(unsigned clockRate)
210: {
211:     assert(m_isInitialized);
212: 
213:     assert(clockRate > 0);
214:     m_clockSpeed = clockRate;
215: 
216:     uint16 divider = static_cast<uint16>(m_coreClockRate / clockRate);
217:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_DIV_OFFSET), divider);
218:     LOG_INFO("Set clock %d", clockRate);
219: }
220: 
221: /// <summary>
222: /// Scan I2C bus for existing of a device at the specified address
223: /// </summary>
224: /// <param name="address">I2C address to be scanned</param>
225: /// <returns>Returns true if a device was found, false otherwise</returns>
226: bool I2CMaster::Scan(uint16 address)
227: {
228:     uint8 data{};
229:     return Read(address, data) == 1;
230: }
231: 
232: /// <summary>
233: /// Read a single byte from the I2C device with specified address
234: /// </summary>
235: /// <param name="address">Device address</param>
236: /// <param name="data">Data to be received</param>
237: /// <returns>Returns number of bytes read, or errorcode < 0 on failure</returns>
238: size_t I2CMaster::Read(uint16 address, uint8 &data)
239: {
240:     return Read(address, &data, 1);
241: }
242: 
243: /// <summary>
244: /// Read a requested number of bytes from the I2C device with specified address
245: /// </summary>
246: /// <param name="address">Device address</param>
247: /// <param name="buffer">Pointer to buffer to store data read</param>
248: /// <param name="count">Requested number of bytes to read</param>
249: /// <returns>Returns number of bytes read, or errorcode < 0 on failure</returns>
250: size_t I2CMaster::Read(uint16 address, void *buffer, size_t count)
251: {
252:     assert(m_isInitialized);
253: 
254:     if ((address >= ADDRESS_10BIT_HIGH) || (count == 0))
255:     {
256:         return -I2C_MASTER_INVALID_PARM;
257:     }
258:     if (address >= RESERVED_ADDRESS_HIGH)
259:     {
260:         // We need to start a write / read cycle
261:         // The address part contains bits 8 and 9 of the address, the first write data byte the bits 0 through 7 of the address.
262:         // After this we read the device
263:         uint8 secondAddressByte = address & 0xFF;
264:         uint8 firstAddressByte = static_cast<uint8>(0x78 | ((address >> 8) & 0x03));
265:         return WriteReadRepeatedStart(firstAddressByte, &secondAddressByte, 1, buffer, count);
266:     }
267:     uint8 addressByte{ static_cast<uint8>(address & 0x7F) };
268: 
269:     uint8 *data = reinterpret_cast<uint8 *>(buffer);
270:     assert(data != 0);
271: 
272:     size_t result = 0;
273: 
274:     WriteAddressRegister(addressByte);
275: 
276:     ClearFIFO();
277:     ClearAllStatus();
278:     WriteDataLengthRegister(count);
279:     StartReadTransfer();
280: 
281:     // Transfer active
282:     while (!TransferDone())
283:     {
284:         while (ReceiveFIFOHasData())
285:         {
286:             *data++ = ReadFIFORegister();
287:             //LOG_INFO("Read byte from %02x, data %02x", address, *(data - 1));
288: 
289:             count--;
290:             result++;
291:         }
292:     }
293: 
294:     // Transfer has finished, grab any remaining stuff from FIFO
295:     while ((count > 0) && ReceiveFIFOHasData())
296:     {
297:         *data++ = ReadFIFORegister();
298:         //LOG_INFO("Read extra byte from %02x, data %02x", address, *(data - 1));
299: 
300:         count--;
301:         result++;
302:     }
303: 
304: #if TRACE
305:     LOG_INFO("Read result = %d", result);
306: #endif
307: 
308:     uint32 status = ReadStatusRegister();
309:     if (status & RPI_I2C_S_ERR)
310:     {
311:         // Clear error bit
312:         ClearNAck();
313: 
314:         result = -I2C_MASTER_ERROR_NACK;
315:     }
316:     else if (status & RPI_I2C_S_CLKT)
317:     {
318:         ClearClockStretchTimeout();
319:         result = -I2C_MASTER_ERROR_CLKT;
320:     }
321:     else if (count > 0)
322:     {
323:         result = -I2C_MASTER_DATA_LEFT;
324:     }
325: 
326:     // Clear done bit
327:     ClearDone();
328: 
329:     return result;
330: }
331: 
332: /// <summary>
333: /// Write a single byte to the I2C device with specified address
334: /// </summary>
335: /// <param name="address">Device address</param>
336: /// <param name="data">Data to write</param>
337: /// <returns>Returns number of bytes written, or errorcode < 0 on failure</returns>
338: size_t I2CMaster::Write(uint16 address, uint8 data)
339: {
340:     return Write(address, &data, 1);
341: }
342: 
343: /// <summary>
344: /// Write a requested number of bytes to the I2C device with specified address
345: /// </summary>
346: /// <param name="address">Device address</param>
347: /// <param name="buffer">Pointer to buffer containing data to sebd</param>
348: /// <param name="count">Requested number of bytes to write</param>
349: /// <returns>Returns number of bytes written, or errorcode < 0 on failure</returns>
350: size_t I2CMaster::Write(uint16 address, const void *buffer, size_t count)
351: {
352:     assert(m_isInitialized);
353: 
354:     if (address >= ADDRESS_10BIT_HIGH)
355:     {
356:         return -I2C_MASTER_INVALID_PARM;
357:     }
358: 
359:     if ((count != 0) && (buffer == nullptr))
360:     {
361:         return -I2C_MASTER_INVALID_PARM;
362:     }
363: 
364:     const uint8 *data = reinterpret_cast<const uint8 *>(buffer);
365:     assert(data != 0);
366: 
367:     int result = 0;
368: 
369:     ClearFIFO();
370: 
371:     unsigned bytesWritten{};
372:     uint8 addressByte{ static_cast<uint8>(address & 0x7F) };
373:     if (address >= RESERVED_ADDRESS_HIGH)
374:     {
375:         // We need to write the low 8 bits of the address first
376:         // The address part contains bits 8 and 9 of the address, the first write data byte the bits 0 through 7 of the address.
377:         uint8 secondAddressByte = address & 0xFF;
378:         addressByte = static_cast<uint8>(0x78 | ((address >> 8) & 0x03));
379:         WriteFIFORegister(secondAddressByte);
380:         bytesWritten++;
381:     }
382: 
383:     WriteAddressRegister(addressByte);
384:     ClearAllStatus();
385:     WriteDataLengthRegister(static_cast<uint8>(bytesWritten + count));
386: 
387:     // Fill FIFO
388:     for (; count > 0 && bytesWritten < RPI_I2C_FIFO_SIZE; bytesWritten++)
389:     {
390:         WriteFIFORegister(*data++);
391:         count--;
392:         result++;
393:     }
394: 
395:     StartWriteTransfer();
396: 
397:     // Transfer active
398:     while (!TransferDone())
399:     {
400:         while ((count > 0) && TransmitFIFOHasSpace())
401:         {
402:             //LOG_INFO("Write extra byte to %02x, data %02x", address, *data);
403:             WriteFIFORegister(*data++);
404:             count--;
405:             result++;
406:         }
407:         Timer::WaitMilliSeconds(1);
408:     }
409: 
410: #if TRACE
411:     LOG_INFO("Write result = %d", result);
412: #endif
413: 
414:     // Check status
415:     uint32 status = ReadStatusRegister();
416:     if (status & RPI_I2C_S_ERR)
417:     {
418:         // Clear error bit
419:         ClearNAck();
420: 
421:         result = -I2C_MASTER_ERROR_NACK;
422:     }
423:     else if (status & RPI_I2C_S_CLKT)
424:     {
425:         ClearClockStretchTimeout();
426:         result = -I2C_MASTER_ERROR_CLKT;
427:     }
428:     else if (count > 0)
429:     {
430:         result = -I2C_MASTER_DATA_LEFT;
431:     }
432: 
433:     // Clear done bit
434:     ClearDone();
435: 
436:     while (ReceiveFIFOHasData())
437:     {
438:         uint8 data = ReadFIFORegister();
439: #if TRACE
440:         LOG_INFO("Read byte = %02x", data);
441: #endif
442:     }
443: 
444:     return result;
445: }
446: 
447: /// <summary>
448: /// Consecutive write and read operation with repeated start
449: /// </summary>
450: /// <param name="address">I2C address of target device</param>
451: /// <param name="writeBuffer">Write data for will be taken from here</param>
452: /// <param name="writeCount">Number of bytes to be written (max. 16)</param>
453: /// <param name="readBuffer">Read data will be stored here</param>
454: /// <param name="readCount">Number of bytes to be read</param>
455: /// <returns>Returns number of bytes read, or errorcode < 0 on failure</returns>
456: size_t I2CMaster::WriteReadRepeatedStart(uint16 address, const void *writeBuffer, size_t writeCount, void *readBuffer, size_t readCount)
457: {
458:     assert(m_isInitialized);
459: 
460:     if (address >= ADDRESS_10BIT_HIGH)
461:     {
462:         return -I2C_MASTER_INVALID_PARM;
463:     }
464: 
465:     if ((writeCount == 0) || (writeCount > ((address >= 0x78) ? RPI_I2C_FIFO_SIZE - 1 : RPI_I2C_FIFO_SIZE)) ||
466:         (writeBuffer == nullptr) ||
467:         (readCount == 0) || (readBuffer == nullptr))
468:     {
469:         return -I2C_MASTER_INVALID_PARM;
470:     }
471: 
472:     const uint8 *writeData = reinterpret_cast<const uint8 *>(writeBuffer);
473: 
474:     int result = 0;
475: 
476:     ClearFIFO();
477: 
478:     unsigned bytesWritten{};
479:     uint8 addressByte{ static_cast<uint8>(address & 0x7F) };
480:     if (address >= RESERVED_ADDRESS_HIGH)
481:     {
482:         // We need to write the low 8 bits of the address first
483:         // The address part contains bits 8 and 9 of the address, the first write data byte the bits 0 through 7 of the address.
484:         uint8 secondAddressByte = address & 0xFF;
485:         uint8 addressByte = static_cast<uint8>(0x78 | ((address >> 8) & 0x03));
486:         WriteFIFORegister(secondAddressByte);
487:         bytesWritten++;
488:     }
489: 
490:     WriteAddressRegister(addressByte);
491:     ClearAllStatus();
492:     WriteDataLengthRegister(static_cast<uint8>(bytesWritten + writeCount));
493: 
494:     // Fill FIFO
495:     for (; writeCount > 0 && bytesWritten < RPI_I2C_FIFO_SIZE; bytesWritten++)
496:     {
497:         WriteFIFORegister(*writeData++);
498: 
499:         writeCount--;
500:         result++;
501:     }
502: 
503:     StartWriteTransfer();
504: 
505:     // Poll to check transfer has started
506:     while (!TransferActive())
507:     {
508:         if (TransferDone())
509:         {
510:             break;
511:         }
512:     }
513: 
514:     uint8 *readData = reinterpret_cast<uint8 *>(readBuffer);
515: 
516:     WriteDataLengthRegister(readCount);
517:     StartReadTransfer();
518: 
519:     assert(m_clockSpeed > 0);
520:     Timer::WaitMicroSeconds((writeCount + 1) * 9 * 1000000 / m_clockSpeed);
521: 
522:     // Transfer active
523:     while (!TransferDone())
524:     {
525:         while ((readCount > 0) && ReceiveFIFOHasData())
526:         {
527:             *readData++ = ReadFIFORegister();
528: 
529:             readCount--;
530:             result++;
531:         }
532:     }
533: 
534:     // Transfer has finished, grab any remaining stuff from FIFO
535:     while ((readCount > 0) && ReceiveFIFOHasData())
536:     {
537:         *readData++ = ReadFIFORegister();
538: 
539:         readCount--;
540:         result++;
541:     }
542: 
543:     // Check status
544:     uint32 status = ReadStatusRegister();
545:     if (status & RPI_I2C_S_ERR)
546:     {
547:         // Clear error bit
548:         ClearNAck();
549: 
550:         result = -I2C_MASTER_ERROR_NACK;
551:     }
552:     else if (status & RPI_I2C_S_CLKT)
553:     {
554:         ClearClockStretchTimeout();
555:         result = -I2C_MASTER_ERROR_CLKT;
556:     }
557:     else if (readCount > 0)
558:     {
559:         result = -I2C_MASTER_DATA_LEFT;
560:     }
561: 
562:     // Clear done bit
563:     ClearDone();
564: 
565:     return result;
566: }
567: 
568: /// <summary>
569: /// Read the I2C Control Register
570: /// </summary>
571: /// <returns>Value read from I2C Control Register</returns>
572: uint32 I2CMaster::ReadControlRegister()
573: {
574:     auto result = m_memoryAccess.Read32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_C_OFFSET));
575: #if TRACE
576:     string text;
577:     text += (result & RPI_I2C_C_ENABLE) ? "EN " : "   ";
578:     text += (result & RPI_I2C_C_INTR_ENABLE) ? "IR " : "  ";
579:     text += (result & RPI_I2C_C_INTT_ENABLE) ? "IT " : "  ";
580:     text += (result & RPI_I2C_C_INTD_ENABLE) ? "ID " : "  ";
581:     text += (result & RPI_I2C_C_ST) ? "ST " : "  ";
582:     text += (result & RPI_I2C_C_CLEAR) ? "CL " : "  ";
583:     text += (result & RPI_I2C_C_READ) ? "RD " : "WR ";
584:     LOG_INFO("Read I2C Control, %s", text.c_str());
585: #endif
586:     return result;
587: }
588: 
589: /// <summary>
590: /// Write to the I2C Control Register
591: /// </summary>
592: /// <param name="data">Value to write</param>
593: void I2CMaster::WriteControlRegister(uint32 data)
594: {
595:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_C_OFFSET), data);
596: #if TRACE
597:     string text;
598:     text += (data & RPI_I2C_C_ENABLE) ? "EN " : "   ";
599:     text += (data & RPI_I2C_C_INTR_ENABLE) ? "IR " : "  ";
600:     text += (data & RPI_I2C_C_INTT_ENABLE) ? "IT " : "  ";
601:     text += (data & RPI_I2C_C_INTD_ENABLE) ? "ID " : "  ";
602:     text += (data & RPI_I2C_C_ST) ? "ST " : "  ";
603:     text += (data & RPI_I2C_C_CLEAR) ? "CL " : "  ";
604:     text += (data & RPI_I2C_C_READ) ? "RD " : "WR ";
605:     LOG_INFO("Write I2C Control, %s", text.c_str());
606: #endif
607: }
608: 
609: /// <summary>
610: /// Start a read transfer
611: /// </summary>
612: void I2CMaster::StartReadTransfer()
613: {
614:     WriteControlRegister(ReadControlRegister() | RPI_I2C_C_ENABLE | RPI_I2C_C_ST | RPI_I2C_C_READ);
615: }
616: 
617: /// <summary>
618: /// Start a write transfer
619: /// </summary>
620: void I2CMaster::StartWriteTransfer()
621: {
622:     WriteControlRegister((ReadControlRegister() & ~RPI_I2C_C_READ)| RPI_I2C_C_ENABLE | RPI_I2C_C_ST | RPI_I2C_C_WRITE);
623: }
624: 
625: /// <summary>
626: /// Clear the FIFO. This clears both read and write FIFO
627: /// </summary>
628: void I2CMaster::ClearFIFO()
629: {
630:     WriteControlRegister(ReadControlRegister() | RPI_I2C_C_CLEAR);
631: }
632: 
633: /// <summary>
634: /// Write to the I2C Address Register
635: /// </summary>
636: /// <param name="data">Value to write</param>
637: void I2CMaster::WriteAddressRegister(uint8 data)
638: {
639:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_A_OFFSET), data);
640: #if TRACE
641:     LOG_INFO("Write I2C Address, %02x", data);
642: #endif
643: }
644: 
645: /// <summary>
646: /// Write to the I2C Data Length Register
647: /// </summary>
648: /// <param name="data">Value to write</param>
649: void I2CMaster::WriteDataLengthRegister(uint8 data)
650: {
651:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_DLEN_OFFSET), data);
652: #if TRACE
653:     LOG_INFO("Write I2C Length, %08x", data);
654: #endif
655: }
656: 
657: /// <summary>
658: /// Read the I2C Status Register
659: /// </summary>
660: /// <returns>Value read from I2C Status Register</returns>
661: uint32 I2CMaster::ReadStatusRegister()
662: {
663:     auto data = m_memoryAccess.Read32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_S_OFFSET));
664:     #if TRACE
665:     string text;
666:     text += (data & RPI_I2C_S_CLKT) ? "CLKT " : "     ";
667:     text += (data & RPI_I2C_S_ERR) ? "ERR " : "    ";
668:     text += (data & RPI_I2C_S_RXF) ? "RXF " : "    ";
669:     text += (data & RPI_I2C_S_TXE) ? "TXE " : "    ";
670:     text += (data & RPI_I2C_S_RXD) ? "RXD " : "    ";
671:     text += (data & RPI_I2C_S_TXD) ? "TXD " : "    ";
672:     text += (data & RPI_I2C_S_RXR) ? "RXR " : "    ";
673:     text += (data & RPI_I2C_S_TXW) ? "TXW " : "    ";
674:     text += (data & RPI_I2C_S_DONE) ? "DONE " : "     ";
675:     text += (data & RPI_I2C_S_TA) ? "TA " : "     ";
676:     LOG_INFO("Read I2C Status, %s", text.c_str());
677:     #endif
678:     return data;
679: }
680: 
681: /// <summary>
682: /// Write to the I2C Status Register
683: /// </summary>
684: /// <param name="data">Value to write</param>
685: void I2CMaster::WriteStatusRegister(uint32 data)
686: {
687:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_S_OFFSET), data);
688: #if TRACE
689:     string text;
690:     text += (data & RPI_I2C_S_CLKT) ? "CLKT " : "     ";
691:     text += (data & RPI_I2C_S_ERR) ? "ERR " : "    ";
692:     text += (data & RPI_I2C_S_DONE) ? "DONE " : "     ";
693:     LOG_INFO("Write I2C Status, %s", text.c_str());
694: #endif
695: }
696: 
697: /// <summary>
698: /// Check whether a clock stretch timeout has occurred
699: /// </summary>
700: /// <returns>Returns true if a clock stretch timeout has occurred</returns>
701: bool I2CMaster::HasClockStretchTimeout()
702: {
703:     return (ReadStatusRegister() & RPI_I2C_S_CLKT) != 0;
704: }
705: 
706: /// <summary>
707: /// Check whether the latest byte has received an ACK
708: /// </summary>
709: /// <returns>Returns true if the latest byte has received an ACK</returns>
710: bool I2CMaster::HasAck()
711: {
712:     return (ReadStatusRegister() & RPI_I2C_S_ERR) == 0;
713: }
714: 
715: /// <summary>
716: /// Check whether the latest byte has not received an ACK
717: /// </summary>
718: /// <returns>Returns true if the latest byte has not received an ACK</returns>
719: bool I2CMaster::HasNAck()
720: {
721:     return (ReadStatusRegister() & RPI_I2C_S_ERR) != 0;
722: }
723: 
724: /// <summary>
725: /// Check whether the read FIFO is full
726: /// </summary>
727: /// <returns>Returns true if the read FIFO is full</returns>
728: bool I2CMaster::ReceiveFIFOFull()
729: {
730:     return (ReadStatusRegister() & RPI_I2C_S_RXF) != 0;
731: }
732: 
733: /// <summary>
734: /// Check whether the read FIFO contains data
735: /// </summary>
736: /// <returns>Returns true if the read FIFO contains data</returns>
737: bool I2CMaster::ReceiveFIFOHasData()
738: {
739:     return (ReadStatusRegister() & RPI_I2C_S_RXD) != 0;
740: }
741: 
742: /// <summary>
743: /// Check whether the read FIFO needs to be read. This means the FIFO is 3/4 full or more
744: /// </summary>
745: /// <returns>Returns true if the read FIFO needs to be read</returns>
746: bool I2CMaster::ReceiveFIFONeedsReading()
747: {
748:     return (ReadStatusRegister() & RPI_I2C_S_RXR) != 0;
749: }
750: 
751: /// <summary>
752: /// Check whether the write FIFO is empty
753: /// </summary>
754: /// <returns>Returns true if the write FIFO is empty</returns>
755: bool I2CMaster::TransmitFIFOEmpty()
756: {
757:     return (ReadStatusRegister() & RPI_I2C_S_TXE) != 0;
758: }
759: 
760: /// <summary>
761: /// Check whether the write FIFO has space to write
762: /// </summary>
763: /// <returns>Returns true if the write FIFO has space to write</returns>
764: bool I2CMaster::TransmitFIFOHasSpace()
765: {
766:     return (ReadStatusRegister() & RPI_I2C_S_TXD) != 0;
767: }
768: 
769: /// <summary>
770: /// Check whether the write FIFO needs to be written to. This means the FIFO is 1/4 full or less
771: /// </summary>
772: /// <returns>Returns true if the write FIFO needs to be written to</returns>
773: bool I2CMaster::TransmitFIFONeedsWriting()
774: {
775:     return (ReadStatusRegister() & RPI_I2C_S_TXW) != 0;
776: }
777: 
778: /// <summary>
779: /// Check whether the transfer is done
780: /// </summary>
781: /// <returns>Returns true if the transfer is done</returns>
782: bool I2CMaster::TransferDone()
783: {
784:     return (ReadStatusRegister() & RPI_I2C_S_DONE) != 0;
785: }
786: 
787: /// <summary>
788: /// Check whether a transfer is active
789: /// </summary>
790: /// <returns>Returns true if a transfer is active</returns>
791: bool I2CMaster::TransferActive()
792: {
793:     return (ReadStatusRegister() & RPI_I2C_S_TA) != 0;
794: }
795: 
796: /// <summary>
797: /// Clear the CLKT (Clock Stretch Timeout) bit in the I2C Status Register
798: /// </summary>
799: void I2CMaster::ClearClockStretchTimeout()
800: {
801:     WriteStatusRegister(RPI_I2C_S_CLKT);
802: }
803: 
804: /// <summary>
805: /// Clear the ERR bit in the I2C Status Register
806: /// </summary>
807: void I2CMaster::ClearNAck()
808: {
809:     WriteStatusRegister(RPI_I2C_S_ERR);
810: }
811: 
812: /// <summary>
813: /// Clear the DONE bit in the I2C Status Register
814: /// </summary>
815: void I2CMaster::ClearDone()
816: {
817:     WriteStatusRegister(RPI_I2C_S_DONE);
818: }
819: 
820: /// <summary>
821: /// Clear the CLKT, ERR and DONE bits in the I2C Status Register
822: /// </summary>
823: void I2CMaster::ClearAllStatus()
824: {
825:     WriteStatusRegister(RPI_I2C_S_CLKT | RPI_I2C_S_ERR | RPI_I2C_S_DONE);
826: }
827: 
828: /// <summary>
829: /// Read the I2C FIFO Register
830: /// </summary>
831: /// <returns>Value read from I2C FIFO Register</returns>
832: uint8 I2CMaster::ReadFIFORegister()
833: {
834:     uint8 data = m_memoryAccess.Read32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_FIFO_OFFSET)) & RPI_I2C_FIFO_MASK;
835:     #if TRACE
836:     LOG_INFO("Read FIFO, data %08x", data);
837:     #endif
838:     return data;
839: }
840: 
841: /// <summary>
842: /// Write to the I2C FIFO Register
843: /// </summary>
844: /// <param name="data">Value to write</param>
845: void I2CMaster::WriteFIFORegister(uint8 data)
846: {
847:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_FIFO_OFFSET), data);
848: #if TRACE
849:     LOG_INFO("Write FIFO, data %08x", data);
850: #endif
851: }
```

- Line 56-57: We add a definition `TRACE` to enforce tracing detailed debug information if the definition is not 0, and skip debug information if set to 0.
We could simply generate e.g. debug level information, but this will still take time from the processor to create and info string that may never be used.
- Line 59-65: We create a definition `I2C_BUSES` as the number of I2C buses available for the enable Raspberry Pi model
- Line 67-68: We create a definition `I2C_CONFIGURATIONS` as the maximum number of defined GPIO pin configurations for each bus
- Line 70-71: We create a definition `I2C_GPIOS` as the total number of pins defined for each bus, i.e. 2.
This is used for the configuration definition
- Line 72-73: We create a definition `I2C_GPIO_SDA` as the index of the SDA pin.
This is used for the configuration definition
- Line 74-75: We create a definition `I2C_GPIO_SCL` as the index of the SCL pin.
This is used for the configuration definition
- Line 77-78: We create a definition `NONE` as an unused or invalid pin configuration
- Line 80-81: We create a definition `RESERVED_ADDRESS_LOW` as the maximum I2C address which is reserved.
For I2C all addresses between 0 and 7 are reserved
- Line 82-83: We create a definition `RESERVED_ADDRESS_HIGH` as the first I2C address in the high range which is reserved.
For I2C all addresses between 120 (0x78) and 127 (0x7F) are reserved
- Line 84-85: We create a definition `ADDRESS_10BIT_HIGH` as the hightest value supported for 10 bit I2C addresses
- Line 87-100: We declare a variable `s_gpioConfig` which holds the different GPIO pin configurations for the I2C pins in each bus
As can be seen there is no valid configuration for bus 2, as it is not on the GPIO header
- Line 102-114: We declare a variable `s_baseAddress` which holds the register base address for each bus.
As can be seen there is no address specified for bus 2, as it is not on the GPIO header, so addressing it would be useless
- Line 116-117: We create a definition `RPI_I2C_FIFO_MASK` to denote the mask to be placed on the FIFO register when reading or writing.
The FIFO can only be read and written per single byte
- Line 119-120: We create a definition `RPI_I2C_FIFO_SIZE` to denote the size of the read and write FIFO
- Line 122-127: We create a macro `ALT_FUNC` to determine the GPIO pin function for a specific configuration on a specified bus index.
This relates to the pin numbers in `s_gpioConfig`.
Notice that the function is the same for SCL and SDA pins
- Line 129-147: We define the constructor
- Line 149-161: We define the destructor
If initialized, it will reset the GPIO pins used to input mode with pull up
- Line 163-203: We define the method `Initialize()`
  - Line 172-173: If already initialized we simply return true
  - Line 176-179: We check for the validity of the specified bus index and configuration number, and whether this specifies valid GPIO pins.
If not we return false
  - Line 181-184: We save the parameters passed, and determine the register base address for the bus
  - Line 185: We request and save the core clock rate
  - Line 187: We assert that we have a valid register base address
  - Line 189-193: We assign the GPIO pins for SDA and SCL, and set them to the correct function
  - Line 195: We assert that we have a valid core clock rate
  - Line 197: We set the initialized flag
  - Line 199: We set the I2C clock rate depending on the mode
- Line 205-219: We define the method `SetClock()` to set the I2C clock rate.
This calculates the divider to be used to get from the core clock rate to the desired clock rate, and writes this value to the I2C Clock Divider register
- Line 221-230: We define the method `Scan()` to scan the bus for a specific I2C address.
It does this by trying to read from the specified address
- Line 232-241: We define the method `Read()` for a single byte read, this simply calls the other `Read()` method
- Line 243-330: We define the method `Read()` for one or more bytes
  - Line 252: We assert that the `Initialize()` method was correctly called
  - Line 254-257: We check that the I2C address is not out of range, and we're not trying to receive zero length data.
Notice that we support both 7 bit and 10 bit addresses.
If the address is not in range, we return an error code
  - Line 258-266: We check if the address is larger than the value address for 7 bits (larger or equal to 0x78).
If so we set the first data byte to write to the low 8 bits of the address, and set the new address byte to 0x78 OR'ed with the upper two bits of the address.
We then perform write-read operation to the new slave address, with the byte to be written equal to the low 8 bits of the address.
If the write fails, we return an error code
  - Line 267: We convert the low 7 bits to an address byte as we are dealing with a 7 bit address
  - Line 269-270: We convert the buffer pointer to a byte pointer and assert it is valid
  - Line 274: We set the I2C address with the new slave address
  - Line 276: We clear the FIFO
  - Line 277: We reset the Clock Stretch Timeout, Error (Nack) and Done conditions
  - Line 278: We set the data length
  - Line 279: We set read mode, enable the I2C controller, and start the transfer
  - Line 281-292: As long as the Done condition is not set, we read the status and check for available data.
If there is data, we read it and place it in the buffer
  - Line 294-302: Even when the Done condition is true, we read data as long as more is available
  - Line 308: We read the status register
  - Line 309-315: We check for an Error condition (meaning no Ack was received), and if so reset the condition and set an error code as the result
  - Line 316-320: We check for an Clock Stretch Timeout condition, and if so reset the condition and set an error code as the result
  - Line 321-324: We check that all requested data was read, and if not set an error code as the result
  - Line 327: We reset the Done condition
- Line 332-341: We define the method `Write()` for a single byte write, this simply calls the other `Write()` method
- Line 343-445: We define the method `Write()` for one or more bytes
  - Line 352: We assert that the `Initialize()` method was correctly called
  - Line 354-357: We check that the address is within the right range and if not return an error code
  - Line 359-362: We check that the buffer is valid and the requested byte count is not zero and if not return an error code
  - Line 364-365: We convert the buffer pointer to a byte pointer and assert it is valid
  - Line 369: We clear the FIFO
  - Line 372: We convert the low 7 bits to an address byte, which is the default behaviour for the 7 bit address case
  - Line 373-381: We check if the address is larger than the value address for 7 bits (larger or equal to 0x78).
If so we set the first data byte to write to the low 8 bits of the address, and set the address byte to 0x78 OR'ed with the upper two bits of the address.
We then add the low 8 bits to the FIFO, and increment the write count to signal that one byte is already in the transmit FIFO
  - Line 383: We set the I2C address with the new slave address
  - Line 384: We reset the Clock Stretch Timeout, Error (Nack) and Done conditions
  - Line 385: We set the data length
  - Line 387-393: We write data to the FIFO until done or the FIFO is full
  - Line 395: We set write mode, enable the I2C controller, and start the transfer
  - Line 397-408: As long as the Done condition is not set, we read the status and check whether there is space in the FIFO to write data.
If there is space and we need to write more data, we write to the FIFO
  - Line 415: We read the I2C Status Register
  - Line 416-422: If there was an Error condition (no Ack received) we reset the Error condition and return an error code
  - Line 423-427: If there was a Clock Stretch Timeout, we reset the Error condition and return an error code
  - Line 428-431: If there is still data to be written, we return an error code
  - Line 434: We reset the Done bit
  - Line 436-442: If there is data to be read we read it. This is to avoid confusion between transfers
- Line 447-566: We define the method `WriteReadRepeatedStart()` to write and read data simultaneously
  - Line 458: We assert that the `Initialize()` method was correctly called
  - Line 460-463: We check that the address is within the right range and if not return an error code
  - Line 465-470: We check that the read and write buffer are valid and the requested send byte count is not zero and not more than the FIFO can hold, as well as that the requested receive count is not zero, and if not return an error code
  - Line 472: We convert the write buffer pointer to a byte pointer
  - Line 476: We clear the FIFO
  - Line 479: We convert the low 7 bits to an address byte, which is the default behaviour for the 7 bit address case
  - Line 480-488: We check if the address is larger than the value address for 7 bits (larger or equal to 0x78).
If so we set the first data byte to write to the low 8 bits of the address, and set the address byte to 0x78 OR'ed with the upper two bits of the address.
We then add the low 8 bits to the FIFO, and increment the write count to signal that one byte is already in the transmit FIFO
  - Line 490: We set the I2C address with the new slave address
  - Line 491: We reset the Clock Stretch Timeout, Error (Nack) and Done conditions
  - Line 492: We set the data length with the number of bytes to send
  - Line 494-501: We write data to the FIFO until done or the FIFO is full
  - Line 503: We set write mode, enable the I2C controller, and start the transfer
  - Line 506-512: If no transfer is active, we check is the Done condition is set, and continue if it is.
  - Line 514: We convert the read buffer pointer to a byte pointer
  - Line 516: We set the data length with the number of bytes to receive
  - Line 517: We set read mode, enable the I2C controller, and start the transfer
  - Line 519-520: We wait a bit depending on the number of bytes sent and the I2C clock rate
  - Line 522-532: As long as the Done condition is not set, we read the status and check whether there is receive data available.
If so we read the data from the FIFO.
  - Line 534-541: As long as the there is receive data available, we read the data from the FIFO.
  - Line 544: We read the I2C Status Register
  - Line 545-551: If there was an Error condition (no Ack received) we reset the Error condition and return an error code
  - Line 552-556: If there was a Clock Stretch Timeout, we reset the Error condition and return an error code
  - Line 557-560: If we could not read the requested amount of bytes, we return an error code
  - Line 563: We reset the Done bit
- Line 568-587: We define the method `ReadControlRegister()`. If tracing is enabled we log the register contents
- Line 589-607: We define the method `WriteControlRegister()`. If tracing is enabled we log the register contents
- Line 609-615: We define the method `StartReadTransfer()`
- Line 617-623: We define the method `StartWriteTransfer()`
- Line 625-631: We define the method `ClearFIFO()`
- Line 633-643: We define the method `WriteAddressRegister()`. If tracing is enabled we log the register contents
- Line 645-655: We define the method `WriteDataLengthRegister()`. If tracing is enabled we log the register contents
- Line 657-679: We define the method `ReadStatusRegister()`. If tracing is enabled we log the register contents
- Line 681-695: We define the method `WriteStatusRegister()`. If tracing is enabled we log the register contents
- Line 697-704: We define the method `HasClockStretchTimeout()`
- Line 706-713: We define the method `HasAck()`
- Line 715-722: We define the method `HasNAck()`
- Line 724-731: We define the method `ReceiveFIFOFull()`
- Line 733-740: We define the method `ReceiveFIFOHasData()`
- Line 742-749: We define the method `ReceiveFIFONeedsReading()`
- Line 751-758: We define the method `TransmitFIFOEmpty()`
- Line 760-767: We define the method `TransmitFIFOHasSpace()`
- Line 769-776: We define the method `TransmitFIFONeedsWriting()`
- Line 778-785: We define the method `TransferDone()`
- Line 787-794: We define the method `TransferActive()`
- Line 796-802: We define the method `ClearClockStretchTimeout()`
- Line 804-810: We define the method `ClearNAck()`
- Line 812-818: We define the method `ClearDone()`
- Line 820-826: We define the method `ClearAllStatus()`
- Line 828-839: We define the method `ReadFIFORegister()`
- Line 841-851: We define the method `WriteFIFORegister()`

In principle we could start writing an application, but we'll fake the I2C functionality first.

### MemoryAccessStubI2C.h {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_MEMORYACCESSSTUBI2CH}

We'll define a `IMemoryAccess` implementation that will fake the I2C register access, and also handles the case where GPIO is addressed.

Create file `code/libraries/baremetal/include/baremetal/stubs/MemoryAccessStubI2C.h`

```cpp
File: code/libraries/baremetal/include/baremetal/stubs/MemoryAccessStubI2C.h
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MemoryAccessStubI2C.h
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : MemoryAccessStubI2C
9: //
10: // Description : I2C register memory access stub
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39: 
40: #pragma once
41: 
42: #include <stdlib/Macros.h>
43: #include <baremetal/stubs/MemoryAccessStubGPIO.h>
44: 
45: /// @file
46: /// MemoryAccessStubI2C
47: 
48: namespace baremetal {
49: 
50: /// @brief I2C registers storage
51: struct I2CRegisters
52: {
53:     /// @brief I2C Control Register (C)
54:     uint32 ControlRegister;
55:     /// @brief I2C Status Register (C)
56:     uint32 StatusRegister;
57:     /// @brief I2C Data Length Register (DLEN)
58:     uint32 DataLengthRegister;
59:     /// @brief I2C Address Register (A)
60:     uint32 AddressRegister;
61:     /// @brief I2C FIFO Register (FIFO)
62:     uint32 FIFORegister;
63:     /// @brief I2C ClockDivider Register (DIV)
64:     uint32 ClockDividerRegister;
65:     /// @brief I2C Data Delay Register (DEL)
66:     uint32 DataDelayRegister;
67:     /// @brief I2C Clock Stretch Timeout Register (CLKT)
68:     uint32 ClockStretchTimeoutRegister;
69: 
70:     /// <summary>
71:     /// Constructor for I2CRegisters
72:     ///
73:     /// Sets default register values
74:     /// </summary>
75:     I2CRegisters()
76:         : ControlRegister{}
77:         , StatusRegister{0x00000050}
78:         , DataLengthRegister{}
79:         , AddressRegister{}
80:         , FIFORegister{}
81:         , ClockDividerRegister{0x000005DC}
82:         , DataDelayRegister{0x00300030}
83:         , ClockStretchTimeoutRegister{0x00000040}
84:     {
85:     }
86: } PACKED;
87: 
88: /// @brief FIFO size (both read and write)
89: #define I2C_FIFO_SIZE 16
90: 
91: /// @brief FIFO template class
92: template<int N>
93: class FIFO
94: {
95: private:
96:     /// @brief Data in FIFO (max 16 bytes)
97:     uint8 m_data[N];    // Size 16
98:     /// @brief Read index. If m_readIndex == m_writeIndex, the FIFO is either empty or full, depending on the full flag
99:     int   m_readIndex;  // Size 4
100:     /// @brief Write index. If m_readIndex == m_writeIndex, the FIFO is either empty or full, depending on the full flag
101:     int   m_writeIndex; // Size 4
102:     /// @brief Flag whether the FIFO is full
103:     bool  m_isFull;     // Size 1
104:     /// @brief Force alignment to 16 bytes
105:     uint8 align[7];     // Size 7
106: 
107: public:
108:     /// <summary>
109:     /// FIFO constructor
110:     /// </summary>
111:     FIFO()
112:         : m_data{}
113:         , m_readIndex{}
114:         , m_writeIndex{}
115:         , m_isFull{}
116:     {
117:     }
118:     /// <summary>
119:     /// Read a byte from the FIFO
120:     /// </summary>
121:     /// <returns>Byte read. If nothing can be read, returns 0</returns>
122:     uint8 Read()
123:     {
124:         uint8 result{};
125:         if (!IsEmpty())
126:         {
127:             result = m_data[m_readIndex];
128:             m_readIndex = (m_readIndex + 1) % N;
129:             m_isFull = false;
130:         }
131:         return result;
132:     }
133:     /// <summary>
134:     /// Write a byte to the FIFO
135:     /// </summary>
136:     /// <param name="data">Data to write</param>
137:     void Write(uint8 data)
138:     {
139:         if (!IsFull())
140:         {
141:             m_data[m_writeIndex] = data;
142:             m_writeIndex = (m_writeIndex + 1) % N;
143:             if (m_readIndex == m_writeIndex)
144:                 m_isFull = true;
145:         }
146:     }
147:     /// <summary>
148:     /// Check if FIFO is empty
149:     /// </summary>
150:     /// <returns>true if FIFO is empty, false otherwise</returns>
151:     bool IsEmpty()
152:     {
153:         return (m_readIndex == m_writeIndex) && !m_isFull;
154:     }
155:     /// <summary>
156:     /// Check if FIFO is full
157:     /// </summary>
158:     /// <returns>true if FIFO is full, false otherwise</returns>
159:     bool IsFull()
160:     {
161:         return (m_readIndex == m_writeIndex) && m_isFull;
162:     }
163:     /// <summary>
164:     /// Check if FIFO is at most 25% full
165:     /// </summary>
166:     /// <returns>true if FIFO is at most 25% full, false otherwise</returns>
167:     bool IsOneQuarterOrLessFull()
168:     {
169:         return ((m_writeIndex - m_readIndex + I2C_FIFO_SIZE) % I2C_FIFO_SIZE) <= (I2C_FIFO_SIZE / 4);
170:     }
171:     /// <summary>
172:     /// Check if FIFO is at least 75% full (at most 25% empty)
173:     /// </summary>
174:     /// <returns>true if FIFO is at least 75% full, false otherwise</returns>
175:     bool IsThreeQuartersOrMoreFull()
176:     {
177:         return ((m_readIndex - m_writeIndex + I2C_FIFO_SIZE) % I2C_FIFO_SIZE) <= (I2C_FIFO_SIZE / 4);
178:     }
179:     /// <summary>
180:     /// Flush the FIFO
181:     /// </summary>
182:     void Flush()
183:     {
184:         m_readIndex = m_writeIndex = 0;
185:         m_isFull = false;
186:     }
187: };
188: 
189: /// @brief Callback for sending address
190: using SendAddressByteCallback = bool(I2CRegisters& registers, uint8 address);
191: /// @brief Callback for receiving data
192: using RecvDataByteCallback = bool(I2CRegisters& registers, uint8 &data);
193: /// @brief Callback for sending data
194: using SendDataByteCallback = bool(I2CRegisters& registers, uint8 data);
195: 
196: /// @brief MemoryAccess implementation for I2C stub
197: class MemoryAccessStubI2C:
198:     public MemoryAccessStubGPIO
199: {
200: private:
201:     /// @brief Storage for I2C registers
202:     I2CRegisters m_registers;
203:     /// @brief I2C master base address
204:     uintptr m_i2cMasterBaseAddress;
205:     /// @brief Receive FIFO
206:     FIFO<I2C_FIFO_SIZE> m_rxFifo;
207:     /// @brief Send FIFO
208:     FIFO<I2C_FIFO_SIZE> m_txFifo;
209:     /// @brief Pointer to send address callback
210:     SendAddressByteCallback* m_sendAddressByteCallback;
211:     /// @brief Pointer to receive data callback
212:     RecvDataByteCallback* m_recvDataByteCallback;
213:     /// @brief Pointer to send data callback
214:     SendDataByteCallback* m_sendDataByteCallback;
215:     /// @brief Number of data bytes received
216:     uint8 m_numBytesReceived;
217:     /// @brief Number of data bytes sent
218:     uint8 m_numBytesSent;
219: 
220: public:
221:     MemoryAccessStubI2C();
222:     void SetBus(uint8 bus);
223: 
224:     uint8  Read8(regaddr address) override;
225:     void   Write8(regaddr address, uint8 data) override;
226: 
227:     uint16 Read16(regaddr address) override;
228:     void   Write16(regaddr address, uint16 data) override;
229: 
230:     uint32 Read32(regaddr address) override;
231:     void   Write32(regaddr address, uint32 data) override;
232: 
233:     void SetSendAddressByteCallback(SendAddressByteCallback callback);
234:     void SetRecvDataByteCallback(RecvDataByteCallback callback);
235:     void SetSendDataByteCallback(SendDataByteCallback callback);
236: 
237: private:
238:     uint32 GetRegisterOffset(regaddr address);
239:     void HandleWriteControlRegister(uint32 data);
240:     void HandleWriteStatusRegister(uint32 data);
241:     void HandleWriteFIFORegister(uint8 data);
242:     uint8 HandleReadFIFORegister();
243:     void HandleSendData();
244:     void HandleRecvData();
245:     void UpdateFIFOStatus();
246:     void CancelTransfer();
247:     void EndTransfer();
248: };
249: 
250: } // namespace baremetal
```

- Line 50-86: We declare a struct `I2CRegisters` to hold the register values for the I2C device
  - Line 53-54: The member variable `ControlRegister` holds the Control Register value
  - Line 55-56: The member variable `StatusRegister` holds the Status Register value
  - Line 57-58: The member variable `DataLengthRegister` holds the DataLength  Register value
  - Line 59-60: The member variable `AddressRegister` holds the Address Register value
  - Line 61-62: The member variable `FIFORegister` holds the FIFO Register entry point
  - Line 63-64: The member variable `ClockDividerRegister` holds the Clock Divider Register value
  - Line 65-66: The member variable `DataDelayRegister` holds the Data Delay Register value
  - Line 67-68: The member variable `ClockStretchTimeoutRegister` holds the Clock Stretch Timeout Register value
  - Line 70-85: We define the constructor, which initializes the register values to their defaults
- Line 88-89: We define `I2C_FIFO_SIZE` as the size of the receive and transmit FIFO
- Line 91-187: We declare and define the template class `FIFO` with the FIFO size as its parameter.
This class acts as the FIFO for receiving and transmitting data
  - Ling 96-97: The member variable `m_data` holds the FIFO data
  - Line 98-99: The member variable `m_readIndex` is the index of the next item to be read from the FIFO
  - Line 100-101: The member variable `m_writeIndex` is the index of the next item to be written to the FIFO
  - Line 102-103: The member variable `m_isFull` denotes whether the FIFO is full. The FIFO is implemented as a cyclic buffer, so when the read and write index are equal, this can both mean it is empty or full.
This variable distinguishes the two cases
  - Line 104-105: The member variable `align` is a fake variable to make sure the FIFO size is a multiple of 16 bytes.
If this is not the case we will end up getting alignment faults
  - Line 108-117: We implement the constructor
  - Line 118-132: We define the method `Read()` which reads an element from the FIFO.
This reads the element at the read position and increments the position, if the FIFO is not empty.
Otherwise, a dummy value is returned
  - Line 133-146: We define the method `Write()` which writes an element to the FIFO.
This write the element at the write position and increments the position, if the FIFO is not full.
Otherwise, nothing is written
  - Line 147-154: We define the method `IsEmpty()` which returns true if the FIFO is empty
  - Line 155-162: We define the method `IsFull()` which returns true if the FIFO is full
  - Line 163-170: We define the method `IsOneQuarterOrLessFull()` which returns true if the FIFO is 25% or less filled
  - Line 171-178: We define the method `IsThreeQuartersOrMoreFull()` which returns true if the FIFO is 75% or more filled
  - Line 179-186: We define the method `Flush()` which flushes the FIFO, i.e. makes it empty
- Line 189-190: We define the type `SendAddressByteCallback` as a callback function when the I2C address is written
- Line 191-192: We define the type `RecvDataByteCallback` as a callback function when data is read from the I2C device
- Line 193-194: We define the type `SendvDataByteCallback` as a callback function when data is written to the I2C device
- Line 196-247: We declare the class `MemoryAccessStubI2C` which acts as the `MemoryAccess` class for fake I2C access.
Note that it derives from `MemoryAccessStubGPIO`
  - Line 201-202: The member variable `m_registers` contains the values of the I2C device registers
  - Line 203-204: The member variable `m_i2cMasterBaseAddress` holds the register base address of the selected I2C device
  - Line 205-206: The member variable `m_rxFifo` holds receive FIFO
  - Line 207-208: The member variable `m_txFifo` holds transmit FIFO
  - Line 209-210: The member variable `m_sendAddressByteCallback` holds the callback function pointer for sending the address byte
  - Line 211-212: The member variable `m_recvDataByteCallback` holds the callback function pointer for receiving a data byte
  - Line 213-214: The member variable `m_sendDataByteCallback` holds the callback function pointer for sending a data byte
  - Line 215-216: The member variable `m_numBytesReceived` holds the number of bytes received in the current transaction
  - Line 217-218: The member variable `m_numBytesSent` holds the number of bytes sent in the current transaction
  - Line 221: We declare the constructor
  - Line 222: We declare the method `SetBus()` to set the I2C bus to use
  - Line 224-231: We override the read / write methods for the interface
  - Line 233-235: We declare methods to set the respective callback function pointers
  - Line 238: We declare the method `GetRegisterOffset()` to calculate the register offset relative to the register base address for the I2C device
  - Line 239: We declare the method `HandleWriteControlRegister()` to handle writing to the control register.
As this can change state, this has to be specifically handled
  - Line 240: We declare the method `HandleWriteStatusRegister()` to handle writing to the status register.
As this can change state, this has to be specifically handled
  - Line 241: We declare the method `HandleWriteFIFORegister()` to handle writing to the FIFO register.
This will update the FIFO and its status bits
  - Line 242: We declare the method `HandleReadFIFORegister()` to handle reading to the FIFO register.
This will update the FIFO and its status bits
  - Line 243: We declare the method `HandleSendData()` to handle receiving data from a (fake) device
  - Line 244: We declare the method `HandleRecvData()` to handle sending data to a (fake) device
  - Line 245: We declare the method `UpdateFIFOStatus()` to update the status for the FIFO in the status register
  - Line 246: We declare the method `CancelTransfer()` to cancel a transaction.
The transaction will be set to done, but with a failed ACK
  - Line 247: We declare the method `EndTransfer()` to finish a transaction.
The transaction will be set to done

### MemoryAccessStubI2C.cpp {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_MEMORYACCESSSTUBI2CCPP}

We'll implement the MemoryAccess stub for I2C.

Create file `code/libraries/baremetal/src/stubs/MemoryAccessStubI2C.cpp`

```cpp
File: code/libraries/baremetal/src/stubs/MemoryAccessStubI2C.cpp
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MemoryAccessStubI2C.cpp
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : MemoryAccessStubI2C
9: //
10: // Description : I2C register memory access stub implementation
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39: 
40: #include <baremetal/stubs/MemoryAccessStubI2C.h>
41: 
42: #include <baremetal/Assert.h>
43: #include <baremetal/BCMRegisters.h>
44: #include <baremetal/Format.h>
45: #include <baremetal/Logger.h>
46: #include <baremetal/String.h>
47: 
48: /// @file
49: /// MemoryAccessStubI2C
50: 
51: /// @brief Define log name
52: LOG_MODULE("MemoryAccessStubI2C");
53: 
54: using namespace baremetal;
55: 
56: /// @brief I2C bus 0 register base address
57: static regaddr I2CBaseAddress0{ RPI_I2C0_BASE };
58: /// @brief I2C bus 1 register base address
59: static regaddr I2CBaseAddress1{ RPI_I2C1_BASE };
60: #if BAREMETAL_RPI_TARGET == 3
61: /// @brief I2C bus 2 register base address
62: static regaddr I2CBaseAddress2{ RPI_I2C2_BASE };
63: #elif BAREMETAL_RPI_TARGET == 4
64: /// @brief I2C bus 3 register base address
65: static regaddr I2CBaseAddress3{ RPI_I2C3_BASE };
66: /// @brief I2C bus 4 register base address
67: static regaddr I2CBaseAddress4{ RPI_I2C4_BASE };
68: /// @brief I2C bus 5 register base address
69: static regaddr I2CBaseAddress5{ RPI_I2C5_BASE };
70: /// @brief I2C bus 6 register base address
71: static regaddr I2CBaseAddress6{ RPI_I2C6_BASE };
72: #endif
73: /// @brief Mask to check whether an address is in the range for a specific I2C bus
74: static uintptr I2CBaseAddressMask{ 0xFFFFFFFFFFFFFFE0 };
75: 
76: /// <summary>
77: /// MemoryAccessStubI2C constructor
78: /// </summary>
79: MemoryAccessStubI2C::MemoryAccessStubI2C()
80:     : m_registers{}
81:     , m_i2cMasterBaseAddress{}
82:     , m_sendAddressByteCallback{}
83:     , m_recvDataByteCallback{}
84:     , m_sendDataByteCallback{}
85:     , m_numBytesReceived{}
86:     , m_numBytesSent{}
87: {
88: }
89: 
90: /// <summary>
91: /// Set I2C device bus number
92: /// </summary>
93: /// <param name="bus">I2C device bus number (0..6) depending on Raspberry Pi model</param>
94: void MemoryAccessStubI2C::SetBus(uint8 bus)
95: {
96:     switch (bus)
97:     {
98:         case 0:
99:             m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress0);
100:             break;
101:         case 1:
102:             m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress1);
103:             break;
104: #if BAREMETAL_RPI_TARGET == 3
105:         case 2:
106:             m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress2);
107:             break;
108: #elif BAREMETAL_RPI_TARGET == 4
109:         case 3:
110:             m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress3);
111:             break;
112:         case 4:
113:             m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress4);
114:             break;
115:         case 5:
116:             m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress5);
117:             break;
118:         case 6:
119:             m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress6);
120:             break;
121: #endif
122:     default:
123:         assert(false);
124:     }
125: }
126: 
127: /// <summary>
128: /// Read a 8 bit value from register at address
129: /// </summary>
130: /// <param name="address">Address of register</param>
131: /// <returns>8 bit register value</returns>
132: uint8 MemoryAccessStubI2C::Read8(regaddr address)
133: {
134:     LOG_PANIC("Call to Read8 should not happen");
135:     return {};
136: }
137: 
138: /// <summary>
139: /// Write a 8 bit value to register at address
140: /// </summary>
141: /// <param name="address">Address of register</param>
142: /// <param name="data">Data to write</param>
143: void MemoryAccessStubI2C::Write8(regaddr address, uint8 data)
144: {
145:     LOG_PANIC("Call to Write8 should not happen");
146: }
147: 
148: /// <summary>
149: /// Read a 16 bit value from register at address
150: /// </summary>
151: /// <param name="address">Address of register</param>
152: /// <returns>16 bit register value</returns>
153: uint16 MemoryAccessStubI2C::Read16(regaddr address)
154: {
155:     LOG_PANIC("Call to Read16 should not happen");
156:     return {};
157: }
158: 
159: /// <summary>
160: /// Write a 16 bit value to register at address
161: /// </summary>
162: /// <param name="address">Address of register</param>
163: /// <param name="data">Data to write</param>
164: void MemoryAccessStubI2C::Write16(regaddr address, uint16 data)
165: {
166:     LOG_PANIC("Call to Write16 should not happen");
167: }
168: 
169: /// <summary>
170: /// Read a 32 bit value from register at address
171: /// </summary>
172: /// <param name="address">Address of register</param>
173: /// <returns>32 bit register value</returns>
174: uint32 MemoryAccessStubI2C::Read32(regaddr address)
175: {
176:     uintptr addr = reinterpret_cast<uintptr>(address);
177:     if ((addr >= RPI_GPIO_BASE) && (addr < RPI_GPIO_END))
178:     {
179:         return MemoryAccessStubGPIO::Read32(address);
180:     }
181: 
182:     uintptr offset = GetRegisterOffset(address);
183:     uint32 *registerField = reinterpret_cast<uint32 *>(reinterpret_cast<uint8 *>(&m_registers) + offset);
184:     LOG_DEBUG("I2C Read register %016x = %08x", offset, *registerField);
185:     switch (offset)
186:     {
187:         case RPI_I2C_C_OFFSET:
188:         {
189:             string line{ "I2C Read Control Register "};
190:             if (*registerField & RPI_I2C_C_ENABLE)
191:                 line += "Enable ON  ";
192:             else
193:                 line += "Enable OFF ";
194:             if (*registerField & RPI_I2C_C_INTR_ENABLE)
195:                 line += "RX Interrupt ON  ";
196:             else
197:                 line += "RX Interrupt OFF ";
198:             if (*registerField & RPI_I2C_C_INTT_ENABLE)
199:                 line += "TX Interrupt ON  ";
200:             else
201:                 line += "TX Interrupt OFF ";
202:             if (*registerField & RPI_I2C_C_INTD_ENABLE)
203:                 line += "DONE Interrupt ON  ";
204:             else
205:                 line += "DONE Interrupt OFF ";
206:             if (*registerField & RPI_I2C_C_READ)
207:                 line += "Read ";
208:             else
209:                 line += "Write ";
210:             LOG_DEBUG(line.c_str());
211:             break;
212:         }
213:         case RPI_I2C_S_OFFSET:
214:         {
215:             string line{ "I2C Read Status Register "};
216:             if (*registerField & RPI_I2C_S_CLKT)
217:                 line += "CLKT ";
218:             else
219:                 line += "     ";
220:             if (*registerField & RPI_I2C_S_ERR)
221:                 line += "NACK ";
222:             else
223:                 line += "ACK  ";
224:             if (*registerField & RPI_I2C_S_RXF)
225:                 line += "RXF ";
226:             else
227:                 line += "    ";
228:             if (*registerField & RPI_I2C_S_TXE)
229:                 line += "TXE ";
230:             else
231:                 line += "    ";
232:             if (*registerField & RPI_I2C_S_RXD)
233:                 line += "RXD ";
234:             else
235:                 line += "    ";
236:             if (*registerField & RPI_I2C_S_TXD)
237:                 line += "TXD ";
238:             else
239:                 line += "    ";
240:             if (*registerField & RPI_I2C_S_RXR)
241:                 line += "RXR ";
242:             else
243:                 line += "    ";
244:             if (*registerField & RPI_I2C_S_TXW)
245:                 line += "TXW ";
246:             else
247:                 line += "    ";
248:             if (*registerField & RPI_I2C_S_DONE)
249:                 line += "DONE ";
250:             else
251:                 line += "     ";
252:             if (*registerField & RPI_I2C_S_TA)
253:                 line += "TA ";
254:             else
255:                 line += "   ";
256:             LOG_DEBUG(line.c_str());
257:             break;
258:         }
259:         case RPI_I2C_DLEN_OFFSET:
260:         {
261:             LOG_DEBUG("I2C Get Data Length %d", *registerField);
262:             break;
263:         }
264:         case RPI_I2C_A_OFFSET:
265:         {
266:             LOG_DEBUG("I2C Get Address %02x", *registerField);
267:             break;
268:         }
269:         case RPI_I2C_FIFO_OFFSET:
270:         {
271:             LOG_DEBUG("I2C Read FIFO %02x", *registerField);
272:             *registerField = HandleReadFIFORegister();
273:             break;
274:         }
275:         case RPI_I2C_DIV_OFFSET:
276:         {
277:             LOG_DEBUG("I2C Set Clock Divider %d", *registerField);
278:             break;
279:         }
280:         case RPI_I2C_DEL_OFFSET:
281:         {
282:             if (*registerField & 0xFFFF0000)
283:             {
284:                 LOG_DEBUG("I2C Get Falling Edge Delay %d", (*registerField >> 16));
285:             }
286:             if (*registerField & 0x0000FFFF)
287:             {
288:                 LOG_DEBUG("I2C Get Rising Edge Delay %d", (*registerField & 0x0000FFFF));
289:             }
290:             break;
291:         }
292:         case RPI_I2C_CLKT_OFFSET:
293:         {
294:             LOG_DEBUG("I2C Get Clock Stretch Timeout %d", (*registerField & 0x0000FFFF));
295:             break;
296:         }
297:         default:
298:             LOG_ERROR("Invalid I2C register access for reading: offset %d", offset);
299:             break;
300:     }
301: 
302:     return *registerField;
303: }
304: 
305: /// <summary>
306: /// Write a 32 bit value to register at address
307: /// </summary>
308: /// <param name="address">Address of register</param>
309: /// <param name="data">Data to write</param>
310: void MemoryAccessStubI2C::Write32(regaddr address, uint32 data)
311: {
312:     uintptr addr = reinterpret_cast<uintptr>(address);
313:     if ((addr >= RPI_GPIO_BASE) && (addr < RPI_GPIO_END))
314:     {
315:         MemoryAccessStubGPIO::Write32(address, data);
316:         return;
317:     }
318: 
319:     uintptr offset = GetRegisterOffset(address);
320:     uint32 *registerField = reinterpret_cast<uint32 *>(reinterpret_cast<uint8 *>(&m_registers) + offset);
321:     LOG_DEBUG("I2C Write register %016x = %08x", offset, data);
322:     switch (offset)
323:     {
324:         case RPI_I2C_C_OFFSET:
325:         {
326:             uint32 diff = (data ^ *registerField) | 0x00B0;
327:             if (diff & RPI_I2C_C_ENABLE)
328:             {
329:                 if (data & RPI_I2C_C_ENABLE)
330:                     LOG_DEBUG("I2C Enable Controller");
331:                 else
332:                     LOG_DEBUG("I2C Disable Controller");
333:             }
334:             if (diff & RPI_I2C_C_INTR_ENABLE)
335:             {
336:                 if (data & RPI_I2C_C_INTR_ENABLE)
337:                     LOG_DEBUG("I2C Enable RX Interrupt");
338:                 else
339:                     LOG_DEBUG("I2C Disable RX Interrupt");
340:             }
341:             if (diff & RPI_I2C_C_INTT_ENABLE)
342:             {
343:                 if (data & RPI_I2C_C_INTT_ENABLE)
344:                     LOG_DEBUG("I2C Enable TX Interrupt");
345:                 else
346:                     LOG_DEBUG("I2C Disable TX Interrupt");
347:             }
348:             if (diff & RPI_I2C_C_INTD_ENABLE)
349:             {
350:                 if (data & RPI_I2C_C_INTD_ENABLE)
351:                     LOG_DEBUG("I2C Enable Done Interrupt");
352:                 else
353:                     LOG_DEBUG("I2C Disable Done Interrupt");
354:             }
355:             if (diff & RPI_I2C_C_READ)
356:             {
357:                 if (data & RPI_I2C_C_READ)
358:                     LOG_DEBUG("I2C Read Mode");
359:                 else
360:                     LOG_DEBUG("I2C Write Mode");
361:             }
362:             if (data & RPI_I2C_C_CLEAR)
363:                 LOG_DEBUG("I2C Clear FIFO");
364:             if (data & RPI_I2C_C_ST)
365:                 LOG_DEBUG("I2C Start Transfer");
366:             HandleWriteControlRegister(data);
367:             break;
368:         }
369:         case RPI_I2C_S_OFFSET:
370:         {
371:             if (data & RPI_I2C_S_CLKT)
372:                 LOG_DEBUG("I2C Reset Clock Stretch Timeout");
373:             if (data & RPI_I2C_S_ERR)
374:                 LOG_DEBUG("I2C Reset Ack Error");
375:             if (data & RPI_I2C_S_DONE)
376:                 LOG_DEBUG("I2C Reset Done");
377:             HandleWriteStatusRegister(data);
378:             break;
379:         }
380:         case RPI_I2C_DLEN_OFFSET:
381:         {
382:             LOG_DEBUG("I2C Set Data Length %d", data);
383:             *registerField = data;
384:             break;
385:         }
386:         case RPI_I2C_A_OFFSET:
387:         {
388:             LOG_DEBUG("I2C Set Address %02x", data);
389:             *registerField = data;
390:             break;
391:         }
392:         case RPI_I2C_FIFO_OFFSET:
393:         {
394:             LOG_DEBUG("I2C Write FIFO %02x", data);
395:             HandleWriteFIFORegister(data);
396:             break;
397:         }
398:         case RPI_I2C_DIV_OFFSET:
399:         {
400:             if (data != *registerField)
401:             {
402:                 LOG_DEBUG("I2C Set Clock Divider %d", data);
403:             }
404:             *registerField = data;
405:             break;
406:         }
407:         case RPI_I2C_DEL_OFFSET:
408:         {
409:             uint32 diff = data & *registerField;
410:             if (diff & 0xFFFF0000)
411:             {
412:                 LOG_DEBUG("I2C Set Falling Edge Delay %d", (data >> 16));
413:             }
414:             if (diff & 0x0000FFFF)
415:             {
416:                 LOG_DEBUG("I2C Set Rising Edge Delay %d", (data & 0x0000FFFF));
417:             }
418:             *registerField = data;
419:             break;
420:         }
421:         case RPI_I2C_CLKT_OFFSET:
422:         {
423:             uint32 diff = data & *registerField;
424:             if (diff & 0x0000FFFF)
425:             {
426:                 LOG_DEBUG("I2C Set Clock Stretch Timeout %d", (data & 0x0000FFFF));
427:             }
428:             *registerField = data;
429:             break;
430:         }
431:         default:
432:             LOG_ERROR("Invalid I2C register access for writing: offset %d", offset);
433:             break;
434:     }
435: }
436: 
437: /// <summary>
438: /// Set callback function for address send
439: /// </summary>
440: /// <param name="callback">Address of callback function</param>
441: void MemoryAccessStubI2C::SetSendAddressByteCallback(SendAddressByteCallback callback)
442: {
443:     m_sendAddressByteCallback = callback;
444: }
445: 
446: /// <summary>
447: /// Set callback function for data receive
448: /// </summary>
449: /// <param name="callback">Address of callback function</param>
450: void MemoryAccessStubI2C::SetRecvDataByteCallback(RecvDataByteCallback callback)
451: {
452:     m_recvDataByteCallback = callback;
453: }
454: 
455: /// <summary>
456: /// Set callback function for data send
457: /// </summary>
458: /// <param name="callback">Address of callback function</param>
459: void MemoryAccessStubI2C::SetSendDataByteCallback(SendDataByteCallback callback)
460: {
461:     m_sendDataByteCallback = callback;
462: }
463: 
464: /// <summary>
465: /// Determine register address offset, by checking against the different bus numbers
466: ///
467: /// If no bus matches the address, an assert if fired
468: /// </summary>
469: /// <param name="address">Address to check</param>
470: /// <returns>Offset relative to the base address for the respective bus, if one exists. Will return 0 (but assert) otherwise</returns>
471: uint32 MemoryAccessStubI2C::GetRegisterOffset(regaddr address)
472: {
473:     assert((reinterpret_cast<uintptr>(address) & I2CBaseAddressMask) == m_i2cMasterBaseAddress);
474:     return reinterpret_cast<uintptr>(address) - m_i2cMasterBaseAddress;
475: }
476: 
477: /// <summary>
478: /// Handle writing to I2C Control Register
479: /// </summary>
480: /// <param name="data">Value to write to the register</param>
481: void MemoryAccessStubI2C::HandleWriteControlRegister(uint32 data)
482: {
483:     if ((data & RPI_I2C_C_CLEAR) != 0)
484:     {
485:         m_rxFifo.Flush();
486:         m_txFifo.Flush();
487:         m_numBytesReceived = 0;
488:         m_numBytesSent = 0;
489:     }
490:     m_registers.ControlRegister = data & ~(RPI_I2C_C_CLEAR | RPI_I2C_C_ST);
491:     if (((data & RPI_I2C_C_ENABLE) != 0) && 
492:         ((data & RPI_I2C_C_ST) != 0))
493:     {
494:         // We started a (new) transaction
495:         m_registers.StatusRegister = m_registers.StatusRegister | RPI_I2C_S_TA;
496:         if (m_sendAddressByteCallback)
497:         {
498:             if (!(*m_sendAddressByteCallback)(m_registers, m_registers.AddressRegister))
499:                 m_registers.StatusRegister |= RPI_I2C_S_ERR;
500:         }
501:         if ((m_registers.ControlRegister & RPI_I2C_C_READ) != 0)
502:         {
503:             HandleRecvData();
504:         }
505:         else
506:         {
507:             HandleSendData();
508:         }
509:     }
510: }
511: 
512: /// <summary>
513: /// Handle writing to I2C Status Register
514: /// </summary>
515: /// <param name="data">Value to write to the register</param>
516: void MemoryAccessStubI2C::HandleWriteStatusRegister(uint32 data)
517: {
518:     if (data & RPI_I2C_S_ERR)
519:     {
520:         m_registers.StatusRegister = m_registers.StatusRegister & ~RPI_I2C_S_ERR;
521:     }
522:     if (data & RPI_I2C_S_DONE)
523:     {
524:         m_registers.StatusRegister = m_registers.StatusRegister & ~(RPI_I2C_S_DONE | RPI_I2C_S_TA);
525:     }
526:     if (data & RPI_I2C_S_CLKT)
527:     {
528:         m_registers.StatusRegister = m_registers.StatusRegister & ~RPI_I2C_S_CLKT;
529:     }
530: }
531: 
532: /// <summary>
533: /// Handle writing to I2C Transmit FIFO Register
534: /// </summary>
535: /// <param name="data">Value to write to the register</param>
536: void MemoryAccessStubI2C::HandleWriteFIFORegister(uint8 data)
537: {
538:     if (!m_txFifo.IsFull())
539:     {
540:         m_txFifo.Write(data);
541:     }
542:     UpdateFIFOStatus();
543:     HandleSendData();
544: }
545: 
546: /// <summary>
547: /// Handle reading to I2C Receive FIFO Register
548: /// </summary>
549: /// <returns>Value read from the FIFO</returns>
550: uint8 MemoryAccessStubI2C::HandleReadFIFORegister()
551: {
552:     uint8 result{};
553:     HandleRecvData();
554:     if (!m_rxFifo.IsEmpty())
555:     {
556:         result = m_rxFifo.Read();
557:     }
558:     UpdateFIFOStatus();
559:     return result;
560: }
561: 
562: /// <summary>
563: /// Handle transmitting data
564: /// </summary>
565: void MemoryAccessStubI2C::HandleSendData()
566: {
567:     if (((m_registers.StatusRegister & RPI_I2C_S_TA) != 0) && 
568:         ((m_registers.ControlRegister & RPI_I2C_C_READ) == 0))
569:     {
570:         while (!m_txFifo.IsEmpty() && (m_numBytesSent < m_registers.DataLengthRegister))
571:         {
572:             auto data = m_txFifo.Read();
573:             UpdateFIFOStatus();
574:             bool sentData{};
575:             if (m_sendDataByteCallback)
576:                 sentData = (*m_sendDataByteCallback)(m_registers, data);
577:             if (sentData)
578:                 ++m_numBytesSent;
579:             else
580:             {
581:                 CancelTransfer();
582:                 break;
583:             }
584:         }
585:     }
586:     if (m_numBytesSent >= m_registers.DataLengthRegister)
587:         EndTransfer();
588: }
589: 
590: /// <summary>
591: /// Handle receiving data
592: /// </summary>
593: void MemoryAccessStubI2C::HandleRecvData()
594: {
595:     if (((m_registers.ControlRegister & RPI_I2C_C_ENABLE) != 0) && 
596:         ((m_registers.ControlRegister & RPI_I2C_C_READ) != 0))
597:     {
598:         bool rxFull = m_rxFifo.IsFull();
599:         while (!m_rxFifo.IsFull() && (m_numBytesReceived < m_registers.DataLengthRegister))
600:         {
601:             uint8 data{};
602:             bool receivedData{};
603:             if (m_recvDataByteCallback)
604:             {
605:                 receivedData = (*m_recvDataByteCallback)(m_registers, data);
606:             }
607:             if (receivedData)
608:             {
609:                 m_rxFifo.Write(data);
610:                 UpdateFIFOStatus();
611:                 ++m_numBytesReceived;
612:             }
613:             else
614:             {
615:                 CancelTransfer();
616:                 break;
617:             }
618:         }
619:     }
620:     if (m_numBytesReceived >= m_registers.DataLengthRegister)
621:         EndTransfer();
622: }
623: 
624: /// <summary>
625: /// Update the FIFO status bits in the I2C Status Register
626: /// </summary>
627: void MemoryAccessStubI2C::UpdateFIFOStatus()
628: {
629:     if (m_txFifo.IsEmpty())
630:         m_registers.StatusRegister |= RPI_I2C_S_TXE;
631:     else
632:         m_registers.StatusRegister &= (~RPI_I2C_S_TXE);
633:     if (m_txFifo.IsFull())
634:         m_registers.StatusRegister |= RPI_I2C_S_TXD;
635:     else
636:         m_registers.StatusRegister &= (~RPI_I2C_S_TXD);
637:     if (m_txFifo.IsOneQuarterOrLessFull())
638:         m_registers.StatusRegister |= RPI_I2C_S_TXW;
639:     else
640:         m_registers.StatusRegister &= (~RPI_I2C_S_TXW);
641:     if (m_rxFifo.IsEmpty())
642:         m_registers.StatusRegister &= (~RPI_I2C_S_RXD);
643:     else
644:         m_registers.StatusRegister |= RPI_I2C_S_RXD;
645:     if (m_rxFifo.IsFull())
646:         m_registers.StatusRegister |= RPI_I2C_S_RXF;
647:     else
648:         m_registers.StatusRegister &= (~RPI_I2C_S_RXF);
649:     if (m_rxFifo.IsThreeQuartersOrMoreFull())
650:         m_registers.StatusRegister |= RPI_I2C_S_RXR;
651:     else
652:         m_registers.StatusRegister &= (~RPI_I2C_S_RXR);
653: }
654: 
655: /// <summary>
656: /// Cancel a transfer, i.e. set error flag to denote NACK, and set done flag
657: /// </summary>
658: void MemoryAccessStubI2C::CancelTransfer()
659: {
660:     m_registers.StatusRegister |= (RPI_I2C_S_ERR | RPI_I2C_S_DONE);
661:     m_registers.StatusRegister &= (~RPI_I2C_S_TA);
662: }
663: 
664: /// <summary>
665: /// Finalize a transfer, i.e. set done flag
666: /// </summary>
667: void MemoryAccessStubI2C::EndTransfer()
668: {
669:     m_registers.StatusRegister |= (RPI_I2C_S_DONE);
670:     m_registers.StatusRegister &= (~RPI_I2C_S_TA);
671: }
```

- Line 56-72: We define variables for the base addresses for each of the I2C buses, depending on the Raspberry Pi model.
- Line 73-74: We define the variable `I2CBaseAddressMask` to be able to check whether an adress is inside the range for a I2C bus
- Line 76-88: We implement the constructor
- Line 90-125: We implement the method `SetBus()`, which sets the base address for the selected I2C bus. If the bus number is invalid for the selected Raspbery Pi mode, an assertion is done
- Line 127-136: We implement the method `Read8()`. This results in a panic as we do not support 8 bit reads
- Line 138-146: We implement the method `Write8()`. This results in a panic as we do not support 8 bit writes
- Line 148-157: We implement the method `Read16()`. This results in a panic as we do not support 16 bit reads
- Line 159-167: We implement the method `Write16()`. This results in a panic as we do not support 16 bit writes
- Line 169-303: We implement the method `Read32()`
  - Line 176-180: We cast the pointer to a `uintptr`. If the address is in the GPIO range, we call the MemoryAccess stub for GPIO to handle the read
  - Line 182: We determine the I2C register offset from the address being read
  - Line 183: We determine the corresponding location in the register storage
  - Line 187-212: We handle the I2C Control Register, and log the respective bit values
  - Line 213-258: We handle the I2C Status Register, and log the respective bit values
  - Line 259-263: We handle the I2C Data Length Register, and log the value
  - Line 264-268: We handle the I2C Address Register, and log the value
  - Line 269-274: We handle the I2C FIFO Register, and log the value.
Here, we call `HandleReadFIFORegister()` to read the FIFO and handle the status
  - Line 275-279: We handle the I2C Clock Divider Register, and log the value
  - Line 280-291: We handle the I2C Delay Register, and log the value
  - Line 292-296: We handle the I2C Clock Stretch Timeout Register, and log the value
- Line 305-435: We implement the method `Write32()`
  - Line 312-317: We cast the pointer to a `uintptr`. If the address is in the GPIO range, we call the MemoryAccess stub for GPIO to handle the write
  - Line 319: We determine the I2C register offset from the address being read
  - Line 320: We determine the corresponding location in the register storage
  - Line 324-368: We handle the I2C Control Register, and log the respective bit values.
We call `HandleWriteControlRegister()` to handle writing to the Control Register
  - Line 369-379: We handle the I2C Status Register, and log the respective bit values.
We call `HandleWriteStatusRegister()` to handle writing to the Status Register
  - Line 380-385: We handle the I2C Data Length Register, and log the value
  - Line 386-391: We handle the I2C Address Register, and log the value
  - Line 392-397: We handle the I2C FIFO Register, and log the value.
Here, we call `HandleWriteFIFORegister()` to write the FIFO and handle the status
  - Line 398-406: We handle the I2C Clock Divider Register, and log the value
  - Line 407-420: We handle the I2C Delay Register, and log the value
  - Line 421-430: We handle the I2C Clock Stretch Timeout Register, and log the value
- Line 437-444: We implement the method `SetSendAddressByteCallback()`
- Line 446-453: We implement the method `SetRecvDataByteCallback()`
- Line 455-462: We implement the method `SetSendDataByteCallback()`
- Line 464-475: We implement the method `GetRegisterOffset()`.
This asserts that the address is in the range for the I2C registers, and then subtracts the base address for the selected I2C bus
- Line 477-510: We implement the method `HandleWriteControlRegister()`.
  - Line 483-489: We handle flushing the FIFO, and reset the number of bytes received / transmitted
  - Line 490: We set the Control Register value. We keep the FIFO clear bits and the start bit out of the value
  - Line 491-509: We handle starting a transaction.
This sets the TA bit in the Status Register, then sends out the address.
If this returns false we set the ERR bit.
We then call `HandleRecvData()` or `HandleSendData()` depending on whether this is a read or write transaction
- Line 512-530: We implement the method `HandleWriteStatusRegister()`.
  - Line 518-521: We handle resetting the ERR bit
  - Line 522-525: We handle resetting the DONE bit
  - Line 526-529: We handle resetting the CLKT bit
- Line 532-544: We implement the method `HandleWriteFIFORegister()`.
  - Line 538-541: If the FIFO is not full, we write the data
  - Line 542: We update the FIFO status bits
  - Line 543: We call `HandleSendData()` to send out any data from the FIFO
- Line 546-560: We implement the method `HandleReadFIFORegister()`.
  - Line 553: We call `HandleRecvData()` to receive any data into the FIFO
  - Line 554-557: If the FIFO is not empty, we read the data
  - Line 558: We update the FIFO status bits
- Line 562-588: We implement the method `HandleSendData()`.
  - Line 567-585: If there is a transmit transaction active, we read data from the FIFO while not empty and not all data has been sent (as set in the Data Length Register), and send this data.
If the result is true, we increment the number of bytes sent.
Otherwise, we cancel the transation
  - Line 586-587: If all data is sent, we finalize the transaction
- Line 590-622: We implement the method `HandleRecvData()`.
  - Line 595-619: If there is a receive transaction active, we receive data as long as the FIFO is not full and not all data has been received (as set in the Data Length Register).
If the receive call returns true, we write the data to the FIFO and update its status, and increment the number of bytes received.
Otherwise, we cancel the transation
  - Line 620-621: If all data is received, we finalize the transaction
- Line 624-653: We implement the method `UpdateFIFOStatus()`.
This updates the respective bits in the Status Register
- Line 655-662: We implement the method `CancelTransfer()`
- Line 664-671: We implement the method `EndTransfer()`

### Update application code {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_UPDATE_APPLICATION_CODE}

Next let's use the I2C stub and use I2CMaster with this stub.
We'll simply scan for a device at a specific address.

Update the file code/applications/demo/src/main.cpp.

```cpp
File: code/applications/demo/src/main.cpp
1: #include <baremetal/Format.h>
2: #include <baremetal/I2CMaster.h>
3: #include <baremetal/Logger.h>
4: #include <baremetal/PhysicalGPIOPin.h>
5: #include <baremetal/String.h>
6: #include <baremetal/System.h>
7: #include <baremetal/stubs/MemoryAccessStubI2C.h>
8:
9: LOG_MODULE("main");
10:
11: using namespace baremetal;
12:
13: bool WriteI2CAddress(I2CRegisters& registers, uint8 address)
14: {
15:     LOG_INFO("I2C Write address %02x", address);
16:     return false;
17: }
18:
19: bool ReadI2CData(I2CRegisters& registers, uint8& data)
20: {
21:     data = {};
22:     LOG_INFO("I2C Read data %02x", data);
23:     return false;
24: }
25:
26: bool WriteI2CData(I2CRegisters& registers, uint8 data)
27: {
28:     LOG_INFO("I2C Write data %02x", data);
29:     return false;
30: }
31:
32: int main()
33: {
34:     auto& console = GetConsole();
35:     GetLogger().SetLogLevel(LogSeverity::Debug);
36:
37:     MemoryAccessStubI2C fakeMemoryAccess;
38:
39:     I2CMaster master(fakeMemoryAccess);
40:     uint8 busIndex = 1;
41:     fakeMemoryAccess.SetSendAddressByteCallback(WriteI2CAddress);
42:     fakeMemoryAccess.SetRecvDataByteCallback(ReadI2CData);
43:     fakeMemoryAccess.SetSendDataByteCallback(WriteI2CData);
44:     fakeMemoryAccess.SetBus(busIndex);
45:
46:     if (!master.Initialize(busIndex))
47:     {
48:         LOG_ERROR("Cannot scan bus %d", busIndex);
49:     }
50:     uint8 address{ 0x20 };
51:     if (master.Scan(address))
52:     {
53:         LOG_INFO("On bus %d Address %02x there is a device", busIndex, address);
54:     }
55:     else
56:     {
57:         LOG_INFO("On bus %d Address %02x there is no device", busIndex, address);
58:     }
59:
60:     LOG_INFO("Rebooting");
61:
62:     return static_cast<int>(ReturnCode::ExitReboot);
63: }
```

- Line 13-17: We define a callback for writing the I2C address.
For now this will fail
- Line 19-24: We define a callback for reading data from a I2C device.
For now this will fail
- Line 26-30: We define a callback for writing data to a I2C device.
For now this will fail
- Line 37: We instantiate a I2C MemoryAccess stub
- Line 39: We instantiate a I2CMaster device, and inject the stub
- Line 41-43: We hook up the callbacks
- Line 44: We setup the stub for the I2C bus we're going to use
- Line 46: We initialize the I2CMaster to the same bus
- Line 51-58: We scan for address 0x20 (this is the address we'll be using for the MCP323017 later on).
If the scan is successful (the device answers), we print a success message, otherwise we print a failure message.
In the current case, this will of course fail

### Update baremetal CMake file {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_UPDATE_BAREMETAL_CMAKE_FILE}

As we added some files to the baremetal libary, we need update its CMake file.

Update the file `code/libraries/baremetal/CMakeLists.txt`

```cmake
File: code/libraries/baremetal/CMakeLists.txt
30: set(PROJECT_SOURCES
31:     ${CMAKE_CURRENT_SOURCE_DIR}/src/stubs/MemoryAccessStubGPIO.cpp
32:     ${CMAKE_CURRENT_SOURCE_DIR}/src/stubs/MemoryAccessStubI2C.cpp
33:     ${CMAKE_CURRENT_SOURCE_DIR}/src/Assert.cpp
34:     ${CMAKE_CURRENT_SOURCE_DIR}/src/Console.cpp
35:     ${CMAKE_CURRENT_SOURCE_DIR}/src/ExceptionHandler.cpp
36:     ${CMAKE_CURRENT_SOURCE_DIR}/src/ExceptionStub.S
37:     ${CMAKE_CURRENT_SOURCE_DIR}/src/Format.cpp
38:     ${CMAKE_CURRENT_SOURCE_DIR}/src/GPIOManager.cpp
39:     ${CMAKE_CURRENT_SOURCE_DIR}/src/HeapAllocator.cpp
40:     ${CMAKE_CURRENT_SOURCE_DIR}/src/I2CMaster.cpp
41:     ${CMAKE_CURRENT_SOURCE_DIR}/src/InterruptHandler.cpp
42:     ${CMAKE_CURRENT_SOURCE_DIR}/src/Interrupts.cpp
43:     ${CMAKE_CURRENT_SOURCE_DIR}/src/Logger.cpp
44:     ${CMAKE_CURRENT_SOURCE_DIR}/src/Mailbox.cpp
45:     ${CMAKE_CURRENT_SOURCE_DIR}/src/MachineInfo.cpp
46:     ${CMAKE_CURRENT_SOURCE_DIR}/src/Malloc.cpp
47:     ${CMAKE_CURRENT_SOURCE_DIR}/src/MemoryAccess.cpp
48:     ${CMAKE_CURRENT_SOURCE_DIR}/src/MemoryManager.cpp
49:     ${CMAKE_CURRENT_SOURCE_DIR}/src/New.cpp
50:     ${CMAKE_CURRENT_SOURCE_DIR}/src/PhysicalGPIOPin.cpp
51:     ${CMAKE_CURRENT_SOURCE_DIR}/src/RPIProperties.cpp
52:     ${CMAKE_CURRENT_SOURCE_DIR}/src/RPIPropertiesInterface.cpp
53:     ${CMAKE_CURRENT_SOURCE_DIR}/src/Serialization.cpp
54:     ${CMAKE_CURRENT_SOURCE_DIR}/src/Startup.S
55:     ${CMAKE_CURRENT_SOURCE_DIR}/src/String.cpp
56:     ${CMAKE_CURRENT_SOURCE_DIR}/src/System.cpp
57:     ${CMAKE_CURRENT_SOURCE_DIR}/src/Timer.cpp
58:     ${CMAKE_CURRENT_SOURCE_DIR}/src/UART0.cpp
59:     ${CMAKE_CURRENT_SOURCE_DIR}/src/UART1.cpp
60:     ${CMAKE_CURRENT_SOURCE_DIR}/src/Version.cpp
61:     )
62: 
63: set(PROJECT_INCLUDES_PUBLIC
64:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/stubs/MemoryAccessStubGPIO.h
65:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/stubs/MemoryAccessStubI2C.h
66:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/ARMInstructions.h
67:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/ARMRegisters.h
68:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/Assert.h
69:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/BCMRegisters.h
70:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/CharDevice.h
71:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/Console.h
72:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/Exception.h
73:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/ExceptionHandler.h
74:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/Format.h
75:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/GPIOManager.h
76:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/HeapAllocator.h
77:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/I2CMaster.h
78:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/IGPIOManager.h
79:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/IGPIOPin.h
80:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/IMailbox.h
81:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/IMemoryAccess.h
82:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/InterruptHandler.h
83:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/Interrupts.h
84:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/Iterator.h
85:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/Logger.h
86:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/MachineInfo.h
87:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/Mailbox.h
88:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/Malloc.h
89:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/MemoryAccess.h
90:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/MemoryManager.h
91:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/MemoryMap.h
92:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/New.h
93:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/PhysicalGPIOPin.h
94:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/RPIProperties.h
95:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/RPIPropertiesInterface.h
96:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/Serialization.h
97:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/String.h
98:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/Synchronization.h
99:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/SysConfig.h
100:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/System.h
101:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/Timer.h
102:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/UART0.h
103:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/UART1.h
104:     ${CMAKE_CURRENT_SOURCE_DIR}/include/baremetal/Version.h
105:     )
106: set(PROJECT_INCLUDES_PRIVATE )
```

### Configuring, building and debugging : Use I2C stub {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_CONFIGURING_BUILDING_AND_DEBUGGING__USE_I2C_STUB}

We can now configure and build our code, and test.
Notice that the setup of the GPIO pins is logged by the stub.

```text
1: Info   0.00:00:00.000 Baremetal 0.0.1 started on Raspberry Pi 4 Model B (AArch64) using BCM2711 SoC (Logger:96)
2: Info   0.00:00:00.010 Starting up (System:209)
3: Info   0.00:00:00.020 Initialize bus 1, mode 0, config 0 (I2CMaster:175)
4: Debug  0.00:00:00.050 GPIO Read Pin Pull Up/Down Mode  - Pin 0 Pull up/down mode PullUp - Pin 1 Pull up/down mode PullUp - Pin 2 Pull up/down mode PullUp - Pin 3 Pull up/down mode PullUp - Pin 4 Pull up/down mode PullUp - Pin 5 Pull up/down mode PullUp - Pin 6 Pull up/down mode PullUp - Pin 7 Pull up/down mode PullUp - Pin 8 Pull up/down mode PullUp - Pin 9 Pull up/down mode PullDown - Pin 10 Pull up/down mode PullDown - Pin 11 Pull up/down mode PullDown - Pin 12 Pull up/down mode PullDown - Pin 13 Pull up/down mode PullDown - Pin 14 Pull up/down mode PullDown - Pin 15 Pull up/down mode PullDown (MemoryAccessStubGPIO:404)
5: Debug  0.00:00:00.080 GPIO Set Pin 2 Pull Up/Down Mode None (MemoryAccessStubGPIO:677)
6: Debug  0.00:00:00.080 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Input - Pin 3 mode Input - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO:211)
7: Debug  0.00:00:00.100 GPIO Set Pin 2 Mode Alt0 (MemoryAccessStubGPIO:444)
8: Debug  0.00:00:00.110 GPIO Read Pin Pull Up/Down Mode  - Pin 0 Pull up/down mode PullUp - Pin 1 Pull up/down mode PullUp - Pin 2 Pull up/down mode None - Pin 3 Pull up/down mode PullUp - Pin 4 Pull up/down mode PullUp - Pin 5 Pull up/down mode PullUp - Pin 6 Pull up/down mode PullUp - Pin 7 Pull up/down mode PullUp - Pin 8 Pull up/down mode PullUp - Pin 9 Pull up/down mode PullDown - Pin 10 Pull up/down mode PullDown - Pin 11 Pull up/down mode PullDown - Pin 12 Pull up/down mode PullDown - Pin 13 Pull up/down mode PullDown - Pin 14 Pull up/down mode PullDown - Pin 15 Pull up/down mode PullDown (MemoryAccessStubGPIO:404)
9: Debug  0.00:00:00.140 GPIO Set Pin 3 Pull Up/Down Mode None (MemoryAccessStubGPIO:677)
10: Debug  0.00:00:00.140 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Alt0 - Pin 3 mode Input - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO:211)
11: Debug  0.00:00:00.150 GPIO Set Pin 3 Mode Alt0 (MemoryAccessStubGPIO:444)
12: Debug  0.00:00:00.160 I2C Write register 0000000000000014 = 00000DAC (MemoryAccessStubI2C:321)
13: Debug  0.00:00:00.170 I2C Set Clock Divider 3500 (MemoryAccessStubI2C:402)
14: Info   0.00:00:00.170 Set clock 100000 (I2CMaster:218)
15: Info   0.00:00:00.180 Set up bus 1, config 0, base address FE804000 (I2CMaster:201)
16: Debug  0.00:00:00.200 I2C Write register 000000000000000C = 00000020 (MemoryAccessStubI2C:321)
17: Debug  0.00:00:00.210 I2C Set Address 20 (MemoryAccessStubI2C:388)
18: Info   0.00:00:00.210 Write I2C Address, 20 (I2CMaster:641)
19: Debug  0.00:00:00.220 I2C Read register 0000000000000000 = 00000000 (MemoryAccessStubI2C:184)
20: Debug  0.00:00:00.220 I2C Read Control Register Enable OFF RX Interrupt OFF TX Interrupt OFF DONE Interrupt OFF Write  (MemoryAccessStubI2C:210)
21: Info   0.00:00:00.230 Read I2C Control,              WR  (I2CMaster:584)
22: Debug  0.00:00:00.230 I2C Write register 0000000000000000 = 00000030 (MemoryAccessStubI2C:321)
23: Debug  0.00:00:00.240 I2C Clear FIFO (MemoryAccessStubI2C:363)
24: Info   0.00:00:00.240 Write I2C Control,            CL WR  (I2CMaster:605)
25: Debug  0.00:00:00.250 I2C Write register 0000000000000004 = 00000302 (MemoryAccessStubI2C:321)
26: Debug  0.00:00:00.260 I2C Reset Clock Stretch Timeout (MemoryAccessStubI2C:372)
27: Debug  0.00:00:00.260 I2C Reset Ack Error (MemoryAccessStubI2C:374)
28: Debug  0.00:00:00.270 I2C Reset Done (MemoryAccessStubI2C:376)
29: Info   0.00:00:00.270 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
30: Debug  0.00:00:00.280 I2C Write register 0000000000000008 = 00000001 (MemoryAccessStubI2C:321)
31: Debug  0.00:00:00.280 I2C Set Data Length 1 (MemoryAccessStubI2C:382)
32: Info   0.00:00:00.290 Write I2C Length, 00000001 (I2CMaster:653)
33: Debug  0.00:00:00.290 I2C Read register 0000000000000000 = 00000000 (MemoryAccessStubI2C:184)
34: Debug  0.00:00:00.300 I2C Read Control Register Enable OFF RX Interrupt OFF TX Interrupt OFF DONE Interrupt OFF Write  (MemoryAccessStubI2C:210)
35: Info   0.00:00:00.310 Read I2C Control,              WR  (I2CMaster:584)
36: Debug  0.00:00:00.310 I2C Write register 0000000000000000 = 00008081 (MemoryAccessStubI2C:321)
37: Debug  0.00:00:00.320 I2C Enable Controller (MemoryAccessStubI2C:330)
38: Debug  0.00:00:00.320 I2C Read Mode (MemoryAccessStubI2C:358)
39: Debug  0.00:00:00.320 I2C Start Transfer (MemoryAccessStubI2C:365)
40: Info   0.00:00:00.330 I2C Write address 20 (main:15)
41: Info   0.00:00:00.330 I2C Read data 00 (main:22)
42: Info   0.00:00:00.340 Write I2C Control, EN       ST   RD  (I2CMaster:605)
43: Debug  0.00:00:00.340 I2C Read register 0000000000000004 = 00000152 (MemoryAccessStubI2C:184)
44: Debug  0.00:00:00.350 I2C Read Status Register      NACK     TXE     TXD         DONE     (MemoryAccessStubI2C:256)
45: Info   0.00:00:00.360 Read I2C Status,      ERR     TXE     TXD         DONE       (I2CMaster:676)
46: Debug  0.00:00:00.370 I2C Read register 0000000000000004 = 00000152 (MemoryAccessStubI2C:184)
47: Debug  0.00:00:00.370 I2C Read Status Register      NACK     TXE     TXD         DONE     (MemoryAccessStubI2C:256)
48: Info   0.00:00:00.380 Read I2C Status,      ERR     TXE     TXD         DONE       (I2CMaster:676)
49: Info   0.00:00:00.390 Read result = 0 (I2CMaster:305)
50: Debug  0.00:00:00.400 I2C Read register 0000000000000004 = 00000152 (MemoryAccessStubI2C:184)
51: Debug  0.00:00:00.410 I2C Read Status Register      NACK     TXE     TXD         DONE     (MemoryAccessStubI2C:256)
52: Info   0.00:00:00.410 Read I2C Status,      ERR     TXE     TXD         DONE       (I2CMaster:676)
53: Debug  0.00:00:00.420 I2C Write register 0000000000000004 = 00000100 (MemoryAccessStubI2C:321)
54: Debug  0.00:00:00.430 I2C Reset Ack Error (MemoryAccessStubI2C:374)
55: Info   0.00:00:00.430 Write I2C Status,      ERR       (I2CMaster:693)
56: Debug  0.00:00:00.440 I2C Write register 0000000000000004 = 00000002 (MemoryAccessStubI2C:321)
57: Debug  0.00:00:00.450 I2C Reset Done (MemoryAccessStubI2C:376)
58: Info   0.00:00:00.450 Write I2C Status,          DONE  (I2CMaster:693)
59: Info   0.00:00:00.460 On bus 1 Address 20 there is no device (main:57)
60: Info   0.00:00:00.470 Rebooting (main:60)
61: Debug  0.00:00:00.490 GPIO Read Pin Pull Up/Down Mode  - Pin 0 Pull up/down mode PullUp - Pin 1 Pull up/down mode PullUp - Pin 2 Pull up/down mode None - Pin 3 Pull up/down mode None - Pin 4 Pull up/down mode PullUp - Pin 5 Pull up/down mode PullUp - Pin 6 Pull up/down mode PullUp - Pin 7 Pull up/down mode PullUp - Pin 8 Pull up/down mode PullUp - Pin 9 Pull up/down mode PullDown - Pin 10 Pull up/down mode PullDown - Pin 11 Pull up/down mode PullDown - Pin 12 Pull up/down mode PullDown - Pin 13 Pull up/down mode PullDown - Pin 14 Pull up/down mode PullDown - Pin 15 Pull up/down mode PullDown (MemoryAccessStubGPIO:404)
62: Debug  0.00:00:00.520 GPIO Set Pin 2 Pull Up/Down Mode PullUp (MemoryAccessStubGPIO:677)
63: Debug  0.00:00:00.520 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Alt0 - Pin 3 mode Alt0 - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO:211)
64: Debug  0.00:00:00.530 GPIO Set Pin 2 Mode Input (MemoryAccessStubGPIO:444)
65: Debug  0.00:00:00.540 GPIO Read Pin Pull Up/Down Mode  - Pin 0 Pull up/down mode PullUp - Pin 1 Pull up/down mode PullUp - Pin 2 Pull up/down mode PullUp - Pin 3 Pull up/down mode None - Pin 4 Pull up/down mode PullUp - Pin 5 Pull up/down mode PullUp - Pin 6 Pull up/down mode PullUp - Pin 7 Pull up/down mode PullUp - Pin 8 Pull up/down mode PullUp - Pin 9 Pull up/down mode PullDown - Pin 10 Pull up/down mode PullDown - Pin 11 Pull up/down mode PullDown - Pin 12 Pull up/down mode PullDown - Pin 13 Pull up/down mode PullDown - Pin 14 Pull up/down mode PullDown - Pin 15 Pull up/down mode PullDown (MemoryAccessStubGPIO:404)
66: Debug  0.00:00:00.560 GPIO Set Pin 3 Pull Up/Down Mode PullUp (MemoryAccessStubGPIO:677)
67: Debug  0.00:00:00.570 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Input - Pin 3 mode Alt0 - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO:211)
68: Debug  0.00:00:00.580 GPIO Set Pin 3 Mode Input (MemoryAccessStubGPIO:444)
69: Info   0.00:00:00.580 Reboot (System:154)
70: Info   0.00:00:00.580 InterruptSystem::Shutdown (InterruptHandler:153)
71: Debug  0.00:00:00.590 InterruptSystem::DisableInterrupts (InterruptHandler:166)
```

- Line 4-7: The GPIO pin 2 (SCL for bus 1) is configured for mode Alt0 (alternate function 0) and pull up/down is switched off
- Line 8-11: The GPIO pin 3 (SDA for bus 1) is configured for mode Alt0 (alternate function 0) and pull up/down is switched off
- Line 12-14: The I2C clock is set to 100 KHz (the clock divider is set to 3500)
- Line 15: The I2C master is set up for bus 1
- Line 16-18: The address (0x20) is written to the address register
- Line 19-24: The control register is first read, then written.
Notice the read value shows the mode is write, and on write the FIFO clear bits are set.
These bits are however not actually written to the Control Register.
Net result is that we clear the FIFO
- Line 25-29: The status register is written to reset the clock stretch timeout flas, the ack error flag, and the done flag
- Line 30-32: The data length register is written (1 byte to be received)
- Line 33-39: The control register is written to set the enable bit, the start bit, and the read bit.
This will start the transfer for reading
  - Line 40: As a result the address byte is sent, calling the callback `WriteI2CAddress()`.
This returns false
  - Line 41: The the first data byte is read, calling the callback `ReadI2CData()`.
This returns false
  - Line 42: The actual data is written to the Control Register
- Line 43-52: The status register is read a couple of times, returning clock stretch timeout, ack error and done flags.
As you can see the ERR flag is set, as well as the DONE flag
- Line 53-55: The status register is written to reset the ERR flag
- Line 56-58: The status register is written to reset the DONE flag
- Line 59: The conclusion is there is no device at the specified address
- Line 61-64: GPIO pin 2 is set to input mode with pull up
- Line 65-68: GPIO pin 3 is set to input mode with pull up

### Update application code - The positive scenario {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_UPDATE_APPLICATION_CODE___THE_POSITIVE_SCENARIO}

Now let's change the code to give a positive result.

Update the file code/applications/demo/src/main.cpp.

```cpp
File: code/applications/demo/src/main.cpp
...
13: bool WriteI2CAddress(I2CRegisters& registers, uint8 address)
14: {
15:     LOG_INFO("I2C Write address %02x", address);
16:     return address == 0x20;
17: }
18: 
19: bool ReadI2CData(I2CRegisters& registers, uint8& data)
20: {
21:     data = {};
22:     LOG_INFO("I2C Read data %02x", data);
23:     return true;
24: }
...
```

- Line 13-17: We change the callback for writing the I2C address.
This will succeed if we write to the correct I2C address
- Line 19-24: We define a callback for reading data from a I2C device.
This will now succeed

### Configuring, building and debugging - The positive scenario {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_CONFIGURING_BUILDING_AND_DEBUGGING___THE_POSITIVE_SCENARIO}

See that the result is now positive, a device is found.

```text
1: Info   0.00:00:00.000 Baremetal 0.0.1 started on Raspberry Pi 4 Model B (AArch64) using BCM2711 SoC (Logger:96)
2: Info   0.00:00:00.010 Starting up (System:209)
3: Info   0.00:00:00.020 Initialize bus 1, mode 0, config 0 (I2CMaster:175)
4: Debug  0.00:00:00.020 GPIO Read Pin Pull Up/Down Mode  - Pin 0 Pull up/down mode PullUp - Pin 1 Pull up/down mode PullUp - Pin 2 Pull up/down mode PullUp - Pin 3 Pull up/down mode PullUp - Pin 4 Pull up/down mode PullUp - Pin 5 Pull up/down mode PullUp - Pin 6 Pull up/down mode PullUp - Pin 7 Pull up/down mode PullUp - Pin 8 Pull up/down mode PullUp - Pin 9 Pull up/down mode PullDown - Pin 10 Pull up/down mode PullDown - Pin 11 Pull up/down mode PullDown - Pin 12 Pull up/down mode PullDown - Pin 13 Pull up/down mode PullDown - Pin 14 Pull up/down mode PullDown - Pin 15 Pull up/down mode PullDown (MemoryAccessStubGPIO:404)
5: Debug  0.00:00:00.050 GPIO Set Pin 2 Pull Up/Down Mode None (MemoryAccessStubGPIO:677)
6: Debug  0.00:00:00.050 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Input - Pin 3 mode Input - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO:211)
7: Debug  0.00:00:00.070 GPIO Set Pin 2 Mode Alt0 (MemoryAccessStubGPIO:444)
8: Debug  0.00:00:00.070 GPIO Read Pin Pull Up/Down Mode  - Pin 0 Pull up/down mode PullUp - Pin 1 Pull up/down mode PullUp - Pin 2 Pull up/down mode None - Pin 3 Pull up/down mode PullUp - Pin 4 Pull up/down mode PullUp - Pin 5 Pull up/down mode PullUp - Pin 6 Pull up/down mode PullUp - Pin 7 Pull up/down mode PullUp - Pin 8 Pull up/down mode PullUp - Pin 9 Pull up/down mode PullDown - Pin 10 Pull up/down mode PullDown - Pin 11 Pull up/down mode PullDown - Pin 12 Pull up/down mode PullDown - Pin 13 Pull up/down mode PullDown - Pin 14 Pull up/down mode PullDown - Pin 15 Pull up/down mode PullDown (MemoryAccessStubGPIO:404)
9: Debug  0.00:00:00.090 GPIO Set Pin 3 Pull Up/Down Mode None (MemoryAccessStubGPIO:677)
10: Debug  0.00:00:00.100 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Alt0 - Pin 3 mode Input - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO:211)
11: Debug  0.00:00:00.110 GPIO Set Pin 3 Mode Alt0 (MemoryAccessStubGPIO:444)
12: Debug  0.00:00:00.110 I2C Write register 0000000000000014 = 00000DAC (MemoryAccessStubI2C:321)
13: Debug  0.00:00:00.120 I2C Set Clock Divider 3500 (MemoryAccessStubI2C:402)
14: Info   0.00:00:00.120 Set clock 100000 (I2CMaster:218)
15: Info   0.00:00:00.120 Set up bus 1, config 0, base address FE804000 (I2CMaster:201)
16: Debug  0.00:00:00.130 I2C Write register 000000000000000C = 00000020 (MemoryAccessStubI2C:321)
17: Debug  0.00:00:00.130 I2C Set Address 20 (MemoryAccessStubI2C:388)
18: Info   0.00:00:00.130 Write I2C Address, 20 (I2CMaster:641)
19: Debug  0.00:00:00.140 I2C Read register 0000000000000000 = 00000000 (MemoryAccessStubI2C:184)
20: Debug  0.00:00:00.140 I2C Read Control Register Enable OFF RX Interrupt OFF TX Interrupt OFF DONE Interrupt OFF Write  (MemoryAccessStubI2C:210)
21: Info   0.00:00:00.150 Read I2C Control,              WR  (I2CMaster:584)
22: Debug  0.00:00:00.150 I2C Write register 0000000000000000 = 00000030 (MemoryAccessStubI2C:321)
23: Debug  0.00:00:00.150 I2C Clear FIFO (MemoryAccessStubI2C:363)
24: Info   0.00:00:00.160 Write I2C Control,            CL WR  (I2CMaster:605)
25: Debug  0.00:00:00.160 I2C Write register 0000000000000004 = 00000302 (MemoryAccessStubI2C:321)
26: Debug  0.00:00:00.170 I2C Reset Clock Stretch Timeout (MemoryAccessStubI2C:372)
27: Debug  0.00:00:00.170 I2C Reset Ack Error (MemoryAccessStubI2C:374)
28: Debug  0.00:00:00.170 I2C Reset Done (MemoryAccessStubI2C:376)
29: Info   0.00:00:00.170 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
30: Debug  0.00:00:00.180 I2C Write register 0000000000000008 = 00000001 (MemoryAccessStubI2C:321)
31: Debug  0.00:00:00.180 I2C Set Data Length 1 (MemoryAccessStubI2C:382)
32: Info   0.00:00:00.180 Write I2C Length, 00000001 (I2CMaster:653)
33: Debug  0.00:00:00.190 I2C Read register 0000000000000000 = 00000000 (MemoryAccessStubI2C:184)
34: Debug  0.00:00:00.190 I2C Read Control Register Enable OFF RX Interrupt OFF TX Interrupt OFF DONE Interrupt OFF Write  (MemoryAccessStubI2C:210)
35: Info   0.00:00:00.200 Read I2C Control,              WR  (I2CMaster:584)
36: Debug  0.00:00:00.200 I2C Write register 0000000000000000 = 00008081 (MemoryAccessStubI2C:321)
37: Debug  0.00:00:00.200 I2C Enable Controller (MemoryAccessStubI2C:330)
38: Debug  0.00:00:00.210 I2C Read Mode (MemoryAccessStubI2C:358)
39: Debug  0.00:00:00.210 I2C Start Transfer (MemoryAccessStubI2C:365)
40: Info   0.00:00:00.210 I2C Write address 20 (main:15)
41: Info   0.00:00:00.220 I2C Read data 00 (main:22)
42: Info   0.00:00:00.220 Write I2C Control, EN       ST   RD  (I2CMaster:605)
43: Debug  0.00:00:00.220 I2C Read register 0000000000000004 = 00000066 (MemoryAccessStubI2C:184)
44: Debug  0.00:00:00.230 I2C Read Status Register      ACK      TXE RXD         TXW DONE     (MemoryAccessStubI2C:256)
45: Info   0.00:00:00.230 Read I2C Status,              TXE RXD         TXW DONE       (I2CMaster:676)
46: Debug  0.00:00:00.240 I2C Read register 0000000000000004 = 00000066 (MemoryAccessStubI2C:184)
47: Debug  0.00:00:00.240 I2C Read Status Register      ACK      TXE RXD         TXW DONE     (MemoryAccessStubI2C:256)
48: Info   0.00:00:00.250 Read I2C Status,              TXE RXD         TXW DONE       (I2CMaster:676)
49: Debug  0.00:00:00.250 I2C Read register 0000000000000010 = 00000000 (MemoryAccessStubI2C:184)
50: Debug  0.00:00:00.250 I2C Read FIFO 00 (MemoryAccessStubI2C:271)
51: Info   0.00:00:00.260 Read FIFO, data 00000000 (I2CMaster:836)
52: Info   0.00:00:00.260 Read result = 1 (I2CMaster:305)
53: Debug  0.00:00:00.260 I2C Read register 0000000000000004 = 0000004E (MemoryAccessStubI2C:184)
54: Debug  0.00:00:00.270 I2C Read Status Register      ACK      TXE         RXR TXW DONE     (MemoryAccessStubI2C:256)
55: Info   0.00:00:00.270 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
56: Debug  0.00:00:00.280 I2C Write register 0000000000000004 = 00000002 (MemoryAccessStubI2C:321)
57: Debug  0.00:00:00.280 I2C Reset Done (MemoryAccessStubI2C:376)
58: Info   0.00:00:00.290 Write I2C Status,          DONE  (I2CMaster:693)
59: Info   0.00:00:00.290 On bus 1 Address 20 there is a device (main:53)
60: Info   0.00:00:00.290 Rebooting (main:60)
61: Debug  0.00:00:00.290 GPIO Read Pin Pull Up/Down Mode  - Pin 0 Pull up/down mode PullUp - Pin 1 Pull up/down mode PullUp - Pin 2 Pull up/down mode None - Pin 3 Pull up/down mode None - Pin 4 Pull up/down mode PullUp - Pin 5 Pull up/down mode PullUp - Pin 6 Pull up/down mode PullUp - Pin 7 Pull up/down mode PullUp - Pin 8 Pull up/down mode PullUp - Pin 9 Pull up/down mode PullDown - Pin 10 Pull up/down mode PullDown - Pin 11 Pull up/down mode PullDown - Pin 12 Pull up/down mode PullDown - Pin 13 Pull up/down mode PullDown - Pin 14 Pull up/down mode PullDown - Pin 15 Pull up/down mode PullDown (MemoryAccessStubGPIO:404)
62: Debug  0.00:00:00.320 GPIO Set Pin 2 Pull Up/Down Mode PullUp (MemoryAccessStubGPIO:677)
63: Debug  0.00:00:00.320 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Alt0 - Pin 3 mode Alt0 - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO:211)
64: Debug  0.00:00:00.330 GPIO Set Pin 2 Mode Input (MemoryAccessStubGPIO:444)
65: Debug  0.00:00:00.340 GPIO Read Pin Pull Up/Down Mode  - Pin 0 Pull up/down mode PullUp - Pin 1 Pull up/down mode PullUp - Pin 2 Pull up/down mode PullUp - Pin 3 Pull up/down mode None - Pin 4 Pull up/down mode PullUp - Pin 5 Pull up/down mode PullUp - Pin 6 Pull up/down mode PullUp - Pin 7 Pull up/down mode PullUp - Pin 8 Pull up/down mode PullUp - Pin 9 Pull up/down mode PullDown - Pin 10 Pull up/down mode PullDown - Pin 11 Pull up/down mode PullDown - Pin 12 Pull up/down mode PullDown - Pin 13 Pull up/down mode PullDown - Pin 14 Pull up/down mode PullDown - Pin 15 Pull up/down mode PullDown (MemoryAccessStubGPIO:404)
66: Debug  0.00:00:00.360 GPIO Set Pin 3 Pull Up/Down Mode PullUp (MemoryAccessStubGPIO:677)
67: Debug  0.00:00:00.360 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Input - Pin 3 mode Alt0 - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO:211)
68: Debug  0.00:00:00.370 GPIO Set Pin 3 Mode Input (MemoryAccessStubGPIO:444)
69: Info   0.00:00:00.380 Reboot (System:154)
70: Info   0.00:00:00.380 InterruptSystem::Shutdown (InterruptHandler:153)
71: Debug  0.00:00:00.380 InterruptSystem::DisableInterrupts (InterruptHandler:166)
```

- Line 40: The address is written
- Line 41: A byte is being read from the device
- Line 42-44: The read transaction is started (actually the byte was already read above)
- Line 43-50: The Status Register is read multiple times again, the DONE bit is set, but the ERR bit is not
- Line 51-52: The byte is read from the FIFO, and the result is therefore 1 (1 byte is read)
- Line 53-55: The Status Register is read again
- Line 56-58: The DONE bit is reset
- Line 59: The conclusion is that there is a device at the address specified

### MemoryAccessStubGPIO.cpp {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_MEMORYACCESSSTUBGPIOCPP}

Let's get rid of the large amount of tracing in the GPIO and I2C stubs.
We'll use the same mechanism as we did in `I2CMaster.cpp`.

Update file `code/libraries/baremetal/src/stubs/MemoryAccessStubGPIO.cpp`

```cpp
File: code/libraries/baremetal/src/stubs/MemoryAccessStubGPIO.cpp
...
56: /// @brief If defined will trace detailed information on messages send and rece
57: #define TRACE 0
58: 
...
114: #if TRACE
115: /// <summary>
116: /// Convert pin mode to string
117: /// </summary>
118: /// <param name="mode">Pin mode</param>
119: /// <returns>String representing pin mode</returns>
120: static string PinModeToString(uint32 mode)
121: {
122:     string result{};
123:     switch (mode & 0x07)
124:     {
125:     case 0:
126:         result = "Input";
127:         break;
128:     case 1:
129:         result = "Output";
130:         break;
131:     case 2:
132:         result = "Alt5";
133:         break;
134:     case 3:
135:         result = "Alt4";
136:         break;
137:     case 4:
138:         result = "Alt0";
139:         break;
140:     case 5:
141:         result = "Alt1";
142:         break;
143:     case 6:
144:         result = "Alt2";
145:         break;
146:     case 7:
147:         result = "Alt3";
148:         break;
149:     }
150:     return result;
151: }
152: 
153: /// <summary>
154: /// Convert pull up/down mode to string
155: /// </summary>
156: /// <param name="mode">Pull up/down mode</param>
157: /// <returns>String representing pull up/down mode</returns>
158: static string PullUpDownModeToString(uint32 mode)
159: {
160:     string result{};
161:     switch (mode & 0x03)
162:     {
163:     case 0:
164:         result = "None";
165:         break;
166:     case 1:
167: #if BAREMETAL_RPI_TARGET == 3
168:         result = "PullDown";
169: #else
170:         result = "PullUp";
171: #endif
172:         break;
173:     case 2:
174: #if BAREMETAL_RPI_TARGET == 3
175:         result = "PullUp";
176: #else
177:         result = "PullDown";
178: #endif
179:         break;
180:     case 3:
181:         result = "Reserved";
182:         break;
183:     }
184:     return result;
185: }
186: #endif
187: 
...
193: uint32 MemoryAccessStubGPIO::Read32(regaddr address)
194: {
195:     uintptr offset = GetRegisterOffset(address);
196:     uint32* registerField = reinterpret_cast<uint32*>(reinterpret_cast<uint8*>(&m_registers) + offset);
197: #if TRACE
198:     LOG_DEBUG("GPIO read register %016x = %08x", offset, *registerField);
...
418: #endif
419:     return *registerField;
420: }
...
427: void MemoryAccessStubGPIO::Write32(regaddr address, uint32 data)
428: {
429:     uintptr offset = GetRegisterOffset(address);
430:     uint32* registerField = reinterpret_cast<uint32*>(reinterpret_cast<uint8*>(&m_registers) + offset);
431: #if TRACE
...
695: #endif
696:     *registerField = data;
697: }
...
```

- Line 56-57: We add a definition `TRACE` which we set to 0 to disable tracing
- Line 114-186: We place the functions `PinModeToString()` and `PullUpDownModeToString()` inside an `#ifdef`
- Line 197-418: We place the contents of the `Read32()` method largely inside an `#ifdef`
- Line 431-695: We place the contents of the `Write32()` method largely inside an `#ifdef`

### Update MemoryAccessStubI2C.cpp {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_UPDATE_MEMORYACCESSSTUBI2CCPP}

Update file `code/libraries/baremetal/src/stubs/MemoryAccessStubI2C.cpp`

```cpp
File: code/libraries/baremetal/src/stubs/MemoryAccessStubI2C.cpp
...
56: /// @brief If defined will trace detailed information on messages send and rece
57: #define TRACE 0
58: 
...
177: uint32 MemoryAccessStubI2C::Read32(regaddr address)
178: {
179:     uintptr addr = reinterpret_cast<uintptr>(address);
180:     if ((addr >= RPI_GPIO_BASE) && (addr < RPI_GPIO_END))
181:     {
182:         return MemoryAccessStubGPIO::Read32(address);
183:     }
184: 
185:     uintptr offset = GetRegisterOffset(address);
186:     uint32 *registerField = reinterpret_cast<uint32 *>(reinterpret_cast<uint8 *>(&m_registers) + offset);
187: #if TRACE
188:     LOG_DEBUG("I2C Read register %016x = %08x", offset, *registerField);
189: #endif
190:     switch (offset)
191:     {
192:         case RPI_I2C_C_OFFSET:
193:         {
194: #if TRACE
195:             string line{ "I2C Read Control Register "};
196:             if (*registerField & RPI_I2C_C_ENABLE)
197:                 line += "Enable ON  ";
198:             else
199:                 line += "Enable OFF ";
200:             if (*registerField & RPI_I2C_C_INTR_ENABLE)
201:                 line += "RX Interrupt ON  ";
202:             else
203:                 line += "RX Interrupt OFF ";
204:             if (*registerField & RPI_I2C_C_INTT_ENABLE)
205:                 line += "TX Interrupt ON  ";
206:             else
207:                 line += "TX Interrupt OFF ";
208:             if (*registerField & RPI_I2C_C_INTD_ENABLE)
209:                 line += "DONE Interrupt ON  ";
210:             else
211:                 line += "DONE Interrupt OFF ";
212:             if (*registerField & RPI_I2C_C_READ)
213:                 line += "Read ";
214:             else
215:                 line += "Write ";
216:             LOG_DEBUG(line.c_str());
217: #endif
218:             break;
219:         }
220:         case RPI_I2C_S_OFFSET:
221:         {
222: #if TRACE
223:             string line{ "I2C Read Status Register "};
224:             if (*registerField & RPI_I2C_S_CLKT)
225:                 line += "CLKT ";
226:             else
227:                 line += "     ";
228:             if (*registerField & RPI_I2C_S_ERR)
229:                 line += "NACK ";
230:             else
231:                 line += "ACK  ";
232:             if (*registerField & RPI_I2C_S_RXF)
233:                 line += "RXF ";
234:             else
235:                 line += "    ";
236:             if (*registerField & RPI_I2C_S_TXE)
237:                 line += "TXE ";
238:             else
239:                 line += "    ";
240:             if (*registerField & RPI_I2C_S_RXD)
241:                 line += "RXD ";
242:             else
243:                 line += "    ";
244:             if (*registerField & RPI_I2C_S_TXD)
245:                 line += "TXD ";
246:             else
247:                 line += "    ";
248:             if (*registerField & RPI_I2C_S_RXR)
249:                 line += "RXR ";
250:             else
251:                 line += "    ";
252:             if (*registerField & RPI_I2C_S_TXW)
253:                 line += "TXW ";
254:             else
255:                 line += "    ";
256:             if (*registerField & RPI_I2C_S_DONE)
257:                 line += "DONE ";
258:             else
259:                 line += "     ";
260:             if (*registerField & RPI_I2C_S_TA)
261:                 line += "TA ";
262:             else
263:                 line += "   ";
264:             LOG_DEBUG(line.c_str());
265: #endif
266:             break;
267:         }
268:         case RPI_I2C_DLEN_OFFSET:
269:         {
270: #if TRACE
271:             LOG_DEBUG("I2C Get Data Length %d", *registerField);
272: #endif
273:             break;
274:         }
275:         case RPI_I2C_A_OFFSET:
276:         {
277: #if TRACE
278:             LOG_DEBUG("I2C Get Address %02x", *registerField);
279: #endif
280:             break;
281:         }
282:         case RPI_I2C_FIFO_OFFSET:
283:         {
284: #if TRACE
285:             LOG_DEBUG("I2C Read FIFO %02x", *registerField);
286: #endif
287:             *registerField = HandleReadFIFORegister();
288:             break;
289:         }
290:         case RPI_I2C_DIV_OFFSET:
291:         {
292: #if TRACE
293:             LOG_DEBUG("I2C Set Clock Divider %d", *registerField);
294: #endif
295:             break;
296:         }
297:         case RPI_I2C_DEL_OFFSET:
298:         {
299: #if TRACE
300:             if (*registerField & 0xFFFF0000)
301:             {
302:                 LOG_DEBUG("I2C Get Falling Edge Delay %d", (*registerField >> 16));
303:             }
304:             if (*registerField & 0x0000FFFF)
305:             {
306:                 LOG_DEBUG("I2C Get Rising Edge Delay %d", (*registerField & 0x0000FFFF));
307:             }
308: #endif
309:             break;
310:         }
311:         case RPI_I2C_CLKT_OFFSET:
312:         {
313: #if TRACE
314:             LOG_DEBUG("I2C Get Clock Stretch Timeout %d", (*registerField & 0x0000FFFF));
315: #endif
316:             break;
317:         }
318:         default:
319:             LOG_ERROR("Invalid I2C register access for reading: offset %d", offset);
320:             break;
321:     }
322: 
323:     return *registerField;
324: }
325: 
326: /// <summary>
327: /// Write a 32 bit value to register at address
328: /// </summary>
329: /// <param name="address">Address of register</param>
330: /// <param name="data">Data to write</param>
331: void MemoryAccessStubI2C::Write32(regaddr address, uint32 data)
332: {
333:     uintptr addr = reinterpret_cast<uintptr>(address);
334:     if ((addr >= RPI_GPIO_BASE) && (addr < RPI_GPIO_END))
335:     {
336:         MemoryAccessStubGPIO::Write32(address, data);
337:         return;
338:     }
339: 
340:     uintptr offset = GetRegisterOffset(address);
341:     uint32 *registerField = reinterpret_cast<uint32 *>(reinterpret_cast<uint8 *>(&m_registers) + offset);
342: #if TRACE
343:     LOG_DEBUG("I2C Write register %016x = %08x", offset, data);
344: #endif
345:     switch (offset)
346:     {
347:         case RPI_I2C_C_OFFSET:
348:         {
349: #if TRACE
350:             uint32 diff = (data ^ *registerField) | 0x00B0;
351:             if (diff & RPI_I2C_C_ENABLE)
352:             {
353:                 if (data & RPI_I2C_C_ENABLE)
354:                     LOG_DEBUG("I2C Enable Controller");
355:                 else
356:                     LOG_DEBUG("I2C Disable Controller");
357:             }
358:             if (diff & RPI_I2C_C_INTR_ENABLE)
359:             {
360:                 if (data & RPI_I2C_C_INTR_ENABLE)
361:                     LOG_DEBUG("I2C Enable RX Interrupt");
362:                 else
363:                     LOG_DEBUG("I2C Disable RX Interrupt");
364:             }
365:             if (diff & RPI_I2C_C_INTT_ENABLE)
366:             {
367:                 if (data & RPI_I2C_C_INTT_ENABLE)
368:                     LOG_DEBUG("I2C Enable TX Interrupt");
369:                 else
370:                     LOG_DEBUG("I2C Disable TX Interrupt");
371:             }
372:             if (diff & RPI_I2C_C_INTD_ENABLE)
373:             {
374:                 if (data & RPI_I2C_C_INTD_ENABLE)
375:                     LOG_DEBUG("I2C Enable Done Interrupt");
376:                 else
377:                     LOG_DEBUG("I2C Disable Done Interrupt");
378:             }
379:             if (diff & RPI_I2C_C_READ)
380:             {
381:                 if (data & RPI_I2C_C_READ)
382:                     LOG_DEBUG("I2C Read Mode");
383:                 else
384:                     LOG_DEBUG("I2C Write Mode");
385:             }
386:             if (data & RPI_I2C_C_CLEAR)
387:                 LOG_DEBUG("I2C Clear FIFO");
388:             if (data & RPI_I2C_C_ST)
389:                 LOG_DEBUG("I2C Start Transfer");
390: #endif
391:             HandleWriteControlRegister(data);
392:             break;
393:         }
394:         case RPI_I2C_S_OFFSET:
395:         {
396: #if TRACE
397:             if (data & RPI_I2C_S_CLKT)
398:                 LOG_DEBUG("I2C Reset Clock Stretch Timeout");
399:             if (data & RPI_I2C_S_ERR)
400:                 LOG_DEBUG("I2C Reset Ack Error");
401:             if (data & RPI_I2C_S_DONE)
402:                 LOG_DEBUG("I2C Reset Done");
403: #endif
404:             HandleWriteStatusRegister(data);
405:             break;
406:         }
407:         case RPI_I2C_DLEN_OFFSET:
408:         {
409: #if TRACE
410:             LOG_DEBUG("I2C Set Data Length %d", data);
411: #endif
412:             *registerField = data;
413:             break;
414:         }
415:         case RPI_I2C_A_OFFSET:
416:         {
417: #if TRACE
418:             LOG_DEBUG("I2C Set Address %02x", data);
419: #endif
420:             *registerField = data;
421:             break;
422:         }
423:         case RPI_I2C_FIFO_OFFSET:
424:         {
425: #if TRACE
426:             LOG_DEBUG("I2C Write FIFO %02x", data);
427: #endif
428:             HandleWriteFIFORegister(data);
429:             break;
430:         }
431:         case RPI_I2C_DIV_OFFSET:
432:         {
433: #if TRACE
434:             if (data != *registerField)
435:             {
436:                 LOG_DEBUG("I2C Set Clock Divider %d", data);
437:             }
438: #endif
439:             *registerField = data;
440:             break;
441:         }
442:         case RPI_I2C_DEL_OFFSET:
443:         {
444: #if TRACE
445:             uint32 diff = data & *registerField;
446:             if (diff & 0xFFFF0000)
447:             {
448:                 LOG_DEBUG("I2C Set Falling Edge Delay %d", (data >> 16));
449:             }
450:             if (diff & 0x0000FFFF)
451:             {
452:                 LOG_DEBUG("I2C Set Rising Edge Delay %d", (data & 0x0000FFFF));
453:             }
454: #endif
455:             *registerField = data;
456:             break;
457:         }
458:         case RPI_I2C_CLKT_OFFSET:
459:         {
460: #if TRACE
461:             uint32 diff = data & *registerField;
462:             if (diff & 0x0000FFFF)
463:             {
464:                 LOG_DEBUG("I2C Set Clock Stretch Timeout %d", (data & 0x0000FFFF));
465:             }
466: #endif
467:             *registerField = data;
468:             break;
469:         }
470:         default:
471:             LOG_ERROR("Invalid I2C register access for writing: offset %d", offset);
472:             break;
473:     }
474: }
```

- Line 56-57: We add a definition `TRACE` which we set to 0 to disable tracing
- Line 187-189: We place the log message inside an `#ifdef`
- Line 194-217: We place the log message inside an `#ifdef`
- Line 222-265: We place the log message inside an `#ifdef`
- Line 270-272: We place the log message inside an `#ifdef`
- Line 277-279: We place the log message inside an `#ifdef`
- Line 284-286: We place the log message inside an `#ifdef`
- Line 292-294: We place the log message inside an `#ifdef`
- Line 299-308: We place the log message inside an `#ifdef`
- Line 313-315: We place the log message inside an `#ifdef`
- Line 342-344: We place the log message inside an `#ifdef`
- Line 349-390: We place the log message inside an `#ifdef`
- Line 396-403: We place the log message inside an `#ifdef`
- Line 409-411: We place the log message inside an `#ifdef`
- Line 417-419: We place the log message inside an `#ifdef`
- Line 425-427: We place the log message inside an `#ifdef`
- Line 433-438: We place the log message inside an `#ifdef`
- Line 444-454: We place the log message inside an `#ifdef`
- Line 460-466: We place the log message inside an `#ifdef`

### Update application code - actual hardware {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_UPDATE_APPLICATION_CODE___ACTUAL_HARDWARE}

Now let's use actual hardware to do the same thing. I hooked up the hardware as specified in [Actual hardware - MCP23017](#TUTORIAL_21_I2C_ACTUAL_HARDWARE___MCP23017)
We we now simply use the default MemoryAccess instance, which will access the actual hardware.

Update the file code/applications/demo/src/main.cpp.

```cpp
File: code/applications/demo/src/main.cpp
File: d:\Projects\RaspberryPi\baremetal.github\code\applications\demo\src\main.cpp
1: #include <baremetal/Format.h>
2: #include <baremetal/I2CMaster.h>
3: #include <baremetal/Logger.h>
4: #include <baremetal/PhysicalGPIOPin.h>
5: #include <baremetal/String.h>
6: #include <baremetal/System.h>
7: #include <baremetal/Timer.h>
8: 
9: LOG_MODULE("main");
10: 
11: using namespace baremetal;
12: 
13: int main()
14: {
15:     auto& console = GetConsole();
16:     GetLogger().SetLogLevel(LogSeverity::Debug);
17: 
18:     uint8 busIndex = 1;
19:     uint8 address{ 0x20 };
20:     I2CMaster master;
21: 
22:     if (!master.Initialize(busIndex))
23:     {
24:         LOG_ERROR("Cannot scan bus %d", busIndex);
25:     }
26: 
27:     if (master.Scan(address))
28:     {
29:         LOG_INFO("On bus %d Address %02x there is a device", busIndex, address);
30:     }
31:     else
32:     {
33:         LOG_INFO("On bus %d Address %02x there is no device", busIndex, address);
34:     }
35: 
36:     LOG_INFO("Rebooting");
37: 
38:     return static_cast<int>(ReturnCode::ExitReboot);
39: }
40: 
```

- Line 20: We instantiate a I2CMaster device
- Line 22: We initialize the I2CMaster to the I2C bus
- Line 27-34: We scan for address 0x20.
If the scan is successful (the device answers), we print a success message, otherwise we print a failure message.
This should succeed when we have actual hardware connected.

### Configuring, building and debugging - actual hardware {#TUTORIAL_21_I2C_FAKING_IT___STEP_1_CONFIGURING_BUILDING_AND_DEBUGGING___ACTUAL_HARDWARE}

You'll notice that the amount of tracing is a lot less, as we're not using the stub.
The result however is the same, the device is found.

```text
1: Info   0.00:00:00.020 Baremetal 0.0.1 started on Raspberry Pi 4 Model B (AArch64) using BCM2711 SoC (Logger:96)
2: Info   0.00:00:00.050 Starting up (System:209)
3: Info   0.00:00:00.070 Initialize bus 1, mode 0, config 0 (I2CMaster:175)
4: Info   0.00:00:00.080 Set clock 100000 (I2CMaster:218)
5: Info   0.00:00:00.100 Set up bus 1, config 0, base address FE804000 (I2CMaster:201)
6: Info   0.00:00:00.120 Write I2C Address, 20 (I2CMaster:641)
7: Info   0.00:00:00.130 Read I2C Control,              WR  (I2CMaster:584)
8: Info   0.00:00:00.160 Write I2C Control,            CL WR  (I2CMaster:605)
9: Info   0.00:00:00.180 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
10: Info   0.00:00:00.200 Write I2C Length, 00000001 (I2CMaster:653)
11: Info   0.00:00:00.210 Read I2C Control,              WR  (I2CMaster:584)
12: Info   0.00:00:00.230 Write I2C Control, EN       ST   RD  (I2CMaster:605)
13: Info   0.00:00:00.260 Read I2C Status,                  RXD TXD         DONE       (I2CMaster:676)
14: Info   0.00:00:00.280 Read I2C Status,                  RXD TXD         DONE       (I2CMaster:676)
15: Info   0.00:00:00.300 Read FIFO, data 000000FF (I2CMaster:836)
16: Info   0.00:00:00.320 Read result = 1 (I2CMaster:305)
17: Info   0.00:00:00.330 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
18: Info   0.00:00:00.360 Write I2C Status,          DONE  (I2CMaster:693)
19: Info   0.00:00:00.380 On bus 1 Address 20 there is a device (main:29)
20: Info   0.00:00:00.400 Rebooting (main:36)
21: Info   0.00:00:00.420 Reboot (System:154)
22: Info   0.00:00:00.430 InterruptSystem::Shutdown (InterruptHandler:153)
23: Debug  0.00:00:00.450 InterruptSystem::DisableInterrupts (InterruptHandler:166)
```

- Line 3: The I2C master is initialized to bus 1
- Line 4: The clock rate is set to 100KHz
- Line 5: The base address is the address for bus 1
- Line 6: The Address Register is set to 0x20
- Line 7-8: The FIFO is cleared by writing to the Control Register
- Line 9: The The ERR, CLKT and DONE bits are reset by writing to the Status Register
- Line 10: The Data Length Register is set to 1
- Line 11-12: The read transaction is started by writing to the Control Register
- Line 13-14: The Status Register is read multiple times. The DONE bit is set, the ERR bit is not
- Line 15-16: The FIFO Register is read, the result is set to 1
- Line 17-18: The Status Register is read again, and the DONE bit is reset
- Line 19: The conclusion is there is a device at address 0x20

## Using MCP23017 - Step 2 {#TUTORIAL_21_I2C_USING_MCP23017___STEP_2}

Now let's start using the I2C Expander MCP 23017.

### MCP23017.h {#TUTORIAL_21_I2C_USING_MCP23017___STEP_2_MCP23017H}

We'll first declare the class for the MCP 23017 device.
This will be placed in the device library.

Create file `code/libraries/device/include/device/i2c/MCP23017.h`

```cpp
File: code/libraries/device/include/device/i2c/MCP23017.h
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MCP23017.h
5: //
6: // Namespace   : device
7: //
8: // Class       : MCP23017
9: //
10: // Description : I2C Master functionality
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39: 
40: #pragma once
41: 
42: #include <baremetal/I2CMaster.h>
43: 
44: /// @file
45: /// MCP 23017 I2C expander support declaration
46: 
47: namespace device {
48: 
49: /// @brief Select register bank for MCP23017.
50: /// MCP23017 has two register banks, which differ in the relative register numbers
51: #define BANK 0
52: 
53: #if BANK == 0
54: 
55: /// @brief MCP23017 registers when BANK = 0
56: enum MCP23017RegisterIndex {
57:     /// @brief I/O Direction Register Port A
58:     IODIRA = 0,
59:     /// @brief I/O Direction Register Port B
60:     IODIRB = 1,
61:     /// @brief Input Polarity Register Port A
62:     IPOLA = 2,
63:     /// @brief Input Polarity Register Port B
64:     IPOLB = 3,
65:     /// @brief GPIO Interrupt Enable Register Port A
66:     GPINTENA = 4,
67:     /// @brief GPIO Interrupt Enable Register Port B
68:     GPINTENB = 5,
69:     /// @brief Default Compare Register Port A
70:     DEFVALA = 6,
71:     /// @brief Default Compare Register Port B
72:     DEFVALB = 7,
73:     /// @brief Interrupt Control Register Port A
74:     INTCONA = 8,
75:     /// @brief Interrupt Control Register Port B
76:     INTCONB = 9,
77:     /// @brief I/O Control Register Port A
78:     IOCONA = 10,
79:     /// @brief I/O Control Register Port B
80:     IOCONB = 11,
81:     /// @brief GPIO Pull-up Resistor Configuration Register Port A
82:     GPPUA = 12,
83:     /// @brief GPIO Pull-up Resistor Configuration Register Port B
84:     GPPUB = 13,
85:     /// @brief Interrupt Flag Register Port A
86:     INTFA = 14,
87:     /// @brief Interrupt Flag Register Port B
88:     INTFB = 15,
89:     /// @brief Interrupt Captured Register Port A
90:     INTCAPA = 16,
91:     /// @brief Interrupt Captured Register Port B
92:     INTCAPB = 17,
93:     /// @brief GPIO Port Register Port A
94:     GPIOA = 18,
95:     /// @brief GPIO Port Register Port b
96:     GPIOB = 19,
97:     /// @brief Output Latch Register Port A
98:     OLATA = 20,
99:     /// @brief Output Latch Register Port B
100:     OLATB = 21,
101: };
102: 
103: #else
104: 
105: /// @brief MCP23017 registers when BANK = 1
106: enum MCP23017RegisterIndex {
107:     /// @brief I/O Direction Register Port A
108:     IODIRA = 0,
109:     /// @brief I/O Direction Register Port B
110:     IODIRB = 16,
111:     /// @brief Input Polarity Register Port A
112:     IPOLA = 1,
113:     /// @brief Input Polarity Register Port B
114:     IPOLB = 17,
115:     /// @brief GPIO Interrupt Enable Register Port A
116:     GPINTENA = 2,
117:     /// @brief GPIO Interrupt Enable Register Port B
118:     GPINTENB = 18,
119:     /// @brief Default Compare Register Port A
120:     DEFVALA = 3,
121:     /// @brief Default Compare Register Port B
122:     DEFVALB = 19,
123:     /// @brief Interrupt Control Register Port A
124:     INTCONA = 4,
125:     /// @brief Interrupt Control Register Port B
126:     INTCONB = 20,
127:     /// @brief I/O Control Register Port A
128:     IOCONA = 5,
129:     /// @brief I/O Control Register Port B
130:     IOCONB = 21,
131:     /// @brief GPIO Pull-up Resistor Configuration Register Port A
132:     GPPUA = 6,
133:     /// @brief GPIO Pull-up Resistor Configuration Register Port B
134:     GPPUB = 22,
135:     /// @brief Interrupt Flag Register Port A
136:     INTFA = 7,
137:     /// @brief Interrupt Flag Register Port B
138:     INTFB = 23,
139:     /// @brief Interrupt Captured Register Port A
140:     INTCAPA = 8,
141:     /// @brief Interrupt Captured Register Port B
142:     INTCAPB = 24,
143:     /// @brief GPIO Port Register Port A
144:     GPIOA = 9,
145:     /// @brief GPIO Port Register Port b
146:     GPIOB = 25,
147:     /// @brief Output Latch Register Port A
148:     OLATA = 10,
149:     /// @brief Output Latch Register Port B
150:     OLATB = 26,
151: };
152: 
153: #endif
154: 
155: /// @brief IO Configuration Register Bank selection
156: #define IOCON_BANK BIT1(7)
157: /// @brief IO Configuration Register Interrupt A/B mirroring
158: #define IOCON_MIRROR BIT1(6)
159: /// @brief IO Configuration Register sequential operation (automatic register index increment, subsequent write will be to next register)
160: #define IOCON_SEQOP BIT1(5)
161: /// @brief IO Configuration Register SDA slew rate
162: #define IOCON_DISSLW BIT1(4)
163: /// @brief IO Configuration Register Hardware Address Enable (for MCP23S017 only)
164: #define IOCON_HAEN BIT1(3)
165: /// @brief IO Configuration Register Open Drain Interrupt pin
166: #define IOCON_ODR BIT1(2)
167: /// @brief IO Configuration Register Interrupt polarity
168: #define IOCON_INTPOL BIT1(1)
169: 
170: /// @brief MCP23017 pin direction
171: enum class PinDirection
172: {
173:     /// @brief Input pin
174:     In,
175:     /// @brief Output pin
176:     Out,
177: };
178: 
179: /// <summary>
180: /// Driver for MCP23017 I2C expander device
181: ///
182: /// This device is normally on I2C address 20-27 depending on how its A0-A2 pins are connected.
183: /// The device support two 8 bit ports name port A and B.
184: /// Each pin can be either an input or output.
185: /// </summary>
186: class MCP23017
187: {
188: private:
189:     /// @brief I2C base device
190:     baremetal::I2CMaster m_device;
191:     /// @brief I2C device address
192:     uint8 m_address;
193: 
194: public:
195:     MCP23017(baremetal::IMemoryAccess &memoryAccess = baremetal::GetMemoryAccess());
196:     ~MCP23017();
197: 
198:     bool Initialize(uint8 bus, uint8 address);
199: 
200:     uint8 ReadRegister(MCP23017RegisterIndex registerAddress);
201:     void WriteRegister(MCP23017RegisterIndex registerAddress, uint8 byte);
202:     void GetPinDirection(uint8 pinNumber, PinDirection &direction);
203:     void SetPinDirection(uint8 pinNumber, const PinDirection &direction);
204:     bool GetPinValue(uint8 pinNumber);
205:     void SetPinValue(uint8 pinNumber, bool on);
206:     void SetPortADirections(const PinDirection &direction);
207:     uint8 GetPortAValue();
208:     void SetPortAValue(uint8 data);
209:     void SetPortBDirections(const PinDirection &direction);
210:     uint8 GetPortBValue();
211:     void SetPortBValue(uint8 data);
212: };
213: 
214: } // namespace device
```

- Line 51: We add a definition `BANK` which determines how to address registers in the MCP23017.
The default is bank 0, but it is possible to switch to bank 1 for a different register order.
We will add the definitions for both, but not support bank 1 for now.
Refer to [MCP23017/MCP23S17 - 16-Bit I/O Expander with Serial Interface](pdf/mcp23017.pdf) for more information
- Line 55-101: We declare the enum `MCP23017RegisterIndex` which holds all register indexes for the MCP23017 registers for bank 0
- Line 105-151: We declare the enum `MCP23017RegisterIndex` which holds all register indexes for the MCP23017 registers for bank 1
- Line 155-168: We add definitions for the bits in the IOCON registers
- Line 170-177: We add a enum `PinDirection` to define the direction of GPIO pins on the MCP23017
- Line 179-212: We declare the class `MCP23017`
  - Line 189-190: The member variable `m_device` holds the I2CMaster for the device
  - Line 191-192: The member variable `m_address` hold the I2C address for the device
  - Line 195: We declare the constructor
  - Line 196: We declare the destructor
  - Line 198: We declare the method `Initialize()` to initialize the device/
It receives a I2C bus index as well as and I2C address
  - Line 200: We declare a method `ReadRegister()` to read from a register on the device
  - Line 201: We declare a method `WriteRegister()` to write to a register on the device
  - Line 202: We declare a method `GetPinDirection()` to get the direction for a GPIO pin.
Pin numbers from 0-7 refer to port A, pin numbers from 8-15 to port B
  - Line 203: We declare a method `SetPinDirection()` to set the direction for a GPIO pin.
Pin numbers from 0-7 refer to port A, pin numbers from 8-15 to port B
  - Line 204: We declare a method `GetPinValue()` to get the value for a GPIO pin.
Pin numbers from 0-7 refer to port A, pin numbers from 8-15 to port B
  - Line 205: We declare a method `SetPinValue()` to set the value for a GPIO pin.
Pin numbers from 0-7 refer to port A, pin numbers from 8-15 to port B
  - Line 206: We declare a method `SetPortADirections()` to set the direction for all GPIO pins on port A
  - Line 207: We declare a method `GetPortAValue()` to get the value for all GPIO pins on port A.
Bit 0 is pin 0 on port A, Bit 7 is pin 7 on port A
  - Line 208: We declare a method `SetPortAValue()` to set the value for all GPIO pins on port A.
Bit 0 is pin 0 on port A, Bit 7 is pin 7 on port A
  - Line 209: We declare a method `SetPortBDirections()` to set the direction for all GPIO pins on port B
  - Line 210: We declare a method `GetPortBValue()` to get the value for all GPIO pins on port B.
Bit 0 is pin 0 on port B, Bit 7 is pin 7 on port B
  - Line 211: We declare a method `SetPortBValue()` to set the value for all GPIO pins on port B.
Bit 0 is pin 0 on port B, Bit 7 is pin 7 on port B

### MCP23017.cpp {#TUTORIAL_21_I2C_USING_MCP23017___STEP_2_MCP23017CPP}

We'll implement the MCP23017 device.

Create file `code/libraries/device/src/i2c/MCP23017.cpp`

```cpp
File: code/libraries/device/src/i2c/MCP23017.cpp
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MCP23017.cpp
5: //
6: // Namespace   : device
7: //
8: // Class       : MCP23017
9: //
10: // Description : I2C Master functionality
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39: 
40: #include <device/i2c/MCP23017.h>
41: 
42: #include <baremetal/Logger.h>
43: 
44: using namespace device;
45: using namespace baremetal;
46: 
47: /// @file
48: /// MCP 23017 I2C expander support declaration
49: 
50: /// @brief Define log name
51: LOG_MODULE("MCP23017");
52: 
53: /// <summary>
54: /// Constructor for MCP23017 class
55: /// </summary>
56: /// <param name="memoryAccess">MemoryAccess instance to be used for register access</param>
57: MCP23017::MCP23017(baremetal::IMemoryAccess &memoryAccess /*= baremetal::GetMemoryAccess()*/)
58:     : m_device{ memoryAccess }
59: {
60: }
61: 
62: /// <summary>
63: /// Destructor for MCP23017 class
64: /// </summary>
65: MCP23017::~MCP23017()
66: {
67:     SetPortADirections(PinDirection::In);
68:     SetPortBDirections(PinDirection::In);
69: }
70: 
71: /// <summary>
72: /// Initialize the MCP23017 I2C expander
73: /// </summary>
74: /// <param name="bus">I2C bus index</param>
75: /// <param name="address">I2C slave address</param>
76: /// <returns>True on success, false otherwise</returns>
77: bool MCP23017::Initialize(uint8 bus, uint8 address)
78: {
79:     LOG_INFO("Initialize %02x", address);
80:     m_address = address;
81:     if (!m_device.Initialize(bus, I2CClockMode::Normal, 0))
82:      return false;
83: 
84:     WriteRegister(IOCONA, 0x2c); // BANK = 0, MIRROR = 0, SEQOP = 1, DISSLW = 0, HAEN = 1, ODR = 1, INTPOL = 0
85:     return true;
86: }
87: 
88: /// <summary>
89: /// Read from the specified MCP23017 register
90: /// </summary>
91: /// <param name="registerAddress">Register index</param>
92: /// <returns>Value read</returns>
93: uint8 MCP23017::ReadRegister(MCP23017RegisterIndex registerAddress)
94: {
95:     uint8 address = static_cast<uint8>(registerAddress);
96:     uint8 data{};
97:     auto bytesTransferred = m_device.WriteReadRepeatedStart(m_address, &address, 1, &data, 1);
98:     LOG_DEBUG("Read bytes from I2C %02x Register %02x: %02x, %d bytes transferred", m_address, address, data, bytesTransferred);
99:     return data;
100: }
101: 
102: /// <summary>
103: /// Write to the specified MCP23017 register
104: /// </summary>
105: /// <param name="registerAddress">Register index</param>
106: /// <param name="byte">Value to write</param>
107: void MCP23017::WriteRegister(MCP23017RegisterIndex registerAddress, uint8 byte)
108: {
109:     const size_t BufferSize{ 2 };
110:     uint8 buffer[BufferSize];
111:     buffer[0] = static_cast<uint8>(registerAddress);
112:     buffer[1] = byte;
113:     auto bytesWritten = m_device.Write(m_address, buffer, BufferSize);
114: 
115:     LOG_DEBUG("Write bytes to I2C %02x Register %02x: %02x, %d bytes written", m_address, buffer[0], buffer[1], bytesWritten);
116: }
117: 
118: /// <summary>
119: /// Get the I/O pin direction for the specified pin on the MCP23017
120: /// </summary>
121: /// <param name="pinNumber">Pin index (0-7 on Port A, 8-15 on Port B)</param>
122: /// <param name="direction">Holds pin direction on return</param>
123: void MCP23017::GetPinDirection(uint8 pinNumber, PinDirection &direction)
124: {
125:     MCP23017RegisterIndex registerAddress = (pinNumber < 8) ? IODIRA : IODIRB;
126:     uint8 data = ReadRegister(registerAddress);
127:     uint8 pinShift = pinNumber % 8;
128:     direction = (data & (1 << pinShift)) ? PinDirection::In : PinDirection::In;
129: }
130: 
131: /// <summary>
132: /// Set the I/O pin direction for the specified pin on the MCP23017
133: /// </summary>
134: /// <param name="pinNumber">Pin index (0-7 on Port A, 8-15 on Port B)</param>
135: /// <param name="direction">Pin direction to set</param>
136: void MCP23017::SetPinDirection(uint8 pinNumber, const PinDirection &direction)
137: {
138:     MCP23017RegisterIndex registerAddress = (pinNumber < 8) ? IODIRA : IODIRB;
139:     uint8 data = ReadRegister(registerAddress);
140:     uint8 pinShift = pinNumber % 8;
141:     uint8 mask = 1 << pinShift;
142:     uint8 pinData = (direction == PinDirection::In) ? mask : 0;
143:     WriteRegister(registerAddress, (data & ~mask) | pinData);
144: }
145: 
146: /// <summary>
147: /// Get the value of an input pin on the MCP23017
148: /// </summary>
149: /// <param name="pinNumber">Pin index (0-7 on Port A, 8-15 on Port B)</param>
150: /// <returns>Requested pin value</returns>
151: bool MCP23017::GetPinValue(uint8 pinNumber)
152: {
153:     MCP23017RegisterIndex registerAddress = (pinNumber < 8) ? GPIOA : GPIOB;
154:     uint8 data = ReadRegister(registerAddress);
155:     uint8 pinShift = pinNumber % 8;
156:     return (data & (1 << pinShift));
157: }
158: 
159: /// <summary>
160: /// Set the value of an output pin on the MCP23017
161: /// </summary>
162: /// <param name="pinNumber">Pin index (0-7 on Port A, 8-15 on Port B)</param>
163: /// <param name="on">Value for output pin</param>
164: void MCP23017::SetPinValue(uint8 pinNumber, bool on)
165: {
166:     MCP23017RegisterIndex registerAddress = (pinNumber < 8) ? GPIOA : GPIOB;
167:     uint8 data = ReadRegister(registerAddress);
168:     uint8 pinShift = pinNumber % 8;
169:     uint8 mask = 1 << pinShift;
170:     uint8 pinData = on ? mask : 0;
171:     WriteRegister(registerAddress, (data & ~mask) | pinData);
172: }
173: 
174: /// <summary>
175: /// Set I/O pin directions for all pin on Port A
176: /// </summary>
177: /// <param name="direction">Direction for pins</param>
178: void MCP23017::SetPortADirections(const PinDirection &direction)
179: {
180:     WriteRegister(GPPUA, 0x00);
181:     WriteRegister(IODIRA, direction == PinDirection::In ? 0xFF : 0x00);
182: }
183: 
184: /// <summary>
185: /// Get value for all pins on Port A.
186: /// Bit 0 is the value for pin 0, etc.
187: /// </summary>
188: /// <returns></returns>
189: uint8 MCP23017::GetPortAValue()
190: {
191:     return ReadRegister(GPIOA);
192: }
193: 
194: /// <summary>
195: /// Set value for all pins on Port A
196: /// </summary>
197: /// <param name="data">Value for pins. Bit 0 is the value for pin 0, etc.</param>
198: void MCP23017::SetPortAValue(uint8 data)
199: {
200:     WriteRegister(GPIOA, data);
201: }
202: 
203: /// <summary>
204: /// Set I/O pin directions for all pin on Port B
205: /// </summary>
206: /// <param name="direction">Direction for pins</param>
207: void MCP23017::SetPortBDirections(const PinDirection &direction)
208: {
209:     WriteRegister(GPPUB, 0x00);
210:     WriteRegister(IODIRB, direction == PinDirection::In ? 0xFF : 0x00);
211: }
212: 
213: /// <summary>
214: /// Get value for all pins on Port B.
215: /// Bit 0 is the value for pin 0, etc.
216: /// </summary>
217: /// <returns></returns>
218: uint8 MCP23017::GetPortBValue()
219: {
220:     return ReadRegister(GPIOB);
221: }
222: 
223: /// <summary>
224: /// Set value for all pins on Port B
225: /// </summary>
226: /// <param name="data">Value for pins. Bit 0 is the value for pin 0, etc.</param>
227: void MCP23017::SetPortBValue(uint8 data)
228: {
229:     WriteRegister(GPIOB, data);
230: }
```

- Line 53-60: We implement the constructor
- Line 62-69: We implement the destructor.
This calls `SetPortADirection()`  and `SetPortBDirection()` to set the GPIO pins on the MCP23017 to input
- Line 71-86: We implement the `Initialize()` method.
The only thing worthwhile mentioning is that we set the IOCON register value with a default
- Line 88-100: We implement the `ReadRegister()` method.
This is implemented as a write/read transaction, as the register index needs to be sent before we can read it
- Line 102-116: We implement the `WriteRegister()` method.
Here we add the register index together with the byte to be written into an array that is then sent
- Line 118-129: We implement the `GetPinDirection()` method.
  - Line 125: We determine the register to read from depending on the pin number
  - Line 126: We read the register value
  - Line 127-128: We extract the pin direction for the requested pin
- Line 131-144: We implement the `SetPinDirection()` method.
  - Line 138: We determine the register to write to depending on the pin number
  - Line 139: We read the register value
  - Line 140-142: We determine the value to add (the specific bit for the requested pin)
  - Line 143: We mask out the current pin direction and add the new pin direction, then write to the register
- Line 146-157: We implement the `GetPinValue()` method.
  - Line 153: We determine the register to read from depending on the pin number
  - Line 154: We read the register value
  - Line 155-156: We extract the pin value for the requested pin
- Line 159-172: We implement the `SetPinValue()` method.
  - Line 166: We determine the register to write to depending on the pin number
  - Line 167: We read the register value
  - Line 168-170: We determine the value to add (the specific bit for the requested pin)
  - Line 171: We mask out the current pin value and add the new pin value, then write to the register
- Line 174-182: We implement the `SetPortADirections()` method.
  - Line 180: We write all 0's to the Pull-up register for port A GPPUA when the pins are set output, all 1's if set to input
  - Line 181: We write all 0's to the Direction register for port A IODIRA when the pins are set output, all 1's if set to input
- Line 184-192: We implement the `GetPortAValue()` method.
We read the GPIO register for port A GPIOA
- Line 194-201: We implement the `SetPortAValue()` method.
We write the GPIO register for port A GPIOA
- Line 203-211: We implement the `SetPortBDirections()` method.
  - Line 209: We write all 0's to the Pull-up register for port B GPPUB when the pins are set output, all 1's if set to input
  - Line 210: We write all 0's to the Direction register for port B IODIRB when the pins are set output, all 1's if set to input
- Line 213-221: We implement the `GetPortBValue()` method.
We read the GPIO register for port B GPIOB
- Line 223-230: We implement the `SetPortBValue()` method.
We write the GPIO register for port B GPIOB

## Faking MCP23017 - Step 3 {#TUTORIAL_21_I2C_FAKING_MCP23017___STEP_3}

In principle we could start writing an application, but again, we'll fake the functionality first.

### MemoryAccessStubMCP23017LEDs.h {#TUTORIAL_21_I2C_FAKING_MCP23017___STEP_3_MEMORYACCESSSTUBMCP23017LEDSH}

We'll define a `IMemoryAccess` implementation that will fake the I2C register access for the MCP23017 chip.

Create file `code/libraries/device/include/device/i2c/MemoryAccessStubMCP23017LEDs.h`

```cpp
File: code/libraries/device/include/device/i2c/MemoryAccessStubMCP23017LEDs.h
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MemoryAccessStubMCP23017LEDs.h
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : MemoryAccessStubMCP23017LEDs
9: //
10: // Description : MCP23017 memory access stub with LEDs on output pins, and controllable inputs on input pins
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39: 
40: #pragma once
41: 
42: #include <stdlib/Macros.h>
43: #include <baremetal/stubs/MemoryAccessStubI2C.h>
44: 
45: /// @file
46: /// MemoryAccessStubMCP23017LEDs
47: 
48: namespace device {
49: 
50: /// @brief MCP23017 registers
51: class MCP23017Registers
52: {
53: public:
54:     /// @brief I/O Direction Register Port A
55:     uint8 IODIRA;
56:     /// @brief I/O Direction Register Port B
57:     uint8 IODIRB;
58:     /// @brief Input Polarity Register Port A
59:     uint8 IPOLA;
60:     /// @brief Input Polarity Register Port B
61:     uint8 IPOLB;
62:     /// @brief GPIO Interrupt Enable Register Port A
63:     uint8 GPINTENA;
64:     /// @brief GPIO Interrupt Enable Register Port B
65:     uint8 GPINTENB;
66:     /// @brief Default Compare Register Port A
67:     uint8 DEFVALA;
68:     /// @brief Default Compare Register Port B
69:     uint8 DEFVALB;
70:     /// @brief Interrupt Control Register Port A
71:     uint8 INTCONA;
72:     /// @brief Interrupt Control Register Port B
73:     uint8 INTCONB;
74:     /// @brief I/O Control Register Port A
75:     uint8 IOCONA;
76:     /// @brief I/O Control Register Port B
77:     uint8 IOCONB;
78:     /// @brief GPIO Pull-up Resistor Configuration Register Port A
79:     uint8 GPPUA;
80:     /// @brief GPIO Pull-up Resistor Configuration Register Port B
81:     uint8 GPPUB;
82:     /// @brief Interrupt Flag Register Port A
83:     uint8 INTFA;
84:     /// @brief Interrupt Flag Register Port B
85:     uint8 INTFB;
86:     /// @brief Interrupt Captured Register Port A
87:     uint8 INTCAPA;
88:     /// @brief Interrupt Captured Register Port B
89:     uint8 INTCAPB;
90:     /// @brief GPIO Port Register Port A
91:     uint8 GPIOA;
92:     /// @brief GPIO Port Register Port b
93:     uint8 GPIOB;
94:     /// @brief Output Latch Register Port A
95:     uint8 OLATA;
96:     /// @brief Output Latch Register Port B
97:     uint8 OLATB;
98: 
99:     /// <summary>
100:     /// Constructor for MCP23017 register storage
101:     /// </summary>
102:     MCP23017Registers()
103:         : IODIRA{ 0xFF }
104:         , IODIRB{ 0xFF }
105:         , IPOLA{}
106:         , IPOLB{}
107:         , GPINTENA{}
108:         , GPINTENB{}
109:         , DEFVALA{}
110:         , DEFVALB{}
111:         , INTCONA{}
112:         , INTCONB{}
113:         , IOCONA{}
114:         , IOCONB{}
115:         , GPPUA{}
116:         , GPPUB{}
117:         , INTFA{}
118:         , INTFB{}
119:         , INTCAPA{}
120:         , INTCAPB{}
121:         , GPIOA{}
122:         , GPIOB{}
123:         , OLATA{}
124:         , OLATB{}
125:     {
126:     }
127: };
128: 
129: /// @brief MemoryAccess implementation for I2C stub
130: class MemoryAccessStubMCP23017LEDs:
131:     public baremetal::MemoryAccessStubI2C
132: {
133: private:
134:     /// @brief Singleton instance
135:     static MemoryAccessStubMCP23017LEDs* pThis;
136:     /// @brief Storage for I2C registers
137:     MCP23017Registers m_registers;
138:     /// @brief A read / write register cycle was started
139:     bool m_cycleStarted;
140:     /// @brief Register selected for current read / write register cycle
141:     uint8 m_selectedRegister;
142: 
143: public:
144:     MemoryAccessStubMCP23017LEDs();
145: 
146:     void ResetCycle();
147:     static bool OnSendAddress(baremetal::I2CRegisters& registers, uint8 data);
148:     static bool OnRecvData(baremetal::I2CRegisters& registers, uint8& data);
149:     static bool OnSendData(baremetal::I2CRegisters& registers, uint8 data);
150: };
151: 
152: } // namespace device
```

- Line 50-127: We declare a class `MCP23017Registers` to hold the register values for the MCP23017 device
  - Line 54-55: The member variable `IODIRA` holds the I/O Direction Register value for port A
  - Line 56-57: The member variable `IODIRB` holds the I/O Direction Register value for port B
  - Line 58-59: The member variable `IPOLA` holds the Input Polarity Register for port A
  - Line 60-61: The member variable `IPOLB` holds the Input Polarity Register for port B
  - Line 62-63: The member variable `GPINTENA` holds the GPIO Interrupt Enable Register for port A
  - Line 64-65: The member variable `GPINTENB` holds the GPIO Interrupt Enable Register for port B
  - Line 66-67: The member variable `DEFVALA` holds the Default Compare Register for port A
  - Line 68-69: The member variable `DEFVALB` holds the Default Compare Register for port B
  - Line 70-71: The member variable `INTCONA` holds the Interrupt Control Register for port A
  - Line 72-73: The member variable `INTCONB` holds the Interrupt Control Register for port B
  - Line 74-75: The member variable `IOCONA` holds the I/O Control Register for port A
  - Line 76-77: The member variable `IOCONB` holds the I/O Control Register for port B
  - Line 78-79: The member variable `GPPUA` holds the GPIO Pull-up Resistor Configuration Register for port A
  - Line 80-81: The member variable `GPPUB` holds the GPIO Pull-up Resistor Configuration Register for port B
  - Line 82-83: The member variable `INTFA` holds the Interrupt Flag Register for port A
  - Line 84-85: The member variable `INTFB` holds the Interrupt Flag Register for port B
  - Line 86-87: The member variable `INTCAPA` holds the Interrupt Captured Register for port A
  - Line 88-89: The member variable `INTCAPB` holds the Interrupt Captured Register for port B
  - Line 90-91: The member variable `GPIOA` holds the GPIO Port Register for port A
  - Line 92-93: The member variable `GPIOB` holds the GPIO Port Register for port B
  - Line 94-95: The member variable `OLATA` holds the Output Latch Register for port A
  - Line 96-97: The member variable `OLATB` holds the Output Latch Register for port B
  - Line 99-126: We define the constructor, which initializes the register values to their defaults
- Line 129-2152: We declare the class `MemoryAccessStubMCP23017LEDs` which acts as the `MemoryAccess` class for fake MCP23017 access.
Note that it derives from `MemoryAccessStubI2C`
  - Line 134-135: The static member variable `pThis` contains the pointer to the singleton instance
  - Line 136-137: The member variable `m_registers` holds the register values
  - Line 138-139: The member variable `m_cycleStarted` holds a flag whether a read or write cycle has started
  - Line 140-141: The member variable `m_selectedRegister` holds the index of the selected register
  - Line 144: We declare the constructor
  - Line 146: We declare the method `ResetCycle()` to reset the read / write cycle
  - Line 147: We declare the static method `OnSendAddress()` as a address send callback
  - Line 148: We declare the static method `OnRecvData()` as a data receive callback
  - Line 149: We declare the static method `OnSendData()` as a data send callback

### MemoryAccessStubMCP23017LEDs.cpp {#TUTORIAL_21_I2C_FAKING_MCP23017___STEP_3_MEMORYACCESSSTUBMCP23017LEDSCPP}

We'll implement the MemoryAccess stub for MCP23017.

Create file `code/libraries/device/src/i2c/MemoryAccessStubMCP23017LEDs.cpp`

```cpp
File: code/libraries/device/src/i2c/MemoryAccessStubMCP23017LEDs.cpp
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MemoryAccessStubMCP23017LEDs.cpp
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : MemoryAccessStubMCP23017LEDs
9: //
10: // Description : MCP23017 memory access stub with LEDs on output pins, and controllable inputs on input pins
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39: 
40: #include <device/i2c/MemoryAccessStubMCP23017LEDs.h>
41: 
42: #include <baremetal/Assert.h>
43: #include <baremetal/BCMRegisters.h>
44: #include <baremetal/Format.h>
45: #include <baremetal/Logger.h>
46: #include <baremetal/String.h>
47: #include <device/i2c/MCP23017.h>
48: 
49: /// @file
50: /// MemoryAccessStubMCP23017LEDs
51: 
52: /// @brief Define log name
53: LOG_MODULE("MemoryAccessStubMCP23017LEDs");
54: 
55: using namespace baremetal;
56: using namespace device;
57: 
58: /// @brief Singleton instance
59: MemoryAccessStubMCP23017LEDs* MemoryAccessStubMCP23017LEDs::pThis{};
60: 
61: /// <summary>
62: /// MemoryAccessStubMCP23017LEDs constructor
63: /// </summary>
64: MemoryAccessStubMCP23017LEDs::MemoryAccessStubMCP23017LEDs()
65:     : m_registers{}
66:     , m_cycleStarted{}
67:     , m_selectedRegister{}
68: {
69:     pThis = this;
70:     SetSendAddressByteCallback(OnSendAddress);
71:     SetRecvDataByteCallback(OnRecvData);
72:     SetSendDataByteCallback(OnSendData);
73: }
74: 
75: /// <summary>
76: /// Reset read or write cycle
77: /// </summary>
78: void MemoryAccessStubMCP23017LEDs::ResetCycle()
79: {
80:     m_cycleStarted = false;
81: }
82: 
83: /// <summary>
84: /// Callback when I2C address is sent
85: /// </summary>
86: /// <param name="registers">I2C register storage, unused</param>
87: /// <param name="data">I2C address, unused</param>
88: /// <returns>True always</returns>
89: bool MemoryAccessStubMCP23017LEDs::OnSendAddress(I2CRegisters &/*registers*/, uint8 /*data*/)
90: {
91:     return true;
92: }
93: 
94: /// <summary>
95: /// Callback when I2C byte is to be received
96: /// </summary>
97: /// <param name="registers">I2C Register storage for stub</param>
98: /// <param name="data">Byte requested</param>
99: /// <returns>True always</returns>
100: bool MemoryAccessStubMCP23017LEDs::OnRecvData(I2CRegisters &registers, uint8 &data)
101: {
102:     uint8* registerAddress = &pThis->m_registers.IODIRA + pThis->m_selectedRegister;
103:     data = *registerAddress;
104:     LOG_DEBUG("Read register %02x: %02x", pThis->m_selectedRegister, data);
105:     switch (pThis->m_selectedRegister)
106:     {
107:         case IOCONA:
108:         case IOCONB:
109:         {
110:             string line;
111:             if (data & IOCON_BANK)
112:                 line += "Bank 1 ";
113:             else
114:                 line += "Bank 0 ";
115:             if (data & IOCON_MIRROR)
116:                 line += "INT_MIRROR ";
117:             else
118:                 line += "           ";
119:             if (data & IOCON_SEQOP)
120:                 line += "SEQOP ";
121:             else
122:                 line += "      ";
123:             if (data & IOCON_DISSLW)
124:                 line += "DISSLW ";
125:             else
126:                 line += "       ";
127:             if (data & IOCON_HAEN)
128:                 line += "HAEN ";
129:             else
130:                 line += "HAEN ";
131:             if (data & IOCON_ODR)
132:                 line += "ODR ";
133:             else
134:                 line += "    ";
135:             if (data & IOCON_INTPOL)
136:                 line += "INTPOL H";
137:             else
138:                 line += "INTPOL L";
139:             LOG_INFO("IOCON: %s", line.c_str());
140:             break;
141:         }
142:         case IODIRA:
143:         {
144:             string line;
145:             uint8 bits = data;
146:             for (int i = 0; i < 8; ++i)
147:             {
148:                 line += (bits & 0x80 ? "I" : "O");
149:                 bits <<= 1;
150:             }
151:             LOG_INFO("IODIR A: %s", line.c_str());
152:             break;
153:         }
154:         case IODIRB:
155:         {
156:             string line;
157:             uint8 bits = data;
158:             for (int i = 0; i < 8; ++i)
159:             {
160:                 line += (bits & 0x80 ? "I" : "O");
161:                 bits <<= 1;
162:             }
163:             LOG_INFO("IODIR B: %s", line.c_str());
164:             break;
165:         }
166:         case GPIOA:
167:         {
168:             string line;
169:             uint8 gpio = data;
170:             for (int i = 0; i < 8; ++i)
171:             {
172:                 line += (gpio & 0x80 ? "X" : " ");
173:                 gpio <<= 1;
174:             }
175:             LOG_INFO("GPIO A: %s", line.c_str());
176:             break;
177:         }
178:         case GPIOB:
179:         {
180:             string line;
181:             uint8 gpio = data;
182:             for (int i = 0; i < 8; ++i)
183:             {
184:                 line += (gpio & 0x80 ? "X" : " ");
185:                 gpio <<= 1;
186:             }
187:             LOG_INFO("GPIO B: %s", line.c_str());
188:             break;
189:         }
190:         case GPINTENA:
191:         {
192:             string line;
193:             uint8 bits = data;
194:             for (int i = 0; i < 8; ++i)
195:             {
196:                 line += Format("Pin %d ", i);
197:                 line += (bits & 0x80 ? "X" : " ");
198:                 bits <<= 1;
199:             }
200:             LOG_INFO("GPINTEN A: %s", line.c_str());
201:             break;
202:         }
203:         case GPINTENB:
204:         {
205:             string line;
206:             uint8 bits = data;
207:             for (int i = 0; i < 8; ++i)
208:             {
209:                 line += Format("Pin %d ", i);
210:                 line += (bits & 0x80 ? "X" : " ");
211:                 bits <<= 1;
212:             }
213:             LOG_INFO("GPINTEN B: %s", line.c_str());
214:             break;
215:         }
216:         case INTCONA:
217:         {
218:             string line;
219:             uint8 bits = data;
220:             for (int i = 0; i < 8; ++i)
221:             {
222:                 line += Format("Pin %d ", i);
223:                 line += (bits & 0x80 ? "DEF " : "PRV ");
224:                 bits <<= 1;
225:             }
226:             LOG_INFO("INTCON A: %s", line.c_str());
227:             break;
228:         }
229:         case INTCONB:
230:         {
231:             string line;
232:             uint8 bits = data;
233:             for (int i = 0; i < 8; ++i)
234:             {
235:                 line += Format("Pin %d ", i);
236:                 line += (bits & 0x80 ? "DEF " : "PRV ");
237:                 bits <<= 1;
238:             }
239:             LOG_INFO("INTCON B: %s", line.c_str());
240:             break;
241:         }
242:         case DEFVALA:
243:         {
244:             string line;
245:             uint8 bits = data;
246:             for (int i = 0; i < 8; ++i)
247:             {
248:                 line += Format("Pin %d ", i);
249:                 line += (bits & 0x80 ? "1" : "0");
250:                 bits <<= 1;
251:             }
252:             LOG_INFO("DEFVAL A: %s", line.c_str());
253:             break;
254:         }
255:         case DEFVALB:
256:         {
257:             string line;
258:             uint8 bits = data;
259:             for (int i = 0; i < 8; ++i)
260:             {
261:                 line += Format("Pin %d ", i);
262:                 line += (bits & 0x80 ? "1" : "0");
263:                 bits <<= 1;
264:             }
265:             LOG_INFO("DEFVAL B: %s", line.c_str());
266:             break;
267:         }
268:         case IPOLA:
269:         {
270:             string line;
271:             uint8 bits = data;
272:             for (int i = 0; i < 8; ++i)
273:             {
274:                 line += Format("Pin %d ", i);
275:                 line += (bits & 0x80 ? "~" : " ");
276:                 bits <<= 1;
277:             }
278:             LOG_INFO("IPOL A: %s", line.c_str());
279:             break;
280:         }
281:         case IPOLB:
282:         {
283:             string line;
284:             uint8 bits = data;
285:             for (int i = 0; i < 8; ++i)
286:             {
287:                 line += Format("Pin %d ", i);
288:                 line += (bits & 0x80 ? "~" : " ");
289:                 bits <<= 1;
290:             }
291:             LOG_INFO("IPOL B: %s", line.c_str());
292:             break;
293:         }
294:         case GPPUA:
295:         {
296:             string line;
297:             uint8 bits = data;
298:             for (int i = 0; i < 8; ++i)
299:             {
300:                 line += Format("Pin %d ", i);
301:                 line += (bits & 0x80 ? "U" : "");
302:                 bits <<= 1;
303:             }
304:             LOG_INFO("GPPU A: %s", line.c_str());
305:             break;
306:         }
307:         case GPPUB:
308:         {
309:             string line;
310:             uint8 bits = data;
311:             for (int i = 0; i < 8; ++i)
312:             {
313:                 line += Format("Pin %d ", i);
314:                 line += (bits & 0x80 ? "U" : "");
315:                 bits <<= 1;
316:             }
317:             LOG_INFO("GPPU B: %s", line.c_str());
318:             break;
319:         }
320:         case INTFA:
321:         {
322:             string line;
323:             uint8 bits = data;
324:             for (int i = 0; i < 8; ++i)
325:             {
326:                 line += Format("Pin %d ", i);
327:                 line += (bits & 0x80 ? "X" : "");
328:                 bits <<= 1;
329:             }
330:             LOG_INFO("INTF A: %s", line.c_str());
331:             break;
332:         }
333:         case INTFB:
334:         {
335:             string line;
336:             uint8 bits = data;
337:             for (int i = 0; i < 8; ++i)
338:             {
339:                 line += Format("Pin %d ", i);
340:                 line += (bits & 0x80 ? "X" : "");
341:                 bits <<= 1;
342:             }
343:             LOG_INFO("INTF B: %s", line.c_str());
344:             break;
345:         }
346:         case INTCAPA:
347:         {
348:             string line;
349:             uint8 bits = data;
350:             for (int i = 0; i < 8; ++i)
351:             {
352:                 line += Format("Pin %d ", i);
353:                 line += (bits & 0x80 ? "1" : "0");
354:                 bits <<= 1;
355:             }
356:             LOG_INFO("INTCAP A: %s", line.c_str());
357:             break;
358:         }
359:         case INTCAPB:
360:         {
361:             string line;
362:             uint8 bits = data;
363:             for (int i = 0; i < 8; ++i)
364:             {
365:                 line += Format("Pin %d ", i);
366:                 line += (bits & 0x80 ? "1" : "0");
367:                 bits <<= 1;
368:             }
369:             LOG_INFO("INTCAP B: %s", line.c_str());
370:             break;
371:         }
372:         case OLATA:
373:         {
374:             string line;
375:             uint8 bits = data;
376:             for (int i = 0; i < 8; ++i)
377:             {
378:                 line += Format("Pin %d ", i);
379:                 line += (bits & 0x80 ? "1" : "0");
380:                 bits <<= 1;
381:             }
382:             LOG_INFO("OLAT A: %s", line.c_str());
383:             break;
384:         }
385:         case OLATB:
386:         {
387:             string line;
388:             uint8 bits = data;
389:             for (int i = 0; i < 8; ++i)
390:             {
391:                 line += Format("Pin %d ", i);
392:                 line += (bits & 0x80 ? "1" : "0");
393:                 bits <<= 1;
394:             }
395:             LOG_INFO("OLAT B: %s", line.c_str());
396:             break;
397:         }
398:     }
399:     pThis->ResetCycle();
400: 
401:     return true;
402: }
403: 
404: /// <summary>
405: /// Callback when I2C byte is sent
406: /// </summary>
407: /// <param name="registers">I2C Register storage for stub</param>
408: /// <param name="data">Byte sent</param>
409: /// <returns>True always</returns>
410: bool MemoryAccessStubMCP23017LEDs::OnSendData(I2CRegisters &registers, uint8 data)
411: {
412:     if (!pThis->m_cycleStarted)
413:     {
414:         pThis->m_selectedRegister = data;
415:         pThis->m_cycleStarted = true;
416:     }
417:     else
418:     {
419:         uint8* registerAddress = &pThis->m_registers.IODIRA + pThis->m_selectedRegister;
420:         *registerAddress = data;
421:         LOG_DEBUG("Write register %02x: %02x", pThis->m_selectedRegister, data);
422:         switch (pThis->m_selectedRegister)
423:         {
424:             case IOCONA:
425:             case IOCONB:
426:             {
427:                 string line;
428:                 if (data & IOCON_BANK)
429:                     line += "Bank 1 ";
430:                 else
431:                     line += "Bank 0 ";
432:                 if (data & IOCON_MIRROR)
433:                     line += "INT_MIRROR ";
434:                 else
435:                     line += "           ";
436:                 if (data & IOCON_SEQOP)
437:                     line += "SEQOP ";
438:                 else
439:                     line += "      ";
440:                 if (data & IOCON_DISSLW)
441:                     line += "DISSLW ";
442:                 else
443:                     line += "       ";
444:                 if (data & IOCON_HAEN)
445:                     line += "HAEN ";
446:                 else
447:                     line += "HAEN ";
448:                 if (data & IOCON_ODR)
449:                     line += "ODR ";
450:                 else
451:                     line += "    ";
452:                 if (data & IOCON_INTPOL)
453:                     line += "INTPOL H";
454:                 else
455:                     line += "INTPOL L";
456:                 LOG_INFO("IOCON: %s", line.c_str());
457:                 break;
458:             }
459:             case IODIRA:
460:             {
461:                 string line;
462:                 uint8 bits = data;
463:                 for (int i = 0; i < 8; ++i)
464:                 {
465:                     line += (bits & 0x80 ? "I" : "O");
466:                     bits <<= 1;
467:                 }
468:                 LOG_INFO("IODIR A: %s", line.c_str());
469:                 break;
470:             }
471:             case IODIRB:
472:             {
473:                 string line;
474:                 uint8 bits = data;
475:                 for (int i = 0; i < 8; ++i)
476:                 {
477:                     line += (bits & 0x80 ? "I" : "O");
478:                     bits <<= 1;
479:                 }
480:                 LOG_INFO("IODIR B: %s", line.c_str());
481:                 break;
482:             }
483:             case GPIOA:
484:             {
485:                 string line;
486:                 uint8 gpio = data;
487:                 for (int i = 0; i < 8; ++i)
488:                 {
489:                     line += (gpio & 0x80 ? "X" : " ");
490:                     gpio <<= 1;
491:                 }
492:                 LOG_INFO("GPIO A: %s", line.c_str());
493:                 break;
494:             }
495:             case GPIOB:
496:             {
497:                 string line;
498:                 uint8 gpio = data;
499:                 for (int i = 0; i < 8; ++i)
500:                 {
501:                     line += (gpio & 0x80 ? "X" : " ");
502:                     gpio <<= 1;
503:                 }
504:                 LOG_INFO("GPIO B: %s", line.c_str());
505:                 break;
506:             }
507:             case GPINTENA:
508:             {
509:                 string line;
510:                 uint8 bits = data;
511:                 for (int i = 0; i < 8; ++i)
512:                 {
513:                     line += Format("Pin %d ", i);
514:                     line += (bits & 0x80 ? "X" : " ");
515:                     bits <<= 1;
516:                 }
517:                 LOG_INFO("GPINTEN A: %s", line.c_str());
518:                 break;
519:             }
520:             case GPINTENB:
521:             {
522:                 string line;
523:                 uint8 bits = data;
524:                 for (int i = 0; i < 8; ++i)
525:                 {
526:                     line += Format("Pin %d ", i);
527:                     line += (bits & 0x80 ? "X" : " ");
528:                     bits <<= 1;
529:                 }
530:                 LOG_INFO("GPINTEN B: %s", line.c_str());
531:                 break;
532:             }
533:             case INTCONA:
534:             {
535:                 string line;
536:                 uint8 bits = data;
537:                 for (int i = 0; i < 8; ++i)
538:                 {
539:                     line += Format("Pin %d ", i);
540:                     line += (bits & 0x80 ? "DEF " : "PRV ");
541:                     bits <<= 1;
542:                 }
543:                 LOG_INFO("INTCON A: %s", line.c_str());
544:                 break;
545:             }
546:             case INTCONB:
547:             {
548:                 string line;
549:                 uint8 bits = data;
550:                 for (int i = 0; i < 8; ++i)
551:                 {
552:                     line += Format("Pin %d ", i);
553:                     line += (bits & 0x80 ? "DEF " : "PRV ");
554:                     bits <<= 1;
555:                 }
556:                 LOG_INFO("INTCON B: %s", line.c_str());
557:                 break;
558:             }
559:             case DEFVALA:
560:             {
561:                 string line;
562:                 uint8 bits = data;
563:                 for (int i = 0; i < 8; ++i)
564:                 {
565:                     line += Format("Pin %d ", i);
566:                     line += (bits & 0x80 ? "1" : "0");
567:                     bits <<= 1;
568:                 }
569:                 LOG_INFO("DEFVAL A: %s", line.c_str());
570:                 break;
571:             }
572:             case DEFVALB:
573:             {
574:                 string line;
575:                 uint8 bits = data;
576:                 for (int i = 0; i < 8; ++i)
577:                 {
578:                     line += Format("Pin %d ", i);
579:                     line += (bits & 0x80 ? "1" : "0");
580:                     bits <<= 1;
581:                 }
582:                 LOG_INFO("DEFVAL B: %s", line.c_str());
583:                 break;
584:             }
585:             case IPOLA:
586:             {
587:                 string line;
588:                 uint8 bits = data;
589:                 for (int i = 0; i < 8; ++i)
590:                 {
591:                     line += Format("Pin %d ", i);
592:                     line += (bits & 0x80 ? "~" : " ");
593:                     bits <<= 1;
594:                 }
595:                 LOG_INFO("IPOL A: %s", line.c_str());
596:                 break;
597:             }
598:             case IPOLB:
599:             {
600:                 string line;
601:                 uint8 bits = data;
602:                 for (int i = 0; i < 8; ++i)
603:                 {
604:                     line += Format("Pin %d ", i);
605:                     line += (bits & 0x80 ? "~" : " ");
606:                     bits <<= 1;
607:                 }
608:                 LOG_INFO("IPOL B: %s", line.c_str());
609:                 break;
610:             }
611:             case GPPUA:
612:             {
613:                 string line;
614:                 uint8 bits = data;
615:                 for (int i = 0; i < 8; ++i)
616:                 {
617:                     line += Format("Pin %d ", i);
618:                     line += (bits & 0x80 ? "U" : "");
619:                     bits <<= 1;
620:                 }
621:                 LOG_INFO("GPPU A: %s", line.c_str());
622:                 break;
623:             }
624:             case GPPUB:
625:             {
626:                 string line;
627:                 uint8 bits = data;
628:                 for (int i = 0; i < 8; ++i)
629:                 {
630:                     line += Format("Pin %d ", i);
631:                     line += (bits & 0x80 ? "U" : "");
632:                     bits <<= 1;
633:                 }
634:                 LOG_INFO("GPPU B: %s", line.c_str());
635:                 break;
636:             }
637:             case OLATA:
638:             {
639:                 string line;
640:                 uint8 bits = data;
641:                 for (int i = 0; i < 8; ++i)
642:                 {
643:                     line += Format("Pin %d ", i);
644:                     line += (bits & 0x80 ? "1" : "0");
645:                     bits <<= 1;
646:                 }
647:                 LOG_INFO("OLAT A: %s", line.c_str());
648:                 break;
649:             }
650:             case OLATB:
651:             {
652:                 string line;
653:                 uint8 bits = data;
654:                 for (int i = 0; i < 8; ++i)
655:                 {
656:                     line += Format("Pin %d ", i);
657:                     line += (bits & 0x80 ? "1" : "0");
658:                     bits <<= 1;
659:                 }
660:                 LOG_INFO("OLAT B: %s", line.c_str());
661:                 break;
662:             }
663:         }
664:         pThis->ResetCycle();
665:     }
666:     return true;
667: }
```

- Line 58-59: We define static instance variable
- Line 61-73: We implement the constructor
- Line 75-81: We implement the method `ResetCycle()`
- Line 83-92: We implement the method `OnSendAddress()`, which does nothing
- Line 94-402: We implement the method `OnRecvData()`
  - Line 102: We calculate the pointer to the selected register value
  - Line 103: We retrieve the register value
  - Line 107-141: If one of the IOCON registers is read, we print the values for the respective bits
  - Line 142-153: If the IODIRA register is read, we print the pin directions for port A
  - Line 154-165: If the IODIRB register is read, we print the pin directions for port B
  - Line 166-177: If the GPIOA register is read, we print the pin values for port A
  - Line 178-189: If the GPIOB register is read, we print the pin values for port B
  - Line 190-202: If the GPINTENA register is read, we print the pin interrupt enable status for port A
  - Line 203-215: If the GPINTENB register is read, we print the pin interrupt enable status for port B
  - Line 216-228: If the INTCONA register is read, we print the pin interrupt comparison setting (compare to default or compare to previous) for port A
  - Line 229-241: If the INTCONB register is read, we print the pin interrupt comparison setting (compare to default or compare to previous) for port B
  - Line 242-254: If the DEFVALA register is read, we print the pin interrupt comparison default value for port A
  - Line 255-267: If the DEFVALB register is read, we print the pin interrupt comparison default value for port B
  - Line 268-280: If the IPOLA register is read, we print the pin polarity setting (same logic or inverted logic) for port A
  - Line 281-293: If the IPOLB register is read, we print the pin polarity setting (same logic or inverted logic) for port B
  - Line 294-306: If the GPPUA register is read, we print the pin pull up settings for port A
  - Line 307-319: If the GPPUB register is read, we print the pin pull up settings for port B
  - Line 320-332: If the INTFA register is read, we print the pin interrupt flags for port A
  - Line 333-345: If the INTFA register is read, we print the pin interrupt flags for port A
  - Line 346-358: If the INTCAPA register is read, we print the pin value at the time of the last interrupt flags for port A
  - Line 359-371: If the INTCAPB register is read, we print the pin value at the time of the last interrupt flags for port B
  - Line 372-384: If the OLATA register is read, we print the pin output latch value for port A
  - Line 385-398: If the OLATA register is read, we print the pin output latch value for port A
  - Line 399: We reset the read cycle
- Line 404-719: We implement the method `OnSendData()`
  - Line 412-416: If the read / write cycle has not started yet, we save the selected register (this is the first byte sent) and start the cycle
  - Line 419: In can the cycle is started, this is a write cycle.
We calculate the pointer to the selected register value
  - Line 420: We set the register value
  - Line 424-458: If one of the IOCON registers is written, we print the values for the respective bits
  - Line 459-470: If the IODIRA register is written, we print the pin directions for port A
  - Line 471-482: If the IODIRB register is written, we print the pin directions for port B
  - Line 483-494: If the GPIOA register is written, we print the pin values for port A
  - Line 495-506: If the GPIOB register is written, we print the pin values for port B
  - Line 507-519: If the GPINTENA register is written, we print the pin interrupt enable status for port A
  - Line 520-532: If the GPINTENB register is written, we print the pin interrupt enable status for port B
  - Line 533-545: If the INTCONA register is written, we print the pin interrupt comparison setting (compare to default or compare to previous) for port A
  - Line 546-558: If the INTCONB register is written, we print the pin interrupt comparison setting (compare to default or compare to previous) for port B
  - Line 559-571: If the DEFVALA register is written, we print the pin interrupt comparison default value for port A
  - Line 572-584: If the DEFVALB register is written, we print the pin interrupt comparison default value for port B
  - Line 585-597: If the IPOLA register is written, we print the pin polarity setting (same logic or inverted logic) for port A
  - Line 598-610: If the IPOLB register is written, we print the pin polarity setting (same logic or inverted logic) for port B
  - Line 611-623: If the GPPUA register is written, we print the pin pull up settings for port A
  - Line 624-636: If the GPPUB register is written, we print the pin pull up settings for port B
  - Line 637-649: If the OLATA register is written, we print the pin output latch value for port A
  - Line 650-662: If the OLATA register is written, we print the pin output latch value for port A
  - Line 664: We reset the write cycle

### Update application code {#TUTORIAL_21_I2C_FAKING_MCP23017___STEP_3_UPDATE_APPLICATION_CODE}

Next let's use the new stub.
We'll initialize the MCP23017 chip, and the interact with it.

Update the file code/applications/demo/src/main.cpp.

```cpp
File: code/applications/demo/src/main.cpp
1: #include <baremetal/Format.h>
2: #include <baremetal/I2CMaster.h>
3: #include <baremetal/Logger.h>
4: #include <baremetal/PhysicalGPIOPin.h>
5: #include <baremetal/String.h>
6: #include <baremetal/System.h>
7: #include <baremetal/Timer.h>
8: #include <device/i2c/MemoryAccessStubMCP23017LEDs.h>
9: #include <device/i2c/MCP23017.h>
10: 
11: LOG_MODULE("main");
12: 
13: using namespace baremetal;
14: using namespace device;
15: 
16: int main()
17: {
18:     auto& console = GetConsole();
19:     GetLogger().SetLogLevel(LogSeverity::Debug);
20: 
21:     MemoryAccessStubMCP23017LEDs fakeMemoryAccess;
22: 
23:     uint8 busIndex = 1;
24:     fakeMemoryAccess.SetBus(busIndex);
25: 
26:     uint8 address{ 0x20 };
27:     MCP23017 expander(fakeMemoryAccess);
28:     
29:     if (!expander.Initialize(busIndex, address))
30:     {
31:         LOG_INFO("Cannot initialize expander");
32:     }
33: 
34:     expander.GetPortAValue();
35:     expander.SetPortADirections(PinDirection::Out);
36:     expander.SetPortBDirections(PinDirection::Out);
37:     expander.SetPortAValue(0x55);
38:     expander.SetPortBValue(0xAA);
39:     Timer::WaitMilliSeconds(500);
40:     expander.SetPortAValue(0xAA);
41:     expander.SetPortBValue(0x55);
42:     Timer::WaitMilliSeconds(500);
43:     expander.SetPortAValue(0x00);
44:     expander.SetPortBValue(0x00);
45: 
46:     LOG_INFO("Rebooting");
47: 
48:     return static_cast<int>(ReturnCode::ExitReboot);
49: }
```

- Line 21: We instantiate the stub for the MCP23017 device
- Line 24: We set up the I2C bus for the device
- Line 27: We instantiate a the MCP23017 expander, and inject the stub
- Line 29: We initialize the expander to the same bus, and address 0x20
- Line 34: We read the pin values for port A
- Line 35-36: We set the direction for all pins to output
- Line 37-38: We set the pins values for port A to 0x55 and for port B to 0xAA
- Line 39: We wait for half a second
- Line 40-41: We set the pins values for port A to 0xAA and for port B to 0x55, so the inverse of before
- Line 42: We wait for half a second
- Line 43-44: We set the pin value for all pins to 0 (off)

### Update device CMake file {#TUTORIAL_21_I2C_FAKING_MCP23017___STEP_3_UPDATE_DEVICE_CMAKE_FILE}

As we added some files to the device libary, we need update its CMake file.

Update the file `code/libraries/device/CMakeLists.txt`

```cmake
File: code/libraries/device/CMakeLists.txt
...
30: set(PROJECT_SOURCES
31:     ${CMAKE_CURRENT_SOURCE_DIR}/src/gpio/KY-040.cpp
32:     ${CMAKE_CURRENT_SOURCE_DIR}/src/i2c/MCP23017.cpp
33:     ${CMAKE_CURRENT_SOURCE_DIR}/src/i2c/MemoryAccessStubMCP23017LEDs.cpp
34:     )
35: 
36: set(PROJECT_INCLUDES_PUBLIC
37:     ${CMAKE_CURRENT_SOURCE_DIR}/include/device/gpio/KY-040.h
38:     ${CMAKE_CURRENT_SOURCE_DIR}/include/device/i2c/MCP23017.h
39:     ${CMAKE_CURRENT_SOURCE_DIR}/include/device/i2c/MemoryAccessStubMCP23017LEDs.h
40:     )
41: set(PROJECT_INCLUDES_PRIVATE )
...
```

### Configuring, building and debugging : Use I2C stub {#TUTORIAL_21_I2C_FAKING_MCP23017___STEP_3_CONFIGURING_BUILDING_AND_DEBUGGING__USE_I2C_STUB}

We can now configure and build our code, and test.
Notice that the setup of the GPIO pins is logged by the stub.

```text
1: Info   0.00:00:00.000 Baremetal 0.0.1 started on Raspberry Pi 4 Model B (AArch64) using BCM2711 SoC (Logger:96)
2: Info   0.00:00:00.010 Starting up (System:209)
3: Info   0.00:00:00.020 Initialize 20 (MCP23017:77)
4: Info   0.00:00:00.020 Initialize bus 1, mode 0, config 0 (I2CMaster:175)
5: Info   0.00:00:00.030 Set clock 100000 (I2CMaster:218)
6: Info   0.00:00:00.030 Set up bus 1, config 0, base address FE804000 (I2CMaster:201)
7: Info   0.00:00:00.040 Read I2C Control,              WR  (I2CMaster:584)
8: Info   0.00:00:00.040 Write I2C Control,            CL WR  (I2CMaster:605)
9: Info   0.00:00:00.050 Write I2C Address, 20 (I2CMaster:641)
10: Info   0.00:00:00.050 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
11: Info   0.00:00:00.060 Write I2C Length, 00000002 (I2CMaster:653)
12: Info   0.00:00:00.060 Write FIFO, data 0000000A (I2CMaster:849)
13: Info   0.00:00:00.060 Write FIFO, data 0000002C (I2CMaster:849)
14: Info   0.00:00:00.070 Read I2C Control,              WR  (I2CMaster:584)
15: Debug  0.00:00:00.070 Write register 0A: 2C (MemoryAccessStubMCP23017LEDs:421)
16: Info   0.00:00:00.080 IOCON: Bank 0            SEQOP        HAEN ODR INTPOL L (MemoryAccessStubMCP23017LEDs:456)
17: Info   0.00:00:00.080 Write I2C Control, EN       ST   WR  (I2CMaster:605)
18: Info   0.00:00:00.090 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
19: Info   0.00:00:00.090 Write result = 2 (I2CMaster:411)
20: Info   0.00:00:00.090 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
21: Info   0.00:00:00.100 Write I2C Status,          DONE  (I2CMaster:693)
22: Info   0.00:00:00.100 Read I2C Status,              TXE         RXR TXW            (I2CMaster:676)
23: Debug  0.00:00:00.110 Write bytes to 20: 0A 2C, 2 bytes written (MCP23017:112)
24: Info   0.00:00:00.110 Read I2C Control, EN           WR  (I2CMaster:584)
25: Info   0.00:00:00.110 Write I2C Control, EN         CL WR  (I2CMaster:605)
26: Info   0.00:00:00.120 Write I2C Address, 20 (I2CMaster:641)
27: Info   0.00:00:00.120 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
28: Info   0.00:00:00.120 Write I2C Length, 00000001 (I2CMaster:653)
29: Info   0.00:00:00.130 Write FIFO, data 00000012 (I2CMaster:849)
30: Info   0.00:00:00.130 Read I2C Control, EN           WR  (I2CMaster:584)
31: Info   0.00:00:00.130 Write I2C Control, EN       ST   WR  (I2CMaster:605)
32: Info   0.00:00:00.140 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
33: Info   0.00:00:00.140 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
34: Info   0.00:00:00.140 Write I2C Length, 00000001 (I2CMaster:653)
35: Info   0.00:00:00.150 Read I2C Control, EN           WR  (I2CMaster:584)
36: Debug  0.00:00:00.150 Read register 12: 00 (MemoryAccessStubMCP23017LEDs:104)
37: Info   0.00:00:00.150 GPIO A:          (MemoryAccessStubMCP23017LEDs:175)
38: Info   0.00:00:00.160 Write I2C Control, EN       ST   RD  (I2CMaster:605)
39: Info   0.00:00:00.160 Read I2C Status,              TXE RXD         TXW DONE       (I2CMaster:676)
40: Info   0.00:00:00.170 Read I2C Status,              TXE RXD         TXW DONE       (I2CMaster:676)
41: Info   0.00:00:00.170 Read FIFO, data 00000000 (I2CMaster:836)
42: Info   0.00:00:00.170 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
43: Info   0.00:00:00.180 Write I2C Status,          DONE  (I2CMaster:693)
44: Info   0.00:00:00.180 Read I2C Control, EN           RD  (I2CMaster:584)
45: Info   0.00:00:00.180 Write I2C Control, EN         CL RD  (I2CMaster:605)
46: Info   0.00:00:00.190 Write I2C Address, 20 (I2CMaster:641)
47: Info   0.00:00:00.190 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
48: Info   0.00:00:00.190 Write I2C Length, 00000002 (I2CMaster:653)
49: Info   0.00:00:00.200 Write FIFO, data 0000000C (I2CMaster:849)
50: Info   0.00:00:00.200 Write FIFO, data 00000000 (I2CMaster:849)
51: Info   0.00:00:00.200 Read I2C Control, EN           RD  (I2CMaster:584)
52: Debug  0.00:00:00.210 Write register 0C: 00 (MemoryAccessStubMCP23017LEDs:421)
53: Info   0.00:00:00.210 GPPU A: Pin 0 Pin 1 Pin 2 Pin 3 Pin 4 Pin 5 Pin 6 Pin 7  (MemoryAccessStubMCP23017LEDs:621)
54: Info   0.00:00:00.220 Write I2C Control, EN       ST   WR  (I2CMaster:605)
55: Info   0.00:00:00.220 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
56: Info   0.00:00:00.220 Write result = 2 (I2CMaster:411)
57: Info   0.00:00:00.230 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
58: Info   0.00:00:00.230 Write I2C Status,          DONE  (I2CMaster:693)
59: Info   0.00:00:00.240 Read I2C Status,              TXE         RXR TXW            (I2CMaster:676)
60: Debug  0.00:00:00.240 Write bytes to 20: 0C 00, 2 bytes written (MCP23017:112)
61: Info   0.00:00:00.240 Read I2C Control, EN           WR  (I2CMaster:584)
62: Info   0.00:00:00.250 Write I2C Control, EN         CL WR  (I2CMaster:605)
63: Info   0.00:00:00.250 Write I2C Address, 20 (I2CMaster:641)
64: Info   0.00:00:00.250 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
65: Info   0.00:00:00.260 Write I2C Length, 00000002 (I2CMaster:653)
66: Info   0.00:00:00.260 Write FIFO, data 00000000 (I2CMaster:849)
67: Info   0.00:00:00.260 Write FIFO, data 00000000 (I2CMaster:849)
68: Info   0.00:00:00.270 Read I2C Control, EN           WR  (I2CMaster:584)
69: Debug  0.00:00:00.270 Write register 00: 00 (MemoryAccessStubMCP23017LEDs:421)
70: Info   0.00:00:00.270 IODIR A: OOOOOOOO (MemoryAccessStubMCP23017LEDs:468)
71: Info   0.00:00:00.280 Write I2C Control, EN       ST   WR  (I2CMaster:605)
72: Info   0.00:00:00.280 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
73: Info   0.00:00:00.290 Write result = 2 (I2CMaster:411)
74: Info   0.00:00:00.290 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
75: Info   0.00:00:00.290 Write I2C Status,          DONE  (I2CMaster:693)
76: Info   0.00:00:00.300 Read I2C Status,              TXE         RXR TXW            (I2CMaster:676)
77: Debug  0.00:00:00.300 Write bytes to 20: 00 00, 2 bytes written (MCP23017:112)
78: Info   0.00:00:00.300 Read I2C Control, EN           WR  (I2CMaster:584)
79: Info   0.00:00:00.310 Write I2C Control, EN         CL WR  (I2CMaster:605)
80: Info   0.00:00:00.310 Write I2C Address, 20 (I2CMaster:641)
81: Info   0.00:00:00.320 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
82: Info   0.00:00:00.320 Write I2C Length, 00000002 (I2CMaster:653)
83: Info   0.00:00:00.320 Write FIFO, data 0000000D (I2CMaster:849)
84: Info   0.00:00:00.320 Write FIFO, data 00000000 (I2CMaster:849)
85: Info   0.00:00:00.330 Read I2C Control, EN           WR  (I2CMaster:584)
86: Debug  0.00:00:00.330 Write register 0D: 00 (MemoryAccessStubMCP23017LEDs:421)
87: Info   0.00:00:00.340 GPPU B: Pin 0 Pin 1 Pin 2 Pin 3 Pin 4 Pin 5 Pin 6 Pin 7  (MemoryAccessStubMCP23017LEDs:634)
88: Info   0.00:00:00.340 Write I2C Control, EN       ST   WR  (I2CMaster:605)
89: Info   0.00:00:00.340 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
90: Info   0.00:00:00.350 Write result = 2 (I2CMaster:411)
91: Info   0.00:00:00.350 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
92: Info   0.00:00:00.360 Write I2C Status,          DONE  (I2CMaster:693)
93: Info   0.00:00:00.360 Read I2C Status,              TXE         RXR TXW            (I2CMaster:676)
94: Debug  0.00:00:00.360 Write bytes to 20: 0D 00, 2 bytes written (MCP23017:112)
95: Info   0.00:00:00.370 Read I2C Control, EN           WR  (I2CMaster:584)
96: Info   0.00:00:00.370 Write I2C Control, EN         CL WR  (I2CMaster:605)
97: Info   0.00:00:00.370 Write I2C Address, 20 (I2CMaster:641)
98: Info   0.00:00:00.380 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
99: Info   0.00:00:00.380 Write I2C Length, 00000002 (I2CMaster:653)
100: Info   0.00:00:00.380 Write FIFO, data 00000001 (I2CMaster:849)
101: Info   0.00:00:00.390 Write FIFO, data 00000000 (I2CMaster:849)
102: Info   0.00:00:00.390 Read I2C Control, EN           WR  (I2CMaster:584)
103: Debug  0.00:00:00.400 Write register 01: 00 (MemoryAccessStubMCP23017LEDs:421)
104: Info   0.00:00:00.400 IODIR B: OOOOOOOO (MemoryAccessStubMCP23017LEDs:480)
105: Info   0.00:00:00.400 Write I2C Control, EN       ST   WR  (I2CMaster:605)
106: Info   0.00:00:00.410 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
107: Info   0.00:00:00.410 Write result = 2 (I2CMaster:411)
108: Info   0.00:00:00.420 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
109: Info   0.00:00:00.420 Write I2C Status,          DONE  (I2CMaster:693)
110: Info   0.00:00:00.420 Read I2C Status,              TXE         RXR TXW            (I2CMaster:676)
111: Debug  0.00:00:00.430 Write bytes to 20: 01 00, 2 bytes written (MCP23017:112)
112: Info   0.00:00:00.430 Read I2C Control, EN           WR  (I2CMaster:584)
113: Info   0.00:00:00.440 Write I2C Control, EN         CL WR  (I2CMaster:605)
114: Info   0.00:00:00.440 Write I2C Address, 20 (I2CMaster:641)
115: Info   0.00:00:00.440 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
116: Info   0.00:00:00.440 Write I2C Length, 00000002 (I2CMaster:653)
117: Info   0.00:00:00.450 Write FIFO, data 00000012 (I2CMaster:849)
118: Info   0.00:00:00.450 Write FIFO, data 00000055 (I2CMaster:849)
119: Info   0.00:00:00.450 Read I2C Control, EN           WR  (I2CMaster:584)
120: Debug  0.00:00:00.460 Write register 12: 55 (MemoryAccessStubMCP23017LEDs:421)
121: Info   0.00:00:00.460 GPIO A:  X X X X (MemoryAccessStubMCP23017LEDs:492)
122: Info   0.00:00:00.470 Write I2C Control, EN       ST   WR  (I2CMaster:605)
123: Info   0.00:00:00.470 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
124: Info   0.00:00:00.470 Write result = 2 (I2CMaster:411)
125: Info   0.00:00:00.480 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
126: Info   0.00:00:00.480 Write I2C Status,          DONE  (I2CMaster:693)
127: Info   0.00:00:00.490 Read I2C Status,              TXE         RXR TXW            (I2CMaster:676)
128: Debug  0.00:00:00.490 Write bytes to 20: 12 55, 2 bytes written (MCP23017:112)
129: Info   0.00:00:00.490 Read I2C Control, EN           WR  (I2CMaster:584)
130: Info   0.00:00:00.500 Write I2C Control, EN         CL WR  (I2CMaster:605)
131: Info   0.00:00:00.500 Write I2C Address, 20 (I2CMaster:641)
132: Info   0.00:00:00.510 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
133: Info   0.00:00:00.510 Write I2C Length, 00000002 (I2CMaster:653)
134: Info   0.00:00:00.510 Write FIFO, data 00000013 (I2CMaster:849)
135: Info   0.00:00:00.520 Write FIFO, data 000000AA (I2CMaster:849)
136: Info   0.00:00:00.520 Read I2C Control, EN           WR  (I2CMaster:584)
137: Debug  0.00:00:00.520 Write register 13: AA (MemoryAccessStubMCP23017LEDs:421)
138: Info   0.00:00:00.530 GPIO B: X X X X  (MemoryAccessStubMCP23017LEDs:504)
139: Info   0.00:00:00.530 Write I2C Control, EN       ST   WR  (I2CMaster:605)
140: Info   0.00:00:00.530 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
141: Info   0.00:00:00.540 Write result = 2 (I2CMaster:411)
142: Info   0.00:00:00.540 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
143: Info   0.00:00:00.550 Write I2C Status,          DONE  (I2CMaster:693)
144: Info   0.00:00:00.550 Read I2C Status,              TXE         RXR TXW            (I2CMaster:676)
145: Debug  0.00:00:00.550 Write bytes to 20: 13 AA, 2 bytes written (MCP23017:112)
146: Info   0.00:00:01.050 Read I2C Control, EN           WR  (I2CMaster:584)
147: Info   0.00:00:01.060 Write I2C Control, EN         CL WR  (I2CMaster:605)
148: Info   0.00:00:01.060 Write I2C Address, 20 (I2CMaster:641)
149: Info   0.00:00:01.060 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
150: Info   0.00:00:01.060 Write I2C Length, 00000002 (I2CMaster:653)
151: Info   0.00:00:01.070 Write FIFO, data 00000012 (I2CMaster:849)
152: Info   0.00:00:01.070 Write FIFO, data 000000AA (I2CMaster:849)
153: Info   0.00:00:01.070 Read I2C Control, EN           WR  (I2CMaster:584)
154: Debug  0.00:00:01.080 Write register 12: AA (MemoryAccessStubMCP23017LEDs:421)
155: Info   0.00:00:01.080 GPIO A: X X X X  (MemoryAccessStubMCP23017LEDs:492)
156: Info   0.00:00:01.080 Write I2C Control, EN       ST   WR  (I2CMaster:605)
157: Info   0.00:00:01.090 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
158: Info   0.00:00:01.090 Write result = 2 (I2CMaster:411)
159: Info   0.00:00:01.090 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
160: Info   0.00:00:01.100 Write I2C Status,          DONE  (I2CMaster:693)
161: Info   0.00:00:01.100 Read I2C Status,              TXE         RXR TXW            (I2CMaster:676)
162: Debug  0.00:00:01.110 Write bytes to 20: 12 AA, 2 bytes written (MCP23017:112)
163: Info   0.00:00:01.110 Read I2C Control, EN           WR  (I2CMaster:584)
164: Info   0.00:00:01.110 Write I2C Control, EN         CL WR  (I2CMaster:605)
165: Info   0.00:00:01.110 Write I2C Address, 20 (I2CMaster:641)
166: Info   0.00:00:01.120 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
167: Info   0.00:00:01.120 Write I2C Length, 00000002 (I2CMaster:653)
168: Info   0.00:00:01.130 Write FIFO, data 00000013 (I2CMaster:849)
169: Info   0.00:00:01.130 Write FIFO, data 00000055 (I2CMaster:849)
170: Info   0.00:00:01.130 Read I2C Control, EN           WR  (I2CMaster:584)
171: Debug  0.00:00:01.140 Write register 13: 55 (MemoryAccessStubMCP23017LEDs:421)
172: Info   0.00:00:01.140 GPIO B:  X X X X (MemoryAccessStubMCP23017LEDs:504)
173: Info   0.00:00:01.140 Write I2C Control, EN       ST   WR  (I2CMaster:605)
174: Info   0.00:00:01.150 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
175: Info   0.00:00:01.150 Write result = 2 (I2CMaster:411)
176: Info   0.00:00:01.150 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
177: Info   0.00:00:01.160 Write I2C Status,          DONE  (I2CMaster:693)
178: Info   0.00:00:01.160 Read I2C Status,              TXE         RXR TXW            (I2CMaster:676)
179: Debug  0.00:00:01.170 Write bytes to 20: 13 55, 2 bytes written (MCP23017:112)
180: Info   0.00:00:01.670 Read I2C Control, EN           WR  (I2CMaster:584)
181: Info   0.00:00:01.670 Write I2C Control, EN         CL WR  (I2CMaster:605)
182: Info   0.00:00:01.670 Write I2C Address, 20 (I2CMaster:641)
183: Info   0.00:00:01.670 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
184: Info   0.00:00:01.680 Write I2C Length, 00000002 (I2CMaster:653)
185: Info   0.00:00:01.680 Write FIFO, data 00000012 (I2CMaster:849)
186: Info   0.00:00:01.680 Write FIFO, data 00000000 (I2CMaster:849)
187: Info   0.00:00:01.690 Read I2C Control, EN           WR  (I2CMaster:584)
188: Debug  0.00:00:01.690 Write register 12: 00 (MemoryAccessStubMCP23017LEDs:421)
189: Info   0.00:00:01.690 GPIO A:          (MemoryAccessStubMCP23017LEDs:492)
190: Info   0.00:00:01.690 Write I2C Control, EN       ST   WR  (I2CMaster:605)
191: Info   0.00:00:01.700 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
192: Info   0.00:00:01.700 Write result = 2 (I2CMaster:411)
193: Info   0.00:00:01.700 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
194: Info   0.00:00:01.710 Write I2C Status,          DONE  (I2CMaster:693)
195: Info   0.00:00:01.710 Read I2C Status,              TXE         RXR TXW            (I2CMaster:676)
196: Debug  0.00:00:01.720 Write bytes to 20: 12 00, 2 bytes written (MCP23017:112)
197: Info   0.00:00:01.720 Read I2C Control, EN           WR  (I2CMaster:584)
198: Info   0.00:00:01.720 Write I2C Control, EN         CL WR  (I2CMaster:605)
199: Info   0.00:00:01.720 Write I2C Address, 20 (I2CMaster:641)
200: Info   0.00:00:01.730 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
201: Info   0.00:00:01.730 Write I2C Length, 00000002 (I2CMaster:653)
202: Info   0.00:00:01.730 Write FIFO, data 00000013 (I2CMaster:849)
203: Info   0.00:00:01.740 Write FIFO, data 00000000 (I2CMaster:849)
204: Info   0.00:00:01.740 Read I2C Control, EN           WR  (I2CMaster:584)
205: Debug  0.00:00:01.740 Write register 13: 00 (MemoryAccessStubMCP23017LEDs:421)
206: Info   0.00:00:01.750 GPIO B:          (MemoryAccessStubMCP23017LEDs:504)
207: Info   0.00:00:01.750 Write I2C Control, EN       ST   WR  (I2CMaster:605)
208: Info   0.00:00:01.750 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
209: Info   0.00:00:01.760 Write result = 2 (I2CMaster:411)
210: Info   0.00:00:01.760 Read I2C Status,              TXE         RXR TXW DONE       (I2CMaster:676)
211: Info   0.00:00:01.760 Write I2C Status,          DONE  (I2CMaster:693)
212: Info   0.00:00:01.770 Read I2C Status,              TXE         RXR TXW            (I2CMaster:676)
213: Debug  0.00:00:01.770 Write bytes to 20: 13 00, 2 bytes written (MCP23017:112)
214: Info   0.00:00:01.770 Rebooting (main:43)
215: Info   0.00:00:01.780 Reboot (System:154)
216: Info   0.00:00:01.780 InterruptSystem::Shutdown (InterruptHandler:153)
217: Debug  0.00:00:01.780 InterruptSystem::DisableInterrupts (InterruptHandler:166)
```

\todo Continue here

## Scanning for actual device - Step 4 {#TUTORIAL_21_I2C_SCANNING_FOR_ACTUAL_DEVICE___STEP_4}

### Update application code {#TUTORIAL_21_I2C_SCANNING_FOR_ACTUAL_DEVICE___STEP_4_UPDATE_APPLICATION_CODE}

Now let's use the actual device, and see if we can find it.

Update the file code/applications/demo/src/main.cpp.

```cpp
File: code/applications/demo/src/main.cpp
1: #include <baremetal/Format.h>
2: #include <baremetal/I2CMaster.h>
3: #include <baremetal/Logger.h>
4: #include <baremetal/PhysicalGPIOPin.h>
5: #include <baremetal/String.h>
6: #include <baremetal/System.h>
7: #include <baremetal/Timer.h>
8: #include <device/i2c/MCP23017.h>
9: 
10: LOG_MODULE("main");
11: 
12: using namespace baremetal;
13: using namespace device;
14: 
15: int main()
16: {
17:     auto& console = GetConsole();
18:     GetLogger().SetLogLevel(LogSeverity::Debug);
19: 
20:     uint8 busIndex = 1;
21:     uint8 address{ 0x20 };
22:     MCP23017 expander;
23: 
24:     if (!expander.Initialize(busIndex, address))
25:     {
26:         LOG_INFO("Cannot initialize expander");
27:     }
28: 
29:     expander.GetPortAValue();
30:     expander.SetPortADirections(PinDirection::Out);
31:     expander.SetPortBDirections(PinDirection::Out);
32:     expander.SetPortAValue(0x55);
33:     expander.SetPortBValue(0xAA);
34:     Timer::WaitMilliSeconds(500);
35:     expander.SetPortAValue(0xAA);
36:     expander.SetPortBValue(0x55);
37:     Timer::WaitMilliSeconds(500);
38:     expander.SetPortAValue(0x00);
39:     expander.SetPortBValue(0x00);
40: 
41:     LOG_INFO("Rebooting");
42: 
43:     return static_cast<int>(ReturnCode::ExitReboot);
44: }
```

### Configuring, building and debugging : Use I2C stub {#TUTORIAL_21_I2C_SCANNING_FOR_ACTUAL_DEVICE___STEP_4_CONFIGURING_BUILDING_AND_DEBUGGING__USE_I2C_STUB}

We can now configure and build our code, and test.
Notice that the setup of the GPIO pins is logged by the stub.

```text
1: Info   0.00:00:00.020 Baremetal 0.0.1 started on Raspberry Pi 4 Model B (AArch64) using BCM2711 SoC (Logger:96)
2: Info   0.00:00:00.050 Starting up (System:209)
3: Info   0.00:00:00.070 Initialize 20 (MCP23017:79)
4: Info   0.00:00:00.080 Initialize bus 1, mode 0, config 0 (I2CMaster:175)
5: Info   0.00:00:00.100 Set clock 100000 (I2CMaster:218)
6: Info   0.00:00:00.120 Set up bus 1, config 0, base address FE804000 (I2CMaster:201)
7: Info   0.00:00:00.140 Read I2C Control,              WR  (I2CMaster:584)
8: Info   0.00:00:00.150 Write I2C Control,            CL WR  (I2CMaster:605)
9: Info   0.00:00:00.170 Write I2C Address, 20 (I2CMaster:641)
10: Info   0.00:00:00.190 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
11: Info   0.00:00:00.210 Write I2C Length, 00000002 (I2CMaster:653)
12: Info   0.00:00:00.220 Write FIFO, data 0000000A (I2CMaster:849)
13: Info   0.00:00:00.240 Write FIFO, data 0000002C (I2CMaster:849)
14: Info   0.00:00:00.260 Read I2C Control,              WR  (I2CMaster:584)
15: Info   0.00:00:00.270 Write I2C Control, EN       ST   WR  (I2CMaster:605)
16: Info   0.00:00:00.290 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
17: Info   0.00:00:00.310 Write result = 2 (I2CMaster:411)
18: Info   0.00:00:00.330 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
19: Info   0.00:00:00.350 Write I2C Status,          DONE  (I2CMaster:693)
20: Info   0.00:00:00.370 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
21: Debug  0.00:00:00.390 Write bytes to I2C 20 Register 0A: 2C, 2 bytes written (MCP23017:115)
22: Info   0.00:00:00.410 Read I2C Control, EN           WR  (I2CMaster:584)
23: Info   0.00:00:00.430 Write I2C Control, EN         CL WR  (I2CMaster:605)
24: Info   0.00:00:00.450 Write I2C Address, 20 (I2CMaster:641)
25: Info   0.00:00:00.460 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
26: Info   0.00:00:00.480 Write I2C Length, 00000001 (I2CMaster:653)
27: Info   0.00:00:00.500 Write FIFO, data 00000012 (I2CMaster:849)
28: Info   0.00:00:00.510 Read I2C Control, EN           WR  (I2CMaster:584)
29: Info   0.00:00:00.530 Write I2C Control, EN       ST   WR  (I2CMaster:605)
30: Info   0.00:00:00.550 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
31: Info   0.00:00:00.570 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
32: Info   0.00:00:00.590 Write I2C Length, 00000001 (I2CMaster:653)
33: Info   0.00:00:00.610 Read I2C Control, EN           WR  (I2CMaster:584)
34: Info   0.00:00:00.620 Write I2C Control, EN       ST   RD  (I2CMaster:605)
35: Info   0.00:00:00.640 Read I2C Status,                  RXD TXD         DONE       (I2CMaster:676)
36: Info   0.00:00:00.660 Read I2C Status,                  RXD TXD         DONE       (I2CMaster:676)
37: Info   0.00:00:00.680 Read FIFO, data 00000000 (I2CMaster:836)
38: Info   0.00:00:00.700 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
39: Info   0.00:00:00.720 Write I2C Status,          DONE  (I2CMaster:693)
40: Debug  0.00:00:00.740 Read bytes from I2C 20 Register 12: 00, 2 bytes transferred (MCP23017:98)
41: Info   0.00:00:00.760 Read I2C Control, EN           RD  (I2CMaster:584)
42: Info   0.00:00:00.780 Write I2C Control, EN         CL RD  (I2CMaster:605)
43: Info   0.00:00:00.800 Write I2C Address, 20 (I2CMaster:641)
44: Info   0.00:00:00.810 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
45: Info   0.00:00:00.830 Write I2C Length, 00000002 (I2CMaster:653)
46: Info   0.00:00:00.850 Write FIFO, data 0000000C (I2CMaster:849)
47: Info   0.00:00:00.860 Write FIFO, data 00000000 (I2CMaster:849)
48: Info   0.00:00:00.880 Read I2C Control, EN           RD  (I2CMaster:584)
49: Info   0.00:00:00.900 Write I2C Control, EN       ST   WR  (I2CMaster:605)
50: Info   0.00:00:00.920 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
51: Info   0.00:00:00.940 Write result = 2 (I2CMaster:411)
52: Info   0.00:00:00.950 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
53: Info   0.00:00:00.980 Write I2C Status,          DONE  (I2CMaster:693)
54: Info   0.00:00:00.990 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
55: Debug  0.00:00:01.010 Write bytes to I2C 20 Register 0C: 00, 2 bytes written (MCP23017:115)
56: Info   0.00:00:01.040 Read I2C Control, EN           WR  (I2CMaster:584)
57: Info   0.00:00:01.050 Write I2C Control, EN         CL WR  (I2CMaster:605)
58: Info   0.00:00:01.070 Write I2C Address, 20 (I2CMaster:641)
59: Info   0.00:00:01.090 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
60: Info   0.00:00:01.100 Write I2C Length, 00000002 (I2CMaster:653)
61: Info   0.00:00:01.120 Write FIFO, data 00000000 (I2CMaster:849)
62: Info   0.00:00:01.140 Write FIFO, data 00000000 (I2CMaster:849)
63: Info   0.00:00:01.160 Read I2C Control, EN           WR  (I2CMaster:584)
64: Info   0.00:00:01.170 Write I2C Control, EN       ST   WR  (I2CMaster:605)
65: Info   0.00:00:01.190 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
66: Info   0.00:00:01.210 Write result = 2 (I2CMaster:411)
67: Info   0.00:00:01.230 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
68: Info   0.00:00:01.250 Write I2C Status,          DONE  (I2CMaster:693)
69: Info   0.00:00:01.270 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
70: Debug  0.00:00:01.290 Write bytes to I2C 20 Register 00: 00, 2 bytes written (MCP23017:115)
71: Info   0.00:00:01.310 Read I2C Control, EN           WR  (I2CMaster:584)
72: Info   0.00:00:01.330 Write I2C Control, EN         CL WR  (I2CMaster:605)
73: Info   0.00:00:01.350 Write I2C Address, 20 (I2CMaster:641)
74: Info   0.00:00:01.360 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
75: Info   0.00:00:01.380 Write I2C Length, 00000002 (I2CMaster:653)
76: Info   0.00:00:01.400 Write FIFO, data 0000000D (I2CMaster:849)
77: Info   0.00:00:01.410 Write FIFO, data 00000000 (I2CMaster:849)
78: Info   0.00:00:01.430 Read I2C Control, EN           WR  (I2CMaster:584)
79: Info   0.00:00:01.450 Write I2C Control, EN       ST   WR  (I2CMaster:605)
80: Info   0.00:00:01.460 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
81: Info   0.00:00:01.480 Write result = 2 (I2CMaster:411)
82: Info   0.00:00:01.500 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
83: Info   0.00:00:01.520 Write I2C Status,          DONE  (I2CMaster:693)
84: Info   0.00:00:01.540 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
85: Debug  0.00:00:01.560 Write bytes to I2C 20 Register 0D: 00, 2 bytes written (MCP23017:115)
86: Info   0.00:00:01.580 Read I2C Control, EN           WR  (I2CMaster:584)
87: Info   0.00:00:01.600 Write I2C Control, EN         CL WR  (I2CMaster:605)
88: Info   0.00:00:01.620 Write I2C Address, 20 (I2CMaster:641)
89: Info   0.00:00:01.640 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
90: Info   0.00:00:01.650 Write I2C Length, 00000002 (I2CMaster:653)
91: Info   0.00:00:01.670 Write FIFO, data 00000001 (I2CMaster:849)
92: Info   0.00:00:01.690 Write FIFO, data 00000000 (I2CMaster:849)
93: Info   0.00:00:01.700 Read I2C Control, EN           WR  (I2CMaster:584)
94: Info   0.00:00:01.720 Write I2C Control, EN       ST   WR  (I2CMaster:605)
95: Info   0.00:00:01.740 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
96: Info   0.00:00:01.760 Write result = 2 (I2CMaster:411)
97: Info   0.00:00:01.770 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
98: Info   0.00:00:01.800 Write I2C Status,          DONE  (I2CMaster:693)
99: Info   0.00:00:01.810 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
100: Debug  0.00:00:01.840 Write bytes to I2C 20 Register 01: 00, 2 bytes written (MCP23017:115)
101: Info   0.00:00:01.860 Read I2C Control, EN           WR  (I2CMaster:584)
102: Info   0.00:00:01.880 Write I2C Control, EN         CL WR  (I2CMaster:605)
103: Info   0.00:00:01.890 Write I2C Address, 20 (I2CMaster:641)
104: Info   0.00:00:01.910 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
105: Info   0.00:00:01.930 Write I2C Length, 00000002 (I2CMaster:653)
106: Info   0.00:00:01.940 Write FIFO, data 00000012 (I2CMaster:849)
107: Info   0.00:00:01.960 Write FIFO, data 00000055 (I2CMaster:849)
108: Info   0.00:00:01.980 Read I2C Control, EN           WR  (I2CMaster:584)
109: Info   0.00:00:01.990 Write I2C Control, EN       ST   WR  (I2CMaster:605)
110: Info   0.00:00:02.010 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
111: Info   0.00:00:02.030 Write result = 2 (I2CMaster:411)
112: Info   0.00:00:02.050 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
113: Info   0.00:00:02.070 Write I2C Status,          DONE  (I2CMaster:693)
114: Info   0.00:00:02.090 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
115: Debug  0.00:00:02.110 Write bytes to I2C 20 Register 12: 55, 2 bytes written (MCP23017:115)
116: Info   0.00:00:02.130 Read I2C Control, EN           WR  (I2CMaster:584)
117: Info   0.00:00:02.150 Write I2C Control, EN         CL WR  (I2CMaster:605)
118: Info   0.00:00:02.170 Write I2C Address, 20 (I2CMaster:641)
119: Info   0.00:00:02.180 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
120: Info   0.00:00:02.200 Write I2C Length, 00000002 (I2CMaster:653)
121: Info   0.00:00:02.220 Write FIFO, data 00000013 (I2CMaster:849)
122: Info   0.00:00:02.230 Write FIFO, data 000000AA (I2CMaster:849)
123: Info   0.00:00:02.250 Read I2C Control, EN           WR  (I2CMaster:584)
124: Info   0.00:00:02.270 Write I2C Control, EN       ST   WR  (I2CMaster:605)
125: Info   0.00:00:02.290 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
126: Info   0.00:00:02.310 Write result = 2 (I2CMaster:411)
127: Info   0.00:00:02.320 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
128: Info   0.00:00:02.350 Write I2C Status,          DONE  (I2CMaster:693)
129: Info   0.00:00:02.360 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
130: Debug  0.00:00:02.380 Write bytes to I2C 20 Register 13: AA, 2 bytes written (MCP23017:115)
131: Info   0.00:00:02.910 Read I2C Control, EN           WR  (I2CMaster:584)
132: Info   0.00:00:02.920 Write I2C Control, EN         CL WR  (I2CMaster:605)
133: Info   0.00:00:02.940 Write I2C Address, 20 (I2CMaster:641)
134: Info   0.00:00:02.960 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
135: Info   0.00:00:02.970 Write I2C Length, 00000002 (I2CMaster:653)
136: Info   0.00:00:02.990 Write FIFO, data 00000012 (I2CMaster:849)
137: Info   0.00:00:03.010 Write FIFO, data 000000AA (I2CMaster:849)
138: Info   0.00:00:03.020 Read I2C Control, EN           WR  (I2CMaster:584)
139: Info   0.00:00:03.040 Write I2C Control, EN       ST   WR  (I2CMaster:605)
140: Info   0.00:00:03.060 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
141: Info   0.00:00:03.080 Write result = 2 (I2CMaster:411)
142: Info   0.00:00:03.100 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
143: Info   0.00:00:03.120 Write I2C Status,          DONE  (I2CMaster:693)
144: Info   0.00:00:03.140 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
145: Debug  0.00:00:03.160 Write bytes to I2C 20 Register 12: AA, 2 bytes written (MCP23017:115)
146: Info   0.00:00:03.180 Read I2C Control, EN           WR  (I2CMaster:584)
147: Info   0.00:00:03.200 Write I2C Control, EN         CL WR  (I2CMaster:605)
148: Info   0.00:00:03.210 Write I2C Address, 20 (I2CMaster:641)
149: Info   0.00:00:03.230 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
150: Info   0.00:00:03.250 Write I2C Length, 00000002 (I2CMaster:653)
151: Info   0.00:00:03.270 Write FIFO, data 00000013 (I2CMaster:849)
152: Info   0.00:00:03.280 Write FIFO, data 00000055 (I2CMaster:849)
153: Info   0.00:00:03.300 Read I2C Control, EN           WR  (I2CMaster:584)
154: Info   0.00:00:03.320 Write I2C Control, EN       ST   WR  (I2CMaster:605)
155: Info   0.00:00:03.330 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
156: Info   0.00:00:03.350 Write result = 2 (I2CMaster:411)
157: Info   0.00:00:03.370 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
158: Info   0.00:00:03.390 Write I2C Status,          DONE  (I2CMaster:693)
159: Info   0.00:00:03.410 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
160: Debug  0.00:00:03.430 Write bytes to I2C 20 Register 13: 55, 2 bytes written (MCP23017:115)
161: Info   0.00:00:03.950 Read I2C Control, EN           WR  (I2CMaster:584)
162: Info   0.00:00:03.970 Write I2C Control, EN         CL WR  (I2CMaster:605)
163: Info   0.00:00:03.990 Write I2C Address, 20 (I2CMaster:641)
164: Info   0.00:00:04.010 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
165: Info   0.00:00:04.020 Write I2C Length, 00000002 (I2CMaster:653)
166: Info   0.00:00:04.040 Write FIFO, data 00000012 (I2CMaster:849)
167: Info   0.00:00:04.060 Write FIFO, data 00000000 (I2CMaster:849)
168: Info   0.00:00:04.070 Read I2C Control, EN           WR  (I2CMaster:584)
169: Info   0.00:00:04.090 Write I2C Control, EN       ST   WR  (I2CMaster:605)
170: Info   0.00:00:04.110 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
171: Info   0.00:00:04.130 Write result = 2 (I2CMaster:411)
172: Info   0.00:00:04.140 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
173: Info   0.00:00:04.170 Write I2C Status,          DONE  (I2CMaster:693)
174: Info   0.00:00:04.180 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
175: Debug  0.00:00:04.210 Write bytes to I2C 20 Register 12: 00, 2 bytes written (MCP23017:115)
176: Info   0.00:00:04.230 Read I2C Control, EN           WR  (I2CMaster:584)
177: Info   0.00:00:04.250 Write I2C Control, EN         CL WR  (I2CMaster:605)
178: Info   0.00:00:04.260 Write I2C Address, 20 (I2CMaster:641)
179: Info   0.00:00:04.280 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
180: Info   0.00:00:04.300 Write I2C Length, 00000002 (I2CMaster:653)
181: Info   0.00:00:04.310 Write FIFO, data 00000013 (I2CMaster:849)
182: Info   0.00:00:04.330 Write FIFO, data 00000000 (I2CMaster:849)
183: Info   0.00:00:04.350 Read I2C Control, EN           WR  (I2CMaster:584)
184: Info   0.00:00:04.360 Write I2C Control, EN       ST   WR  (I2CMaster:605)
185: Info   0.00:00:04.380 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
186: Info   0.00:00:04.400 Write result = 2 (I2CMaster:411)
187: Info   0.00:00:04.420 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
188: Info   0.00:00:04.440 Write I2C Status,          DONE  (I2CMaster:693)
189: Info   0.00:00:04.460 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
190: Debug  0.00:00:04.480 Write bytes to I2C 20 Register 13: 00, 2 bytes written (MCP23017:115)
191: Info   0.00:00:04.500 Rebooting (main:41)
192: Info   0.00:00:04.520 Read I2C Control, EN           WR  (I2CMaster:584)
193: Info   0.00:00:04.540 Write I2C Control, EN         CL WR  (I2CMaster:605)
194: Info   0.00:00:04.550 Write I2C Address, 20 (I2CMaster:641)
195: Info   0.00:00:04.570 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
196: Info   0.00:00:04.590 Write I2C Length, 00000002 (I2CMaster:653)
197: Info   0.00:00:04.610 Write FIFO, data 0000000C (I2CMaster:849)
198: Info   0.00:00:04.630 Write FIFO, data 00000000 (I2CMaster:849)
199: Info   0.00:00:04.650 Read I2C Control, EN           WR  (I2CMaster:584)
200: Info   0.00:00:04.670 Write I2C Control, EN       ST   WR  (I2CMaster:605)
201: Info   0.00:00:04.690 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
202: Info   0.00:00:04.710 Write result = 2 (I2CMaster:411)
203: Info   0.00:00:04.730 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
204: Info   0.00:00:04.750 Write I2C Status,          DONE  (I2CMaster:693)
205: Info   0.00:00:04.760 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
206: Debug  0.00:00:04.780 Write bytes to I2C 20 Register 0C: 00, 2 bytes written (MCP23017:115)
207: Info   0.00:00:04.800 Read I2C Control, EN           WR  (I2CMaster:584)
208: Info   0.00:00:04.820 Write I2C Control, EN         CL WR  (I2CMaster:605)
209: Info   0.00:00:04.840 Write I2C Address, 20 (I2CMaster:641)
210: Info   0.00:00:04.860 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
211: Info   0.00:00:04.880 Write I2C Length, 00000002 (I2CMaster:653)
212: Info   0.00:00:04.900 Write FIFO, data 00000000 (I2CMaster:849)
213: Info   0.00:00:04.920 Write FIFO, data 000000FF (I2CMaster:849)
214: Info   0.00:00:04.940 Read I2C Control, EN           WR  (I2CMaster:584)
215: Info   0.00:00:04.950 Write I2C Control, EN       ST   WR  (I2CMaster:605)
216: Info   0.00:00:04.970 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
217: Info   0.00:00:04.990 Write result = 2 (I2CMaster:411)
218: Info   0.00:00:05.010 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
219: Info   0.00:00:05.030 Write I2C Status,          DONE  (I2CMaster:693)
220: Info   0.00:00:05.050 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
221: Debug  0.00:00:05.070 Write bytes to I2C 20 Register 00: FF, 2 bytes written (MCP23017:115)
222: Info   0.00:00:05.090 Read I2C Control, EN           WR  (I2CMaster:584)
223: Info   0.00:00:05.100 Write I2C Control, EN         CL WR  (I2CMaster:605)
224: Info   0.00:00:05.120 Write I2C Address, 20 (I2CMaster:641)
225: Info   0.00:00:05.140 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
226: Info   0.00:00:05.160 Write I2C Length, 00000002 (I2CMaster:653)
227: Info   0.00:00:05.180 Write FIFO, data 0000000D (I2CMaster:849)
228: Info   0.00:00:05.200 Write FIFO, data 00000000 (I2CMaster:849)
229: Info   0.00:00:05.220 Read I2C Control, EN           WR  (I2CMaster:584)
230: Info   0.00:00:05.240 Write I2C Control, EN       ST   WR  (I2CMaster:605)
231: Info   0.00:00:05.250 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
232: Info   0.00:00:05.270 Write result = 2 (I2CMaster:411)
233: Info   0.00:00:05.290 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
234: Info   0.00:00:05.310 Write I2C Status,          DONE  (I2CMaster:693)
235: Info   0.00:00:05.330 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
236: Debug  0.00:00:05.350 Write bytes to I2C 20 Register 0D: 00, 2 bytes written (MCP23017:115)
237: Info   0.00:00:05.370 Read I2C Control, EN           WR  (I2CMaster:584)
238: Info   0.00:00:05.390 Write I2C Control, EN         CL WR  (I2CMaster:605)
239: Info   0.00:00:05.410 Write I2C Address, 20 (I2CMaster:641)
240: Info   0.00:00:05.430 Write I2C Status, CLKT ERR DONE  (I2CMaster:693)
241: Info   0.00:00:05.440 Write I2C Length, 00000002 (I2CMaster:653)
242: Info   0.00:00:05.460 Write FIFO, data 00000001 (I2CMaster:849)
243: Info   0.00:00:05.480 Write FIFO, data 000000FF (I2CMaster:849)
244: Info   0.00:00:05.500 Read I2C Control, EN           WR  (I2CMaster:584)
245: Info   0.00:00:05.520 Write I2C Control, EN       ST   WR  (I2CMaster:605)
246: Info   0.00:00:05.540 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
247: Info   0.00:00:05.560 Write result = 2 (I2CMaster:411)
248: Info   0.00:00:05.580 Read I2C Status,              TXE     TXD         DONE       (I2CMaster:676)
249: Info   0.00:00:05.600 Write I2C Status,          DONE  (I2CMaster:693)
250: Info   0.00:00:05.620 Read I2C Status,              TXE     TXD                    (I2CMaster:676)
251: Debug  0.00:00:05.640 Write bytes to I2C 20 Register 01: FF, 2 bytes written (MCP23017:115)
252: Info   0.00:00:05.650 Reboot (System:154)
253: Info   0.00:00:05.670 InterruptSystem::Shutdown (InterruptHandler:153)
254: Debug  0.00:00:05.690 InterruptSystem::DisableInterrupts (InterruptHandler:166)
```

- Line 3-6: The I2C Master is initialized
- Line 7-21: The MCP23017 class `Initialize()` method writes 0x2C to the MCP123017 IOCON register
- Line 22-40: We read the MCP23017 GPIOA register.
This is done by first writing 1 byte (the register number), and then reading one byte
- Line 41-55: We write 0x00 to the MCP23017 GPPUA register.
This disables the pull up resistors for port A
- Line 56-70: We write 0x00 to the MCP23017 IODIRA register.
This sets all pins on port A to output
- Line 71-85: We write 0x00 to the MCP23017 GPPUB register.
This disables the pull up resistors for port B
- Line 86-100: We write 0x00 to the MCP23017 IODIRB register.
This sets all pins on port B to output
- Line 101-115: We write 0x55 to the MCP23017 GPIOA register.
This sets the pin values on port A.
This results in the first image below
- Line 116-130: We write 0xAA to the MCP23017 GPIOB register.
This sets the pin values on port B
- Line 131-145: We write 0xAA to the MCP23017 GPIOA register.
This sets the pin values on port A.
This results in the second image below
- Line 146-160: We write 0x55 to the MCP23017 GPIOB register.
This sets the pin values on port B
- Line 161-175: We write 0x00 to the MCP23017 GPIOA register.
This sets the pin values on port A.
This results in the third image below
- Line 176-190: We write 0x00 to the MCP23017 GPIOB register.
This sets the pin values on port B
- Line 191-206: We write 0x00 to the MCP23017 GPPUA register.
This disables the pull up resistors for port A
- Line 207-221: We write 0xFF to the MCP23017 IODIRA register.
This sets all pins on port A to input
- Line 222-236: We write 0x00 to the MCP23017 GPPUB register.
This disables the pull up resistors for port B
- Line 237-251: We write 0xFF to the MCP23017 IODIRB register.
This sets all pins on port B to input

<img src="images/Tutorial_21-MCP23017-1.jpg"  alt="I2C bus" width="600"/>

<img src="images/Tutorial_21-MCP23017-2.jpg"  alt="I2C bus" width="600"/>

<img src="images/Tutorial_21-MCP23017-3.jpg"  alt="I2C bus" width="600"/>


Next: [22-i2s](22-i2s.md)
