# Tutorial 21: I2C {#TUTORIAL_21_I2C}

@tableofcontents

## New tutorial setup {#TUTORIAL_21_I2C_NEW_TUTORIAL_SETUP}

As in the previous tutorial, you will find the code integrated into the CMake structure, in `tutorial/21-i2c`.
In the same way, the project names are adapted to make sure there are no conflicts.

### Tutorial results {#TUTORIAL_21_I2C_NEW_TUTORIAL_SETUP_TUTORIAL_RESULTS}

This tutorial will result in (next to the main project structure):
- a library `output/Debug/lib/baremetal-21.a`
- a library `output/Debug/lib/device-21.a`
- a library `output/Debug/lib/stdlib-21.a`
- an application `output/Debug/bin/21-i2c.elf`
- an image in `deploy/Debug/21-i2c-image`

## What is I2C {#TUTORIAL_21_I2C_WHAT_IS_I2C}

I2C (called IIC or I-square-C) is s very simple serial bus meant for communication on short distance, initially meant for IC to IC communication.
Hence its name `Inter IC Communication` or IIC (I2C).
The bus has a clock signal, named SCL, and a data signal, called SDA.

<img src="images/i2c-single-master-single-slave.png"  alt="I2C bus" width="600"/>

I2C uses the concept of a master and slave. The master is in control of the clock, the slave listens to it.
However the roles of master and slave can be reversed, and there can be multiple masters and slaves, however only one master can exist at any time.
Both SCL and SDA are pulled up with a resistor, meaning the idle state for each signal is high or `1`.

I2C was initially intended to run at a 100 KHz clock, but nowadays can also be run at 400 KHz, 1 MHz, 1.7MHz, 3.4 MHz and 5 MHz.
The baseline is that the bus can run at the highest speed supported by all devices on the bus.

I will not go into all the details of the protocol, as there is a lot of information available, e.g. [Wikipedia](https://en.wikipedia.org/wiki/I%C2%B2C).

However, a few things need to be said to make things clear.

If a master wants to read or write a device, it will create a so-called `start condition`. It will then send the address, which will be acknowldged by the device being addressed, if any.
Then either the master (write) or the addressed device (read) will send data, until a `stop condition` is created.
Whether a read or write operation takes place is determined by the R/<u>W</u> bit (Read = 1, Write = 0).
The data sent can be any number of bytes, although most devices only support blocks of up to 256 bytes.
Addresses in I2C are either 7 or 10 bits, by enforcing 10 bit address to be using a special pattern:

| Address  | Bit 6 | Bit 5 | Bit 4 | Bit 3 | Bit 2 | Bit 1 | Bit 0 | Address | 
|----------|-------|-------|-------|-------|-------|-------|-------|---------|
| 7 bit    |    A6 |    A5 |    A4 |    A3 |    A2 |    A1 |    A0 | Bit A2-A0 are often selectable in HW, bit A6-A3 are fixed by the device
| reserved |     0 |     0 |     0 |     0 |     X |     X |     X | Reserved addresses, not usable by devices
| 10 bit   |     1 |     1 |     1 |     1 |     0 |    A9 |    A8 | Special pattern A6-A2 = 11110 means 10 bit address, another byte with A7-A0 follows

The way data is read or written in I2C is shown in the image below.

<img src="images/i2c-protocol.png"  alt="I2C I2C message protocol" width="800"/>

Slaves each have a fixed address, which is preprogrammed.

In the original protocol, there were 7 address bits, meaning 128 different addresses, however the first and last 8 addresses in this range are reserved, limiting the number of usable addresses to 112.
The 10 bit address mode, which would mean 1024 addresses, again reserves the same 16 addresses, so the maximum number of different addresses in this case is 1008.
Data is sent or received in chunks of 8 bits, but multiple such chuncks can be sent or received in one message.

Important is the <u>ACK</u>/NACK bit, which is a pause between two bytes. By pulling the ACK bit low, the slave device acknowledges receiving.
If at any time the ack is not given, communication stops.
When scanning for devices on a bus, this is the way to determine whether a device is present at the specified address.

There are many devices on the market supporting I2C, ranging from sensors, EEPROMs, memory modules, real time clocks, hardware monitors, actuators, DACs and ADCs, to displays.
The EDID (Extended Display Identification Data) such as used by HDMI is also I2C based.

Due to the fact that a chip has a preprogrammed address, how do we then support multiple of the same devices?
The answer is simple, we use a multiplexer, which splits up in mostly 8 new busses. One such multiplexer is [TCA9548](pdf/tca9548a.pdf).

Many devices however have extra pins to set the address within a subset, allowing multiple of the same devices to be addressed in parallel.

There are also devices that allow for direct input and output, so GPIO pins can also be controlled through I2C devices. Two such devices are [MCP23008](pdf/mcp23008.pdf) and [MCP23017](pdf/mcp23017.pdf).

It would be nice to be able to control a simple 2 x 20 character display this way, however, as the programming of this device is quite some work, we'll postpone that until later this tutorial.
We'll start with a simple device, the MCP23017, and control some LEDs from it.

We'll use a circuit as depicted in [this diagram](pdf/MCP23017_LEDs.pdf). You can build your own if you like, if not, just try to follow the tutorial, and look forward to where we will use an off-the-shelf LCD display.

Raspberry Pi supports 7 and 10 bit addresses, and between 2 and 7 I2C buses. The speed supported is either 100 Kbps, 400 Kbps or 1 Mbps.
See [Raspberry Pi I2C](#RASPBERRY_PI_I2C) for more information.
        
## Basic I2C functionality - faking it - Step 1 {#TUTORIAL_21_I2C_BASIC_I2C_FUNCTIONALITY___FAKING_IT___STEP_1}

Before really attaching any devices, let's see if we can fake the I2C functionality, so we can debug our code a bit.
We'll do this by creating a IMemoryAccess instance that handling the access to I2C registers.
As we'll see, due to the fact that we also need to program GPIO to correctly assign the I2C pins, we'll also be creating a fake IMemoryAccess instance for GPIO.

### BCMRegisters.h {#TUTORIAL_21_I2C_BASIC_I2C_FUNCTIONALITY___FAKING_IT___STEP_1_BCMREGISTERSH}

First, we need to define register for the I2C devices.

Update the file `code/libraries/baremetal/include/baremetal/BCMRegisters.h`

```cpp
File: code/libraries/baremetal/include/baremetal/BCMRegisters.h
...
284: //---------------------------------------------
285: // Raspberry Pi GPIO
286: //---------------------------------------------
287: 
288: /// @brief Raspberry Pi GPIO registers base address. See @ref RASPBERRY_PI_GPIO
289: #define RPI_GPIO_BASE                   RPI_BCM_IO_BASE + 0x00200000
290: /// @brief Raspberry Pi GPIO function select register 0 (GPIO 0..9) (3 bits / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
291: #define RPI_GPIO_GPFSEL0_OFFSET         0x00000000
292: /// @brief Raspberry Pi GPIO function select register 0 (GPIO 0..9) (3 bits / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
293: #define RPI_GPIO_GPFSEL0                reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPFSEL0_OFFSET)
294: /// @brief Raspberry Pi GPIO function select register 1 (GPIO 10..19) (3 bits / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
295: #define RPI_GPIO_GPFSEL1_OFFSET         0x00000004
296: /// @brief Raspberry Pi GPIO function select register 1 (GPIO 10..19) (3 bits / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
297: #define RPI_GPIO_GPFSEL1                reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPFSEL1_OFFSET)
298: /// @brief Raspberry Pi GPIO function select register 2 (GPIO 20..29) (3 bits / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
299: #define RPI_GPIO_GPFSEL2_OFFSET         0x00000008
300: /// @brief Raspberry Pi GPIO function select register 2 (GPIO 20..29) (3 bits / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
301: #define RPI_GPIO_GPFSEL2                reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPFSEL2_OFFSET)
302: /// @brief Raspberry Pi GPIO function select register 3 (GPIO 30..39) (3 bits / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
303: #define RPI_GPIO_GPFSEL3_OFFSET         0x0000000C
304: /// @brief Raspberry Pi GPIO function select register 3 (GPIO 30..39) (3 bits / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
305: #define RPI_GPIO_GPFSEL3                reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPFSEL3_OFFSET)
306: /// @brief Raspberry Pi GPIO function select register 4 (GPIO 40..49) (3 bits / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
307: #define RPI_GPIO_GPFSEL4_OFFSET         0x00000010
308: /// @brief Raspberry Pi GPIO function select register 3 (GPIO 40..49) (3 bits / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
309: #define RPI_GPIO_GPFSEL4                reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPFSEL4_OFFSET)
310: /// @brief Raspberry Pi GPIO function select register 5 (GPIO 50..53) (3 bits / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
311: #define RPI_GPIO_GPFSEL5_OFFSET         0x00000014
312: /// @brief Raspberry Pi GPIO function select register 5 (GPIO 50..59) (3 bits / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
313: #define RPI_GPIO_GPFSEL5                reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPFSEL5_OFFSET)
314: /// @brief Raspberry Pi GPIO set register 0 (GPIO 0..31) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
315: #define RPI_GPIO_GPSET0_OFFSET          0x0000001C
316: /// @brief Raspberry Pi GPIO set register 0 (GPIO 0..31) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
317: #define RPI_GPIO_GPSET0                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPSET0_OFFSET)
318: /// @brief Raspberry Pi GPIO set register 1 (GPIO 32..53) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
319: #define RPI_GPIO_GPSET1_OFFSET          0x00000020
320: /// @brief Raspberry Pi GPIO set register 1 (GPIO 32..53) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
321: #define RPI_GPIO_GPSET1                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPSET1_OFFSET)
322: /// @brief Raspberry Pi GPIO clear register 0 (GPIO 0..31) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
323: #define RPI_GPIO_GPCLR0_OFFSET          0x00000028
324: /// @brief Raspberry Pi GPIO clear register 0 (GPIO 0..31) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
325: #define RPI_GPIO_GPCLR0                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPCLR0_OFFSET)
326: /// @brief Raspberry Pi GPIO clear register 1 (GPIO 32..53) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
327: #define RPI_GPIO_GPCLR1_OFFSET          0x0000002C
328: /// @brief Raspberry Pi GPIO clear register 1 (GPIO 32..53) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
329: #define RPI_GPIO_GPCLR1                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPCLR1_OFFSET)
330: /// @brief Raspberry Pi GPIO level register 0 (GPIO 0..31) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
331: #define RPI_GPIO_GPLEV0_OFFSET          0x00000034
332: /// @brief Raspberry Pi GPIO level register 0 (GPIO 0..31) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
333: #define RPI_GPIO_GPLEV0                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPLEV0_OFFSET)
334: /// @brief Raspberry Pi GPIO level register 1 (GPIO 32..53) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
335: #define RPI_GPIO_GPLEV1_OFFSET          0x00000038
336: /// @brief Raspberry Pi GPIO level register 1 (GPIO 32..53) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
337: #define RPI_GPIO_GPLEV1                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPLEV1_OFFSET)
338: /// @brief Raspberry Pi GPIO event detected register 0 (GPIO 0..31) (1 bit / GPIO) (R) offset. See @ref RASPBERRY_PI_GPIO
339: #define RPI_GPIO_GPEDS0_OFFSET          0x00000040
340: /// @brief Raspberry Pi GPIO event detected register 0 (GPIO 0..31) (1 bit / GPIO) (R). See @ref RASPBERRY_PI_GPIO
341: #define RPI_GPIO_GPEDS0                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPEDS0_OFFSET)
342: /// @brief Raspberry Pi GPIO event detected register 1 (GPIO 32..53) (1 bit / GPIO) (R) offset. See @ref RASPBERRY_PI_GPIO
343: #define RPI_GPIO_GPEDS1_OFFSET          0x00000044
344: /// @brief Raspberry Pi GPIO event detected register 1 (GPIO 32..53) (1 bit / GPIO) (R). See @ref RASPBERRY_PI_GPIO
345: #define RPI_GPIO_GPEDS1                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPEDS1_OFFSET)
346: /// @brief Raspberry Pi GPIO rising edge detect enable register 0 (GPIO 0..31) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
347: #define RPI_GPIO_GPREN0_OFFSET          0x0000004C
348: /// @brief Raspberry Pi GPIO rising edge detect enable register 0 (GPIO 0..31) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
349: #define RPI_GPIO_GPREN0                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPREN0_OFFSET)
350: /// @brief Raspberry Pi GPIO rising edge detect enable register 1 (GPIO 32..53) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
351: #define RPI_GPIO_GPREN1_OFFSET          0x00000050
352: /// @brief Raspberry Pi GPIO rising edge detect enable register 1 (GPIO 32..53) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
353: #define RPI_GPIO_GPREN1                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPREN1_OFFSET)
354: /// @brief Raspberry Pi GPIO falling edge detect enable register 0 (GPIO 0..31) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
355: #define RPI_GPIO_GPFEN0_OFFSET          0x00000058
356: /// @brief Raspberry Pi GPIO falling edge detect enable register 0 (GPIO 0..31) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
357: #define RPI_GPIO_GPFEN0                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPFEN0_OFFSET)
358: /// @brief Raspberry Pi GPIO falling edge detect enable register 1 (GPIO 32..53) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
359: #define RPI_GPIO_GPFEN1_OFFSET          0x0000005C
360: /// @brief Raspberry Pi GPIO falling edge detect enable register 1 (GPIO 32..53) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
361: #define RPI_GPIO_GPFEN1                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPFEN1_OFFSET)
362: /// @brief Raspberry Pi GPIO high level detect enable register 0 (GPIO 0..31) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
363: #define RPI_GPIO_GPHEN0_OFFSET          0x00000064
364: /// @brief Raspberry Pi GPIO high level detect enable register 0 (GPIO 0..31) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
365: #define RPI_GPIO_GPHEN0                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPHEN0_OFFSET)
366: /// @brief Raspberry Pi GPIO high level detect enable register 1 (GPIO 32..53) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
367: #define RPI_GPIO_GPHEN1_OFFSET          0x00000068
368: /// @brief Raspberry Pi GPIO high level detect enable register 1 (GPIO 32..53) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
369: #define RPI_GPIO_GPHEN1                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPHEN1_OFFSET)
370: /// @brief Raspberry Pi GPIO low level detect enable register 0 (GPIO 0..31) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
371: #define RPI_GPIO_GPLEN0_OFFSET          0x00000070
372: /// @brief Raspberry Pi GPIO low level detect enable register 0 (GPIO 0..31) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
373: #define RPI_GPIO_GPLEN0                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPLEN0_OFFSET)
374: /// @brief Raspberry Pi GPIO low level detect enable register 1 (GPIO 32..53) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
375: #define RPI_GPIO_GPLEN1_OFFSET          0x00000074
376: /// @brief Raspberry Pi GPIO low level detect enable register 1 (GPIO 32..53) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
377: #define RPI_GPIO_GPLEN1                 reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPLEN1_OFFSET)
378: /// @brief Raspberry Pi GPIO asynchronous rising edge detect enable register 0 (GPIO 0..31) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
379: #define RPI_GPIO_GPAREN0_OFFSET         0x0000007C
380: /// @brief Raspberry Pi GPIO asynchronous rising edge detect enable register 0 (GPIO 0..31) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
381: #define RPI_GPIO_GPAREN0                reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPAREN0_OFFSET)
382: /// @brief Raspberry Pi GPIO asynchronous rising edge detect enable register 1 (GPIO 32..53) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
383: #define RPI_GPIO_GPAREN1_OFFSET         0x00000080
384: /// @brief Raspberry Pi GPIO asynchronous rising edge detect enable register 1 (GPIO 32..53) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
385: #define RPI_GPIO_GPAREN1                reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPAREN1_OFFSET)
386: /// @brief Raspberry Pi GPIO asynchronous falling edge detect enable register 0 (GPIO 0..31) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
387: #define RPI_GPIO_GPAFEN0_OFFSET         0x00000088
388: /// @brief Raspberry Pi GPIO asynchronous falling edge detect enable register 0 (GPIO 0..31) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
389: #define RPI_GPIO_GPAFEN0                reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPAFEN0_OFFSET)
390: /// @brief Raspberry Pi GPIO asynchronous fallign edge detect enable register 1 (GPIO 32..53) (1 bit / GPIO) (R/W) offset. See @ref RASPBERRY_PI_GPIO
391: #define RPI_GPIO_GPAFEN1_OFFSET         0x0000008C
392: /// @brief Raspberry Pi GPIO asynchronous fallign edge detect enable register 1 (GPIO 32..53) (1 bit / GPIO) (R/W). See @ref RASPBERRY_PI_GPIO
393: #define RPI_GPIO_GPAFEN1                reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPAFEN1_OFFSET)
394: #if BAREMETAL_RPI_TARGET == 3
395: /// @brief Raspberry Pi GPIO pull up/down mode register (2 bits) (R/W) offset. Raspberry Pi 3 only. See @ref RASPBERRY_PI_GPIO
396: #define RPI_GPIO_GPPUD_OFFSET           0x00000094
397: /// @brief Raspberry Pi GPIO pull up/down mode register (2 bits) (R/W). Raspberry Pi 3 only. See @ref RASPBERRY_PI_GPIO
398: #define RPI_GPIO_GPPUD                  reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPPUD_OFFSET)
399: /// @brief Raspberry Pi GPIO pull up/down clock register 0 (GPIO 0..31) (1 bit / GPIO) (R/W) offset. Raspberry Pi 3 only. See @ref RASPBERRY_PI_GPIO
400: #define RPI_GPIO_GPPUDCLK0_OFFSET       0x00000098
401: /// @brief Raspberry Pi GPIO pull up/down clock register 0 (GPIO 0..31) (1 bit / GPIO) (R/W). Raspberry Pi 3 only. See @ref RASPBERRY_PI_GPIO
402: #define RPI_GPIO_GPPUDCLK0              reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPPUDCLK0_OFFSET)
403: /// @brief Raspberry Pi GPIO pull up/down clock register 1 (GPIO 32..53) (1 bit / GPIO) (R/W) offset. Raspberry Pi 3 only. See @ref RASPBERRY_PI_GPIO
404: #define RPI_GPIO_GPPUDCLK1_OFFSET       0x0000009C
405: /// @brief Raspberry Pi GPIO pull up/down clock register 1 (GPIO 32..53) (1 bit / GPIO) (R/W). Raspberry Pi 3 only. See @ref RASPBERRY_PI_GPIO
406: #define RPI_GPIO_GPPUDCLK1              reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPPUDCLK1_OFFSET)
407: #else // RPI target 4 or 5
408: /// @brief Raspberry Pi GPIO pull up/down pin multiplexer register offset. Undocumented
409: #define RPI_GPIO_GPPINMUXSD_OFFSET      0x000000D0
410: /// @brief Raspberry Pi GPIO pull up/down pin multiplexer register. Undocumented
411: #define RPI_GPIO_GPPINMUXSD             reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPPINMUXSD_OFFSET)
412: /// @brief Raspberry Pi GPIO pull up/down mode register 0 (GPIO 0..15) (2 bits / GPIO) (R/W) offset. Raspberry Pi 4/5 only. See @ref RASPBERRY_PI_GPIO
413: #define RPI_GPIO_GPPUPPDN0_OFFSET       0x000000E4
414: /// @brief Raspberry Pi GPIO pull up/down mode register 0 (GPIO 0..15) (2 bits / GPIO) (R/W). Raspberry Pi 4/5 only. See @ref RASPBERRY_PI_GPIO
415: #define RPI_GPIO_GPPUPPDN0              reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPPUPPDN0_OFFSET)
416: /// @brief Raspberry Pi GPIO pull up/down mode register 1 (GPIO 16..31) (2 bits / GPIO) (R/W) offset. Raspberry Pi 4/5 only. See @ref RASPBERRY_PI_GPIO
417: #define RPI_GPIO_GPPUPPDN1_OFFSET       0x000000E8
418: /// @brief Raspberry Pi GPIO pull up/down mode register 1 (GPIO 16..31) (2 bits / GPIO) (R/W). Raspberry Pi 4/5 only. See @ref RASPBERRY_PI_GPIO
419: #define RPI_GPIO_GPPUPPDN1              reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPPUPPDN1_OFFSET)
420: /// @brief Raspberry Pi GPIO pull up/down mode register 2 (GPIO 32..47) (2 bits / GPIO) (R/W) offset. Raspberry Pi 4/5 only. See @ref RASPBERRY_PI_GPIO
421: #define RPI_GPIO_GPPUPPDN2_OFFSET       0x000000EC
422: /// @brief Raspberry Pi GPIO pull up/down mode register 2 (GPIO 32..47) (2 bits / GPIO) (R/W). Raspberry Pi 4/5 only. See @ref RASPBERRY_PI_GPIO
423: #define RPI_GPIO_GPPUPPDN2              reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPPUPPDN2_OFFSET)
424: /// @brief Raspberry Pi GPIO pull up/down mode register 3 (GPIO 48..53) (2 bits / GPIO) (R/W) offset. Raspberry Pi 4/5 only. See @ref RASPBERRY_PI_GPIO
425: #define RPI_GPIO_GPPUPPDN3_OFFSET       0x000000F0
426: /// @brief Raspberry Pi GPIO pull up/down mode register 3 (GPIO 48..53) (2 bits / GPIO) (R/W). Raspberry Pi 4/5 only. See @ref RASPBERRY_PI_GPIO
427: #define RPI_GPIO_GPPUPPDN3              reinterpret_cast<regaddr>(RPI_GPIO_BASE + RPI_GPIO_GPPUPPDN3_OFFSET)
428: #endif
429: /// @brief End of GPIO register region
430: #define RPI_GPIO_END                    RPI_GPIO_BASE + 0x00000100
431: 
432: //---------------------------------------------
433: // Raspberry Pi UART0
434: //---------------------------------------------
...
469: //---------------------------------------------
470: // Raspberry Pi I2C
471: //---------------------------------------------
472: 
473: /// @brief Raspberry Pi I2C bus 0 registers base address.
474: #define RPI_I2C0_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205000)
475: /// @brief Raspberry Pi I2C bus 1 registers base address.
476: #define RPI_I2C1_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00804000)
477: 
478: #if BAREMETAL_RPI_TARGET == 3
479: /// @brief Raspberry Pi I2C bus 2 registers base address.
480: #define RPI_I2C2_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00805000)
481: #elif BAREMETAL_RPI_TARGET == 4
482: /// @brief Raspberry Pi I2C bus 3 registers base address.
483: #define RPI_I2C3_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205600)
484: /// @brief Raspberry Pi I2C bus 4 registers base address.
485: #define RPI_I2C4_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205800)
486: /// @brief Raspberry Pi I2C bus 5 registers base address.
487: #define RPI_I2C5_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205A80)
488: /// @brief Raspberry Pi I2C bus 6 registers base address.
489: #define RPI_I2C6_BASE                 reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205C00)
490: #endif
491: 
492: /// @brief Raspberry Pi I2C control register (R/W) offset relative to RPI_I2Cx_BASE
493: #define RPI_I2C_C_OFFSET              0x00000000
494: /// @brief Disable BSC (I2C) controller
495: #define RPI_I2C_C_DISABLE             BIT0(15)
496: /// @brief Enable BSC (I2C) controller
497: #define RPI_I2C_C_ENABLE              BIT1(15)
498: /// @brief Disable interrupt on receive 3/4 full
499: #define RPI_I2C_C_INTR_DISABLE        BIT0(10)
500: /// @brief Enable interrupt on receive 3/4 full
501: #define RPI_I2C_C_INTR_ENABLE         BIT1(10)
502: /// @brief Disable interrupt on transmit 3/4 empty
503: #define RPI_I2C_C_INTT_DISABLE        BIT0(9)
504: /// @brief Enable interrupt on receive 3/4 empty
505: #define RPI_I2C_C_INTT_ENABLE         BIT1(9)
506: /// @brief Disable interrupt on transfer done
507: #define RPI_I2C_C_INTD_DISABLE        BIT0(8)
508: /// @brief Enable interrupt on transfer done
509: #define RPI_I2C_C_INTD_ENABLE         BIT1(8)
510: /// @brief Transfer start (start condition)
511: #define RPI_I2C_C_ST                  BIT1(7)
512: /// @brief Clear FIFO
513: #define RPI_I2C_C_CLEAR               BITS(4, 5)
514: /// @brief Write transfer
515: #define RPI_I2C_C_WRITE               BIT0(0)
516: /// @brief Read transfer
517: #define RPI_I2C_C_READ                BIT1(0)
518: 
519: /// @brief Raspberry Pi I2C status register (R/W) offset relative to RPI_I2Cx_BASE
520: #define RPI_I2C_S_OFFSET              0x00000004
521: /// @brief Clock stretch timeout
522: #define RPI_I2C_S_CLKT                BIT1(9)
523: /// @brief ACK error
524: #define RPI_I2C_S_ERR                 BIT1(8)
525: /// @brief Receive FIFO full
526: #define RPI_I2C_S_RXF                 BIT1(7)
527: /// @brief Transmit FIFO empty
528: #define RPI_I2C_S_TXE                 BIT1(6)
529: /// @brief Receive FIFO has data
530: #define RPI_I2C_S_RXD                 BIT1(5)
531: /// @brief Transmit FIFO has space
532: #define RPI_I2C_S_TXD                 BIT1(4)
533: /// @brief Receive FIFO is 3/4 full
534: #define RPI_I2C_S_RXR                 BIT1(3)
535: /// @brief Transmit FIFO is 1/4 full
536: #define RPI_I2C_S_TXW                 BIT1(2)
537: /// @brief Transfer is done
538: #define RPI_I2C_S_DONE                BIT1(1)
539: /// @brief Transfer is active
540: #define RPI_I2C_S_TA                  BIT1(0)
541: 
542: /// /// @brief Raspberry Pi I2C data length register (R/W) offset relative to RPI_I2Cx_BASE
543: #define RPI_I2C_DLEN_OFFSET           0x00000008
544: /// @brief Raspberry Pi I2C slave address register (R/W) offset relative to RPI_I2Cx_BASE
545: #define RPI_I2C_A_OFFSET              0x0000000C
546: /// @brief Raspberry Pi I2C data FIFO register (R/W) offset relative to RPI_I2Cx_BASE
547: #define RPI_I2C_FIFO_OFFSET           0x00000010
548: /// @brief Raspberry Pi I2C clock divider register (R/W) offset relative to RPI_I2Cx_BASE
549: #define RPI_I2C_DIV_OFFSET            0x00000014
550: /// @brief Raspberry Pi I2C data delay register (R/W) offset relative to RPI_I2Cx_BASE
551: #define RPI_I2C_DEL_OFFSET            0x00000018
552: /// @brief Raspberry Pi I2C clock stretch timeout register (R/W) offset relative to RPI_I2Cx_BASE
553: #define RPI_I2C_CLKT_OFFSET           0x0000001C
554: /// @brief Raspberry Pi I2C register address from base address and offset
555: #define RPI_I2C_REG_ADDRESS(base, offset)   reinterpret_cast<regaddr>((base) + (offset))
556: 
```

- Line 291-428: We add a definition for the relative offset of each GPIO register, and use this to calculate the actual address.
We can later use the offset
- Line 430: We add a definition `RPI_GPIO_END` to denote the end of the GPIO registers.
We'll use this later to distinguish between I2C and GPIO registers
- Line 473-490: We define the base address for each I2C bus, depending on the model.
Raspberry Pi 3 has buses 0, 1 and 2, Raspberry Pi has bus 0, 1, 3, 4, 5, 6
- Line 493: We define the offset relative to the base address for the Control Register.
The actual address is calculated using the `RPI_I2C_REG_ADDRESS` macro
- Line 494-517: We define the bits for the Control Register.
Notice that some bits are defined as BIT0, basically meaning the bit has value 0, defined for clarity
- Line 520: We define the offset relative to the base address for the Status Register.
The actual address is calculated using the `RPI_I2C_REG_ADDRESS` macro
- Line 521-540: We define the bits for the Status Register
- Line 543: We define the offset relative to the base address for the Data Length Register
- Line 545: We define the offset relative to the base address for the Address Register
- Line 547: We define the offset relative to the base address for the FIFO Register
- Line 549: We define the offset relative to the base address for the Clock Divider Register
- Line 551: We define the offset relative to the base address for the Data Delay Register
- Line 553: We define the offset relative to the base address for the Clock Stretch Register
- Line 555: We define the macro `RPI_I2C_REG_ADDRESS` to calculate the register address from the I2C bus register base address and the relative register offset.
Each block of bus registers has the same shape for Raspberry Pi 3 and 4.
For Raspberry Pi 5, different registers are used, which we will skip for now.

### I2CMaster.h {#TUTORIAL_21_I2C_BASIC_I2C_FUNCTIONALITY___FAKING_IT___STEP_1_I2CMASTERH}

We'll create a class `I2CMaster` which functions as a master on a I2C bus.

Create the file `code/libraries/baremetal/include/baremetal/I2CMaster.h`

```cpp
File: code/libraries/baremetal/include/baremetal/I2CMaster.h
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : I2CMaster.h
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : I2CMaster
9: //
10: // Description : I2C Master functionality
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39: 
40: #pragma once
41: 
42: #include <baremetal/BCMRegisters.h>
43: #include <baremetal/IMemoryAccess.h>
44: #include <baremetal/PhysicalGPIOPin.h>
45: 
46: /// @file
47: /// I2C Master
48: 
49: namespace baremetal
50: {
51: 
52: #if BAREMETAL_RPI_TARGET <= 4
53: 
54: // Return codes returned by Read/Write as negative value
55: /// @brief Invalid parameter
56: #define I2C_MASTER_INVALID_PARM  1
57: /// @brief Received a NACK
58: #define I2C_MASTER_ERROR_NACK   2
59: /// @brief Received clock stretch timeout
60: #define I2C_MASTER_ERROR_CLKT   3
61: /// @brief Not all data has been sent/received
62: #define I2C_MASTER_DATA_LEFT    4
63: /// @brief Transfer timed out
64: #define I2C_MASTER_TIMEOUT      5
65: /// @brief Bus did not become ready
66: #define I2C_MASTER_BUS_NOT_BUSY 6
67: 
68: /// <summary>
69: /// I2C speed selection
70: /// </summary>
71: enum class I2CMode
72: {
73:     /// @brief I2C @ 100 KHz
74:     Normal,
75:     /// @brief I2C @ 400 KHz
76:     Fast,
77:     /// @brief I2C @ 1 MHz
78:     FastPlus,
79: };
80: 
81: /// <summary>
82: /// Driver for I2C master devices
83: ///
84: /// GPIO pin mapping (Raspberry Pi 3-4)
85: /// bus       | config 0      | config 1      | config 2      | Boards
86: /// :-------: | :-----------: | :-----------: | :-----------: | :-----
87: /// ^         | SDA    SCL    | SDA    SCL    | SDA    SCL    | ^
88: /// 0         | GPIO0  GPIO1  | GPIO28 GPIO29 | GPIO44 GPIO45 | Raspberry Pi 3 / 4
89: /// 1         | GPIO2  GPIO3  |               |               | Raspberry Pi 3 only
90: /// 2         |               |               |               | None
91: /// 3         | GPIO2  GPIO3  | GPIO4  GPIO5  |               | Raspberry Pi 4 only
92: /// 4         | GPIO6  GPIO7  | GPIO8  GPIO9  |               | Raspberry Pi 4 only
93: /// 5         | GPIO10 GPIO11 | GPIO12 GPIO13 |               | Raspberry Pi 4 only
94: /// 6         | GPIO22 GPIO23 |               |               | Raspberry Pi 4 only
95: ///
96: /// GPIO pin mapping (Raspberry Pi 5)
97: /// bus       | config 0      | config 1      | config 2      | Boards
98: /// :-------: | :-----------: | :-----------: | :-----------: | :-----
99: /// ^         | SDA    SCL    | SDA    SCL    | SDA    SCL    | ^
100: /// 0         | GPIO0  GPIO1  | GPIO8  GPIO9  |               | Raspberry Pi 5 only
101: /// 1         | GPIO2  GPIO3  | GPIO10 GPIO11 |               | Raspberry Pi 5 only
102: /// 2         | GPIO4  GPIO5  | GPIO12 GPIO13 |               | Raspberry Pi 5 only
103: /// 3         | GPIO6  GPIO7  | GPIO14 GPIO15 | GPIO22 GPIO23 | Raspberry Pi 5 only
104: /// </summary>
105: class I2CMaster
106: {
107: private:
108:     /// @brief Memory access interface reference for accessing registers.
109:     IMemoryAccess&  m_memoryAccess;
110:     /// @brief I2C bus index
111:     uint8           m_bus;
112:     /// @brief I2C bus base register address
113:     regaddr         m_baseAddress;
114:     /// @brief I2C bus clock rate
115:     I2CMode         m_mode;
116:     /// @brief I2C bus GPIO configuration index used
117:     uint32          m_config;
118:     /// @brief True if class is already initialized
119:     bool            m_isInitialized;
120: 
121:     /// @brief GPIO pin for SDA wire
122:     PhysicalGPIOPin m_sdaPin;
123:     /// @brief GPIO pin for SCL wire
124:     PhysicalGPIOPin m_sclPin;
125: 
126:     /// @brief Core clock rate used to determine I2C clock rate in Hz
127:     unsigned        m_coreClockRate;
128:     /// @brief I2C clock rate in Hz
129:     unsigned        m_clockSpeed;
130: 
131: public:
132:     I2CMaster(IMemoryAccess &memoryAccess = GetMemoryAccess());
133: 
134:     virtual ~I2CMaster();
135: 
136:     bool Initialize(uint8 bus, I2CMode mode = I2CMode::Normal, uint32 config = 0);
137: 
138:     void SetClock(unsigned clockSpeed);
139:     bool Scan(uint8 address);
140:     size_t Read(uint8 address, uint8 &data);
141:     size_t Read(uint8 address, void *buffer, size_t count);
142:     size_t Write(uint8 address, uint8 data);
143:     size_t Write(uint8 address, const void *buffer, size_t count);
144:     size_t WriteReadRepeatedStart(uint8 address, const void *writeBuffer, size_t writeCount, void *readBuffer, size_t readCount);
145: 
146: private:
147:     uint32 ReadControlRegister();
148:     void WriteControlRegister(uint32 data);
149:     void StartTransfer();
150:     void ClearFIFO();
151:     void SetReadTransfer();
152:     void SetWriteTransfer();
153:     void WriteAddressRegister(uint8 data);
154:     void WriteDataLengthRegister(uint8 data);
155:     void WriteStatusRegister(uint32 data);
156:     uint32 ReadStatusRegister();
157:     bool HasClockStretchTimeout();
158:     bool HasAck();
159:     bool HasNAck();
160:     bool ReceiveFIFOFull();
161:     bool ReceiveFIFOHasData();
162:     bool ReceiveFIFONeedsReading();
163:     bool TransmitFIFOEmpty();
164:     bool TransmitFIFOHasSpace();
165:     bool TransmitFIFONeedsWriting();
166:     bool TransferDone();
167:     bool TransferActive();
168:     void ClearClockStretchTimeout();
169:     void ClearNAck();
170:     void ClearDone();
171:     void WriteFIFORegister(uint8 data);
172:     uint8 ReadFIFORegister();
173: };
174: 
175: #else
176: 
177: #error RPI 5 not supported yet
178: 
179: #endif
180: 
181: } // namespace baremetal
```

- Line 52: We only support Raspberry Pi model 3 and 4 for now, as Raspberry Pi 5 behaves differently
- Line 55-66: We define some error return codes
- Line 71-79: We define the enum `I2CMode` to denote the I2C bus clock rate
- Line 105-173: We declare the class `I2CMaster`
  - Line 109: We declare a member variable `m_memoryAccess` to access registers
  - Line 111: We declare a member variable `m_bus` to hold the I2C bus index
  - Line 113: We declare a member variable `m_baseAddress` to hold the I2C bus register base address
  - Line 115: We declare a member variable `m_mode` to hold the I2C clock rate setting
  - Line 117: We declare a member variable `m_config` to hold the configuration used to set GPIO pins for the I2C bus.
This has a direct relationship to the GPIO number used for the two I2C wires
  - Line 119: We declare a member variable `m_isInitialized` to guard aginst multiple initialization
  - Line 122: We declare a member variable `m_sdaPin` to hold the physical GPIO used for the SDA wire
  - Line 124: We declare a member variable `m_sclPin` to hold the physical GPIO used for the SCL wire
  - Line 127: We declare a member variable `m_coreClockRate` to hold the SoC core clock rate (in Hz), which is used to derive the I2C clock rate
  - Line 129: We declare a member variable `m_clockSpeed` to hold hte I2C clock rate (in Hz)
  - Line 132: We declare the constructor, which either takes the singleton `MemoryAccess` instance, or any other passed `IMemoryAccess` instance
  - Line 134: We declare the destructor
  - Line 138: We declare the method `SetClock()` to set the I2C clock rate in Hz
  - Line 139: We declate the method `Scan()` to scan a specific address for existence of a I2C device
  - Line 140: We declare a method `Read()` to read a single byte from an I2c device
  - Line 141: We declare a method `Read()` to read one or more bytes from an I2c device
  - Line 142: We declare a method `Write()` to write a single byte to an I2c device
  - Line 143: We declare a method `Write()` to write one of more bytes to an I2c device
  - Line 144: We declare a method `WriteReadRepeatedStart()` which send and receives data until the specific number of bytes is read
  - Line 147: We declare a method `ReadControlRegister()` to read from the I2C Control Register
  - Line 148: We declare a method `WriteControlRegister()` to write to the I2C Control Register
  - Line 149: We declare a method `StartTransfer()` to start a data transfer
  - Line 150: We declare a method `ClearFIFO()` to clear both read and write FIFO
  - Line 151: We declare a method `SetReadTransfer()` to set transfer to reading
  - Line 152: We declare a method `SetWriteTransfer()` to set transfer to writing
  - Line 153: We declare a method `WriteAddressRegister()` to write to the I2C Address Register
  - Line 154: We declare a method `WriteDataLengthRegister()` to write to the I2C DataLength Register
  - Line 155: We declare a method `WriteStatusRegister()` to write to the I2C Status Register
  - Line 156: We declare a method `ReadStatusRegister()` to read from the I2C Status Register
  - Line 157: We declare a method `HasClockStretchTimeout()` to check whether a Clock Stretch Timeout has occurred
  - Line 158: We declare a method `HasAck()` to check whether an Ack was received
  - Line 159: We declare a method `HasNAck()` to check whether no Ack was received
  - Line 160: We declare a method `ReceiveFIFOFull()` to check whether the receive FIFO is full
  - Line 161: We declare a method `ReceiveFIFOHasData()` to check whether the receive FIFO contains data
  - Line 162: We declare a method `ReceiveFIFONeedsReading()` to check whether the receive FIFO needs reading, i.e. when the receive FIFO is at least 3/4 full
  - Line 163: We declare a method `TransmitFIFOEmpty()` to check whether the transmit FIFO is empty
  - Line 164: We declare a method `TransmitFIFOHasSpace()` to check whether the transmit FIFO has space to write
  - Line 165: We declare a method `TransmitFIFONeedsWriting()` to check whether the transmit FIFO needs writing, i.e. when the transmit FIFO is 1/4 full or less
  - Line 166: We declare a method `TransferDone()` to check whether the transfert is done
  - Line 167: We declare a method `TransferActive()` to check whether there is an active transfer
  - Line 168: We declare a method `ClearClockStretchTimeout()` to clear the Clock Stretch Timeout condition
  - Line 169: We declare a method `ClearNAck()` to clear the NAck condition
  - Line 170: We declare a method `ClearDone()` to clear the done status
  - Line 171: We declare a method `WriteFIFORegister()` to write to the I2C FIFO
  - Line 172: We declare a method `ReadFIFORegister()` to read from the I2C FIFO

### I2CMaster.cpp {#TUTORIAL_21_I2C_BASIC_I2C_FUNCTIONALITY___FAKING_IT___STEP_1_I2CMASTERCPP}

Let's implement the `I2CMaster` class.

Create the file `code/libraries/baremetal/src/I2CMaster.cpp`

```cpp
File: code/libraries/baremetal/src/I2CMaster.cpp
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : I2CMaster.cpp
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : I2CMaster
9: //
10: // Description : I2C Master functionality
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39: 
40: #include <baremetal/I2CMaster.h>
41: 
42: #include <baremetal/Assert.h>
43: #include <baremetal/Logger.h>
44: #include <baremetal/MachineInfo.h>
45: #include <baremetal/String.h>
46: #include <baremetal/Timer.h>
47: 
48: /// @file
49: /// I2CMaster
50: 
51: using namespace baremetal;
52: 
53: /// @brief Define log name
54: LOG_MODULE("I2CMaster");
55: 
56: /// @brief If defined will trace detailed information on messages send and rece
57: #define TRACE 1
58: 
59: #if BAREMETAL_RPI_TARGET == 3
60: /// @brief Number of I2C buses for RPI 3
61: #define I2C_BUSES           2
62: #else
63: /// @brief Number of I2C buses for RPI 4
64: #define I2C_BUSES           7
65: #endif
66: 
67: /// @brief Total number of different GPIO pin configurations for I2C pins
68: #define I2C_CONFIGURATIONS  3
69: 
70: /// @brief Total number of GPIO pins used for I2C (SCL / SDA)
71: #define I2C_GPIOS           2
72: /// @brief Index of I2C SDA pin
73: #define I2C_GPIO_SDA        0
74: /// @brief Index of I2C SCL pin
75: #define I2C_GPIO_SCL        1
76: 
77: /// @brief Value in configuration table to flag invalid combination
78: #define NONE	{10000, 10000}
79: 
80: /// @brief I2C addresses below RESERVED_ADDRESS_LOW are reserved
81: #define RESERVED_ADDRESS_LOW 0x07
82: /// @brief I2C addresses staring from RESERVED_ADDRESS_HIGH are reserved
83: #define RESERVED_ADDRESS_HIGH 0x78
84: 
85: /// @brief GPIO pin configurations for I2C pins. For every bus there are multiple configurations for the two I2C pins
86: static unsigned s_GPIOConfig[I2C_BUSES][I2C_CONFIGURATIONS][I2C_GPIOS] =
87: {
88:     // SDA, SCL
89:     {{ 0,  1}, {28, 29}, {44, 45}}, // Alt0, Alt0, Alt1
90:     {{ 2,  3},   NONE,     NONE  }, // Alt0
91: #if BAREMETAL_RPI_TARGET == 4
92:     {  NONE,     NONE,     NONE  }, // unused
93:     {{ 2,  3}, { 4,  5},   NONE  }, // Alt5, Alt5
94:     {{ 6,  7}, { 8,  9},   NONE  }, // Alt5, Alt5
95:     {{10, 11}, {12, 13},   NONE  }, // Alt5, Alt5
96:     {{22, 23},   NONE  ,   NONE  }  // Alt5
97: #endif
98: };
99: 
100: /// @brief I2C register bases addresses for each bus, depening on the RPI model
101: static regaddr s_BaseAddress[I2C_BUSES] =
102: {
103:     RPI_I2C0_BASE,
104:     RPI_I2C1_BASE,
105: #if BAREMETAL_RPI_TARGET == 4
106:     0,
107:     RPI_I2C3_BASE,
108:     RPI_I2C4_BASE,
109:     RPI_I2C5_BASE,
110:     RPI_I2C6_BASE,
111: #endif
112: };
113: 
114: /// @brief FIFO register mask. Only one byte can be written at once
115: #define RPI_I2C_FIFO_MASK   0xFF
116: 
117: /// @brief Size of FIFO for both read and write operations
118: #define RPI_I2C_FIFO_SIZE   16
119: 
120: /// @brief Macro to determine GPIO function to be selected for a specific bus and configuration
121: #define ALT_FUNC(bus, config) ((bus) == 0 && (config) == 2          \
122:                                 ? GPIOMode::AlternateFunction1        \
123:                                 : ((bus) < 2                     \
124:                                     ? GPIOMode::AlternateFunction0    \
125:                                     : GPIOMode::AlternateFunction5))
126: 
127: /// <summary>
128: /// Constructor for I2CMaster
129: /// 
130: /// The default value for memoryAccess will use the singleton MemoryAccess instance. A different reference to a IMemoryAccess instance can be passed for testing
131: /// </summary>
132: /// <param name="memoryAccess">MemoryAccess instance to be used for register access</param>
133: I2CMaster::I2CMaster(IMemoryAccess &memoryAccess/* = GetMemoryAccess()*/)
134:     : m_memoryAccess{ memoryAccess }
135:     , m_bus{}
136:     , m_baseAddress{}
137:     , m_mode{}
138:     , m_config{}
139:     , m_isInitialized{}
140:     , m_sdaPin{memoryAccess}
141:     , m_sclPin{memoryAccess}
142:     , m_coreClockRate{}
143:     , m_clockSpeed{}
144: {
145: }
146: 
147: /// <summary>
148: /// Destructor for I2CMaster
149: /// </summary>
150: I2CMaster::~I2CMaster()
151: {
152:     if (m_isInitialized)
153:     {
154:         m_sdaPin.SetMode(GPIOMode::Input);
155:         m_sclPin.SetMode(GPIOMode::Input);
156:     }
157:     m_isInitialized = false;
158:     m_baseAddress = 0;
159: }
160: 
161: /// <summary>
162: /// Initialize the I2CMaster for a specific bus, using the specified configuration index, and setting the clock as specified.
163: /// </summary>
164: /// <param name="bus">Device number (see: comment for I2CMaster class</param>
165: /// <param name="mode">I2C clock rate to be used</param>
166: /// <param name="config">Configuration index to be used. Determines which GPIO pins are to be used for the I2C bus</param>
167: /// <returns></returns>
168: bool I2CMaster::Initialize(uint8 bus, I2CMode mode, uint32 config)
169: {
170:     if (m_isInitialized)
171:         return true;
172: 
173:     LOG_INFO("Initialize bus %d, mode %d, config %d", bus, static_cast<int>(mode), config);
174:     if ((bus >= I2C_BUSES) ||
175:         (config >= I2C_CONFIGURATIONS) ||
176:         (s_GPIOConfig[bus][config][I2C_GPIO_SDA] >= NUM_GPIO))
177:         return false;
178: 
179:     m_bus = bus;
180:     m_mode = mode;
181:     m_config = config;
182:     m_baseAddress = s_BaseAddress[m_bus];
183:     m_coreClockRate = GetMachineInfo().GetClockRate(ClockID::CORE);
184: 
185:     assert(m_baseAddress != 0);
186: 
187:     m_sdaPin.AssignPin(s_GPIOConfig[m_bus][m_config][I2C_GPIO_SDA]);
188:     m_sdaPin.SetMode(ALT_FUNC(m_bus, m_config));
189: 
190:     m_sclPin.AssignPin(s_GPIOConfig[m_bus][m_config][I2C_GPIO_SCL]);
191:     m_sclPin.SetMode(ALT_FUNC(m_bus, m_config));
192: 
193:     assert(m_coreClockRate > 0);
194: 
195:     m_isInitialized = true;
196: 
197:     SetClock(m_mode == I2CMode::FastPlus ? 1000000 : (m_mode == I2CMode::Fast ? 400000 : 100000));
198: 
199:     LOG_INFO("Set up bus %d, config %d, base address %08X", bus, config, m_baseAddress);
200:     return true;
201: }
202: 
203: /// <summary>
204: /// Set I2C clock rate
205: /// </summary>
206: /// <param name="clockSpeed">Clock rate in Hz</param>
207: void I2CMaster::SetClock(unsigned clockSpeed)
208: {
209:     assert(m_isInitialized);
210: 
211:     assert(clockSpeed > 0);
212:     m_clockSpeed = clockSpeed;
213: 
214:     uint16 divider = static_cast<uint16>(m_coreClockRate / clockSpeed);
215:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_DIV_OFFSET), divider);
216:     LOG_INFO("Set clock %d", clockSpeed);
217: }
218: 
219: /// <summary>
220: /// Scan I2C bus for existing of a device at the specified address
221: /// </summary>
222: /// <param name="address">I2C address to be scanned</param>
223: /// <returns>Returns true if a device was found, false otherwise</returns>
224: bool I2CMaster::Scan(uint8 address)
225: {
226:     uint8 data{};
227:     return Read(address, data) == 1;
228: }
229: 
230: /// <summary>
231: /// Read a single byte from the I2C device with specified address
232: /// </summary>
233: /// <param name="address">Device address</param>
234: /// <param name="data">Data to be received</param>
235: /// <returns>Returns number of bytes read, or errorcode < 0 on failure</returns>
236: size_t I2CMaster::Read(uint8 address, uint8 &data)
237: {
238:     return Read(address, &data, 1);
239: }
240: 
241: /// <summary>
242: /// Read a requested number of bytes from the I2C device with specified address
243: /// </summary>
244: /// <param name="address">Device address</param>
245: /// <param name="buffer">Pointer to buffer to store data read</param>
246: /// <param name="count">Requested number of bytes to read</param>
247: /// <returns>Returns number of bytes read, or errorcode < 0 on failure</returns>
248: size_t I2CMaster::Read(uint8 address, void *buffer, size_t count)
249: {
250:     assert(m_isInitialized);
251: 
252:     if ((address >= 0x80) || (count == 0))
253:     {
254:         return -I2C_MASTER_INVALID_PARM;
255:     }
256: 
257:     uint8 *data = reinterpret_cast<uint8 *>(buffer);
258:     assert(data != 0);
259: 
260:     size_t result = 0;
261: 
262:     // Setup transfer
263:     WriteAddressRegister(address);
264: 
265:     // Clear FIFO
266:     ClearFIFO();
267:     // Clear error and done conditions
268:     WriteStatusRegister(RPI_I2C_S_CLKT | RPI_I2C_S_ERR | RPI_I2C_S_DONE);
269: 
270:     WriteDataLengthRegister(count);
271: 
272:     // Enable, start read transfer
273:     WriteControlRegister(RPI_I2C_C_ENABLE | RPI_I2C_C_ST | RPI_I2C_C_READ);
274: 
275:     // Transfer active
276:     while (!(ReadStatusRegister() & RPI_I2C_S_DONE))
277:     {
278:         while (ReadStatusRegister() & RPI_I2C_S_RXD)
279:         {
280:             *data++ = ReadFIFORegister();
281:             //LOG_INFO("Read byte from %02x, data %02x", address, *(data - 1));
282: 
283:             count--;
284:             result++;
285:         }
286:     }
287: 
288:     // Transfer has finished, grab any remaining stuff from FIFO
289:     while ((count > 0) && (ReadStatusRegister() & RPI_I2C_S_RXD))
290:     {
291:         *data++ = ReadFIFORegister();
292:         //LOG_INFO("Read extra byte from %02x, data %02x", address, *(data - 1));
293: 
294:         count--;
295:         result++;
296:     }
297: 
298: #if TRACE
299:     LOG_INFO("Read result = %d", result);
300: #endif
301: 
302:     uint32 status = ReadStatusRegister();
303:     if (status & RPI_I2C_S_ERR)
304:     {
305:         // Clear error bit
306:         ClearNAck();
307: 
308:         result = -I2C_MASTER_ERROR_NACK;
309:     }
310:     else if (status & RPI_I2C_S_CLKT)
311:     {
312:         ClearClockStretchTimeout();
313:         result = -I2C_MASTER_ERROR_CLKT;
314:     }
315:     else if (count > 0)
316:     {
317:         result = -I2C_MASTER_DATA_LEFT;
318:     }
319: 
320:     // Clear done bit
321:     ClearDone();
322: 
323:     return result;
324: }
325: 
326: /// <summary>
327: /// Write a single byte to the I2C device with specified address
328: /// </summary>
329: /// <param name="address">Device address</param>
330: /// <param name="data">Data to write</param>
331: /// <returns>Returns number of bytes written, or errorcode < 0 on failure</returns>
332: size_t I2CMaster::Write(uint8 address, uint8 data)
333: {
334:     return Write(address, &data, 1);
335: }
336: 
337: /// <summary>
338: /// Write a requested number of bytes to the I2C device with specified address
339: /// </summary>
340: /// <param name="address">Device address</param>
341: /// <param name="buffer">Pointer to buffer containing data to sebd</param>
342: /// <param name="count">Requested number of bytes to write</param>
343: /// <returns>Returns number of bytes written, or errorcode < 0 on failure</returns>
344: size_t I2CMaster::Write(uint8 address, const void *buffer, size_t count)
345: {
346:     assert(m_isInitialized);
347: 
348:     if ((address <= RESERVED_ADDRESS_LOW) || (address >= RESERVED_ADDRESS_HIGH))
349:     {
350:         return -I2C_MASTER_INVALID_PARM;
351:     }
352: 
353:     if ((count != 0) && (buffer == nullptr))
354:     {
355:         return -I2C_MASTER_INVALID_PARM;
356:     }
357: 
358:     const uint8 *data = reinterpret_cast<const uint8 *>(buffer);
359: 
360:     int result = 0;
361: 
362:     // Setup transfer
363:     WriteAddressRegister(address);
364: 
365:     // Clear FIFO
366:     ClearFIFO();
367:     // Clear error and done conditions
368:     WriteStatusRegister(RPI_I2C_S_CLKT | RPI_I2C_S_ERR | RPI_I2C_S_DONE);
369: 
370:     WriteDataLengthRegister(count);
371: 
372:     ReadControlRegister();
373:     ReadStatusRegister();
374: 
375:     // Fill FIFO
376:     for (unsigned i = 0; count > 0 && i < RPI_I2C_FIFO_SIZE; i++)
377:     {
378:         WriteFIFORegister(*data++);
379:         count--;
380:         result++;
381:     }
382: 
383:     // Enable, start write transfer
384:     WriteControlRegister(RPI_I2C_C_ENABLE | RPI_I2C_C_ST | RPI_I2C_C_WRITE);
385: 
386:     // Transfer active
387:     while (!(ReadStatusRegister() & RPI_I2C_S_DONE))
388:     {
389:         while ((count > 0) && (ReadStatusRegister() & RPI_I2C_S_TXD))
390:         {
391:             //LOG_INFO("Write extra byte to %02x, data %02x", address, *data);
392:             WriteFIFORegister(*data++);
393:             count--;
394:             result++;
395:         }
396:         Timer::WaitMilliSeconds(1);
397:     }
398: 
399: #if TRACE
400:     LOG_INFO("Write result = %d", result);
401: #endif
402: 
403:     // Check status
404:     uint32 status = ReadStatusRegister();
405:     if (status & RPI_I2C_S_ERR)
406:     {
407:         // Clear error bit
408:         ClearNAck();
409: 
410:         result = -I2C_MASTER_ERROR_NACK;
411:     }
412:     else if (status & RPI_I2C_S_CLKT)
413:     {
414:         ClearClockStretchTimeout();
415:         result = -I2C_MASTER_ERROR_CLKT;
416:     }
417:     else if (count > 0)
418:     {
419:         result = -I2C_MASTER_DATA_LEFT;
420:     }
421: 
422:     // Clear done bit
423:     ClearDone();
424:  
425:     while (ReadStatusRegister() & RPI_I2C_S_RXD)
426:     {
427:         uint8 data = ReadFIFORegister();
428: #if TRACE
429:         LOG_INFO("Read byte = %02x", data);
430: #endif
431:     }
432: 
433:     return result;
434: }
435: 
436: /// <summary>
437: /// Consecutive write and read operation with repeated start
438: /// </summary>
439: /// <param name="address">I2C address of target device</param>
440: /// <param name="writeBuffer">Write data for will be taken from here</param>
441: /// <param name="writeCount">Number of bytes to be written (max. 16)</param>
442: /// <param name="readBuffer">Read data will be stored here</param>
443: /// <param name="readCount">Number of bytes to be read</param>
444: /// <returns>Returns number of bytes read, or errorcode < 0 on failure</returns>
445: size_t I2CMaster::WriteReadRepeatedStart(uint8 address, const void *writeBuffer, size_t writeCount, void *readBuffer, size_t readCount)
446: {
447:     assert(m_isInitialized);
448: 
449:     if ((address <= RESERVED_ADDRESS_LOW) || (address >= RESERVED_ADDRESS_HIGH))
450:     {
451:         return -I2C_MASTER_INVALID_PARM;
452:     }
453: 
454:     if ((writeCount == 0) || (writeCount > RPI_I2C_FIFO_SIZE) || 
455:         (writeBuffer == nullptr) ||
456:         (readCount == 0) || (readBuffer == nullptr))
457:     {
458:         return -I2C_MASTER_INVALID_PARM;
459:     }
460: 
461:     const uint8 *writeData = reinterpret_cast<const uint8 *>(writeBuffer);
462: 
463:     int result = 0;
464: 
465:     // Setup transfer
466:     WriteAddressRegister(address);
467: 
468:     // Clear FIFO
469:     ClearFIFO();
470:     // Clear error and done conditions
471:     WriteStatusRegister(RPI_I2C_S_CLKT | RPI_I2C_S_ERR | RPI_I2C_S_DONE);
472: 
473:     WriteDataLengthRegister(writeCount);
474: 
475:     // Fill FIFO
476:     for (unsigned i = 0; writeCount > 0 && i < RPI_I2C_FIFO_SIZE; i++)
477:     {
478:         WriteFIFORegister(*writeData++);
479: 
480:         writeCount--;
481:         result++;
482:     }
483: 
484:     // Enable, start write transfer
485:     WriteControlRegister(RPI_I2C_C_ENABLE | RPI_I2C_C_ST | RPI_I2C_C_WRITE);
486: 
487:     // Poll for transfer has started
488:     while (!(ReadStatusRegister() & RPI_I2C_S_TA))
489:     {
490:         if (ReadStatusRegister() & RPI_I2C_S_DONE)
491:         {
492:             break;
493:         }
494:     }
495: 
496:     uint8 *readData = reinterpret_cast<uint8 *>(readBuffer);
497: 
498:     WriteDataLengthRegister(readCount);
499: 
500:     // Enable, start read transfer
501:     WriteControlRegister(RPI_I2C_C_ENABLE | RPI_I2C_C_ST | RPI_I2C_C_READ);
502: 
503:     assert(m_clockSpeed > 0);
504:     Timer::WaitMicroSeconds((writeCount + 1) * 9 * 1000000 / m_clockSpeed);
505: 
506:     // Transfer active
507:     while (!(ReadStatusRegister() & RPI_I2C_S_DONE))
508:     {
509:         while ((readCount > 0) && ReadStatusRegister() & RPI_I2C_S_RXD)
510:         {
511:             *readData++ = ReadFIFORegister() & RPI_I2C_FIFO_MASK;
512: 
513:             readCount--;
514:             result++;
515:         }
516:     }
517: 
518:     // Transfer has finished, grab any remaining stuff from FIFO
519:     while ((readCount > 0) && (ReadStatusRegister() & RPI_I2C_S_RXD))
520:     {
521:         *readData++ = ReadFIFORegister() & RPI_I2C_FIFO_MASK;
522: 
523:         readCount--;
524:         result++;
525:     }
526: 
527:     // Check status
528:     uint32 status = ReadStatusRegister();
529:     if (status & RPI_I2C_S_ERR)
530:     {
531:         // Clear error bit
532:         ClearNAck();
533: 
534:         result = -I2C_MASTER_ERROR_NACK;
535:     }
536:     else if (status & RPI_I2C_S_CLKT)
537:     {
538:         ClearClockStretchTimeout();
539:         result = -I2C_MASTER_ERROR_CLKT;
540:     }
541:     else if (readCount > 0)
542:     {
543:         result = -I2C_MASTER_DATA_LEFT;
544:     }
545: 
546:     // Clear done bit
547:     ClearDone();
548: 
549:     return result;
550: }
551: 
552: /// <summary>
553: /// Read the I2C Control Register
554: /// </summary>
555: /// <returns>Value read from I2C Control Register</returns>
556: uint32 I2CMaster::ReadControlRegister()
557: {
558:     auto result = m_memoryAccess.Read32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_C_OFFSET));
559: #if TRACE
560:     string text;
561:     text += (result & RPI_I2C_C_ENABLE) ? "EN " : "   ";
562:     text += (result & RPI_I2C_C_INTR_ENABLE) ? "IR " : "  ";
563:     text += (result & RPI_I2C_C_INTT_ENABLE) ? "IT " : "  ";
564:     text += (result & RPI_I2C_C_INTD_ENABLE) ? "ID " : "  ";
565:     text += (result & RPI_I2C_C_ST) ? "ST " : "  ";
566:     text += (result & RPI_I2C_C_CLEAR) ? "CL " : "  ";
567:     text += (result & RPI_I2C_C_READ) ? "RD " : "WR ";
568:     LOG_INFO("Read I2C Control, %s", text.c_str());
569: #endif
570:     return result;
571: }
572: 
573: /// <summary>
574: /// Write to the I2C Control Register
575: /// </summary>
576: /// <param name="data">Value to write</param>
577: void I2CMaster::WriteControlRegister(uint32 data)
578: {
579:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_C_OFFSET), data);
580: #if TRACE
581:     string text;
582:     text += (data & RPI_I2C_C_ENABLE) ? "EN " : "   ";
583:     text += (data & RPI_I2C_C_INTR_ENABLE) ? "IR " : "  ";
584:     text += (data & RPI_I2C_C_INTT_ENABLE) ? "IT " : "  ";
585:     text += (data & RPI_I2C_C_INTD_ENABLE) ? "ID " : "  ";
586:     text += (data & RPI_I2C_C_ST) ? "ST " : "  ";
587:     text += (data & RPI_I2C_C_CLEAR) ? "CL " : "  ";
588:     text += (data & RPI_I2C_C_READ) ? "RD " : "WR ";
589:     LOG_INFO("Write I2C Control, %s", text.c_str());
590: #endif
591: }
592: 
593: /// <summary>
594: /// Start a transfer
595: /// </summary>
596: void I2CMaster::StartTransfer()
597: {
598:     WriteControlRegister(ReadControlRegister() | RPI_I2C_C_ST);
599: }
600: 
601: /// <summary>
602: /// Clear the FIFO. This clears both read and write FIFO
603: /// </summary>
604: void I2CMaster::ClearFIFO()
605: {
606:     WriteControlRegister(ReadControlRegister() | RPI_I2C_C_CLEAR);
607: }
608: 
609: /// <summary>
610: /// Set transfer typue to read for the next transfer
611: /// </summary>
612: void I2CMaster::SetReadTransfer()
613: {
614:     WriteControlRegister((ReadControlRegister() | RPI_I2C_C_READ));
615: }
616: 
617: /// <summary>
618: /// Set transfer typue to write for the next transfer
619: /// </summary>
620: void I2CMaster::SetWriteTransfer()
621: {
622:     WriteControlRegister((ReadControlRegister() & ~RPI_I2C_C_READ));
623: }
624: 
625: /// <summary>
626: /// Write to the I2C Address Register
627: /// </summary>
628: /// <param name="data">Value to write</param>
629: void I2CMaster::WriteAddressRegister(uint8 data)
630: {
631:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_A_OFFSET), data);
632: #if TRACE
633:     LOG_INFO("Write I2C Address, %08x", data);
634: #endif
635: }
636: 
637: /// <summary>
638: /// Write to the I2C Data Length Register
639: /// </summary>
640: /// <param name="data">Value to write</param>
641: void I2CMaster::WriteDataLengthRegister(uint8 data)
642: {
643:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_DLEN_OFFSET), data);
644: #if TRACE
645:     LOG_INFO("Write I2C Length, %08x", data);
646: #endif
647: }
648: 
649: /// <summary>
650: /// Write to the I2C Status Register
651: /// </summary>
652: /// <param name="data">Value to write</param>
653: void I2CMaster::WriteStatusRegister(uint32 data)
654: {
655:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_S_OFFSET), data);
656: #if TRACE
657:     string text;
658:     text += (data & RPI_I2C_S_CLKT) ? "CLKT " : "     ";
659:     text += (data & RPI_I2C_S_ERR) ? "ERR " : "    ";
660:     text += (data & RPI_I2C_S_DONE) ? "DONE " : "     ";
661:     LOG_INFO("Write I2C Status, %s", text.c_str());
662: #endif
663: }
664: 
665: /// <summary>
666: /// Read the I2C Status Register
667: /// </summary>
668: /// <returns>Value read from I2C Status Register</returns>
669: uint32 I2CMaster::ReadStatusRegister()
670: {
671:     uint8 data = m_memoryAccess.Read32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_S_OFFSET));
672: #if TRACE
673:     string text;
674:     text += (data & RPI_I2C_S_CLKT) ? "CLKT " : "     ";
675:     text += (data & RPI_I2C_S_ERR) ? "ERR " : "    ";
676:     text += (data & RPI_I2C_S_RXF) ? "RXF " : "    ";
677:     text += (data & RPI_I2C_S_TXE) ? "TXE " : "    ";
678:     text += (data & RPI_I2C_S_RXD) ? "RXD " : "    ";
679:     text += (data & RPI_I2C_S_TXD) ? "TXD " : "    ";
680:     text += (data & RPI_I2C_S_RXR) ? "RXR " : "    ";
681:     text += (data & RPI_I2C_S_TXW) ? "TXW " : "    ";
682:     text += (data & RPI_I2C_S_DONE) ? "DONE " : "     ";
683:     text += (data & RPI_I2C_S_TA) ? "TA " : "     ";
684:     LOG_INFO("Read I2C Status, %s", text.c_str());
685: #endif
686:     return data;
687: }
688: 
689: /// <summary>
690: /// Check whether a clock stretch timeout has occurred
691: /// </summary>
692: /// <returns>Returns true if a clock stretch timeout has occurred</returns>
693: bool I2CMaster::HasClockStretchTimeout()
694: {
695:     return (ReadStatusRegister() & RPI_I2C_S_CLKT) != 0;
696: }
697: 
698: /// <summary>
699: /// Check whether the latest byte has received an ACK
700: /// </summary>
701: /// <returns>Returns true if the latest byte has received an ACK</returns>
702: bool I2CMaster::HasAck()
703: {
704:     return (ReadStatusRegister() & RPI_I2C_S_ERR) == 0;
705: }
706: 
707: /// <summary>
708: /// Check whether the latest byte has not received an ACK
709: /// </summary>
710: /// <returns>Returns true if the latest byte has not received an ACK</returns>
711: bool I2CMaster::HasNAck()
712: {
713:     return (ReadStatusRegister() & RPI_I2C_S_ERR) != 0;
714: }
715: 
716: /// <summary>
717: /// Check whether the read FIFO is full
718: /// </summary>
719: /// <returns>Returns true if the read FIFO is full</returns>
720: bool I2CMaster::ReceiveFIFOFull()
721: {
722:     return (ReadStatusRegister() & RPI_I2C_S_RXF) != 0;
723: }
724: 
725: /// <summary>
726: /// Check whether the read FIFO contains data
727: /// </summary>
728: /// <returns>Returns true if the read FIFO contains data</returns>
729: bool I2CMaster::ReceiveFIFOHasData()
730: {
731:     return (ReadStatusRegister() & RPI_I2C_S_RXD) != 0;
732: }
733: 
734: /// <summary>
735: /// Check whether the read FIFO needs to be read. This means the FIFO is 3/4 full or more
736: /// </summary>
737: /// <returns>Returns true if the read FIFO needs to be read</returns>
738: bool I2CMaster::ReceiveFIFONeedsReading()
739: {
740:     return (ReadStatusRegister() & RPI_I2C_S_RXR) != 0;
741: }
742: 
743: /// <summary>
744: /// Check whether the write FIFO is empty
745: /// </summary>
746: /// <returns>Returns true if the write FIFO is empty</returns>
747: bool I2CMaster::TransmitFIFOEmpty()
748: {
749:     return (ReadStatusRegister() & RPI_I2C_S_TXE) != 0;
750: }
751: 
752: /// <summary>
753: /// Check whether the write FIFO has space to write
754: /// </summary>
755: /// <returns>Returns true if the write FIFO has space to write</returns>
756: bool I2CMaster::TransmitFIFOHasSpace()
757: {
758:     return (ReadStatusRegister() & RPI_I2C_S_TXD) != 0;
759: }
760: 
761: /// <summary>
762: /// Check whether the write FIFO needs to be written to. This means the FIFO is 1/4 full or less
763: /// </summary>
764: /// <returns>Returns true if the write FIFO needs to be written to</returns>
765: bool I2CMaster::TransmitFIFONeedsWriting()
766: {
767:     return (ReadStatusRegister() & RPI_I2C_S_TXW) != 0;
768: }
769: 
770: /// <summary>
771: /// Check whether the transfer is done
772: /// </summary>
773: /// <returns>Returns true if the transfer is done</returns>
774: bool I2CMaster::TransferDone()
775: {
776:     return (ReadStatusRegister() & RPI_I2C_S_DONE) != 0;
777: }
778: 
779: /// <summary>
780: /// Check whether a transfer is active
781: /// </summary>
782: /// <returns>Returns true if a transfer is active</returns>
783: bool I2CMaster::TransferActive()
784: {
785:     return (ReadStatusRegister() & RPI_I2C_S_TA) != 0;
786: }
787: 
788: /// <summary>
789: /// Clear the CLKT (Clock Stretch Timeout) bit in the I2C Status Register
790: /// </summary>
791: void I2CMaster::ClearClockStretchTimeout()
792: {
793:     WriteStatusRegister(RPI_I2C_S_CLKT);
794: }
795: 
796: /// <summary>
797: /// Clear the ACK bit in the I2C Status Register
798: /// </summary>
799: void I2CMaster::ClearNAck()
800: {
801:     WriteStatusRegister(RPI_I2C_S_ERR);
802: }
803: 
804: /// <summary>
805: /// Clear the DONE bit in the I2C Status Register
806: /// </summary>
807: void I2CMaster::ClearDone()
808: {
809:     WriteStatusRegister(RPI_I2C_S_DONE);
810: }
811: 
812: /// <summary>
813: /// Write to the I2C FIFO Register
814: /// </summary>
815: /// <param name="data">Value to write</param>
816: void I2CMaster::WriteFIFORegister(uint8 data)
817: {
818:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_FIFO_OFFSET), data);
819: #if TRACE
820:     LOG_INFO("Write FIFO, data %08x", data);
821: #endif
822: }
823: 
824: /// <summary>
825: /// Read the I2C FIFO Register
826: /// </summary>
827: /// <returns>Value read from I2C FIFO Register</returns>
828: uint8 I2CMaster::ReadFIFORegister()
829: {
830:     uint8 data = m_memoryAccess.Read32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_FIFO_OFFSET)) & RPI_I2C_FIFO_MASK;
831: #if TRACE
832:     LOG_INFO("Read FIFO, data %08x", data);
833: #endif
834:     return data;
835: }
```

- Line 57: We add a definition `TRACE` to enforce tracing detailed debug information if the definition is not 0, and skuip debug information if set to 0
- Line 59-65: We create a definition `I2C_BUSES` as the number of I2C buses available for the enable Raspberry Pi model
- Line 68: We create a definition `I2C_CONFIGURATIONS` as the maximum number of defined GPIO pin configurations for each bus
- Line 71: We create a definition `I2C_GPIOS` as the total number of pins defined for each bus
- Line 73: We create a definition `I2C_GPIO_SDA` as the index of the SDA pin
- Line 75: We create a definition `I2C_GPIO_SCL` as the index of the SCL pin
- Line 78: We create a definition `NONE` as an unused or invalid pin configuration
- Line 81: We create a definition `RESERVED_ADDRESS_LOW` as the maximum I2C address which is reserved.
For I2C all addresses between 0 and 7 are reserved
- Line 83: We create a definition `RESERVED_ADDRESS_HIGH` as the first I2C address in the high range which is reserved.
For I2C all addresses between 120 and 127 are reserved
- Line 86-98: We declare a variable `s_GPIOConfig` which holds the different GPIO pin configurations for the I2C pins in each bus
As can be seen there is no valid configuration for bus 2, as it is not on the GPIO header
- Line 101-112: We declare a variable `s_BaseAddress` which holds the register base address for each bus
As can be seen there is no address specified for bus 2, as it is not on the GPIO header, so addressing it would be useless
- Line 115: We create a definition `RPI_I2C_FIFO_MASK` to denote the mask to be placed on the FIFO register when reading or writing.
The FIFO can only be read and written per single byte
- Line 118: We create a definition `RPI_I2C_FIFO_SIZE` to denote the size of the read and write FIFO
- Line 121-125: We create a macro `ALT_FUNC` to determine the GPIO pin function for a specific configuration on a specified bus index.
This relates to the pin numbers in `s_GPIOConfig`
- Line 133-145: We define the constructor
- Line 150-159: We define the destructor. If initialized, it will reset the GPIO pins used to input mode
- Line 168-201: We define the method `Initialize()`
  - Line 170-171: If already initialized we simply return true
  - Line 174: We check for the validity of the specified bus index and configuration number, and whether this specifies valid GPIO pins.
If not we return false
  - Line 179-182: We save the parameters passed, and determine the register base address for the bus
  - Line 183: We request and save the core clock rate
  - Line 185: We assert that we have a valid register base address
  - Line 187-191: We assign the GPIO pins for SDA and SCL, and set them to the correct function
  - Line 193: We assert that we have a valid core clock rate
  - Line 195: We set the initialized flag
  - Line 197: We set the I2C clock rate depending on the mode
- Line 207-217: We define the method `SetClock()` to set the I2C clock rate.
This calculates the divider to be used to get from the core clock rate to the desired clock rate
- Line 224-228: We define the method `Scan()` to scan the bus for a specific I2C address.
It does this by trying to read from the specified address
- Line 236-239: We define the method `Read()` for a single byte read, this simply calls the other `Read()` method
- Line 248-324: We define the method `Read()` for one or more bytes
  - Line 250: We assert that the `Initialize()` method was correctly called
  - Line 252-255: We check that the I2C address is not out of range, and we're not trying to read empty data.
Notice that for now we only support 7 bit addresses
  - Line 257-258: We convert the buffer pointer to a byte pointer and assert it is valid
  - Line 263: We set the I2C address
  - Line 266: We clear the FIFO
  - Line 268: We reset the Clock Stretch Timeout, Error (Nack) and Done conditions
  - Line 270: We set the data length
  - Line 273: We set read mode, enable the I2C controller, and start the transfer
  - Line 276-286: As long as the Done condition is not set, we read the status and check for available data.
If there is data, we read it and place it in the buffer
  - Line 289-296: Even when the Done condition is true, we read data as long as more is available
  - Line 303-309: We check for an Error condition (meaning no Ack was received), and if so reset the condition and set an error code as the result
  - Line 310-314: We check for an Clock Stretch Timeout condition, and if so reset the condition and set an error code as the result
  - Line 315-318: We check that all requested data was read, and if not set an error code as the result
  - Line 321: We reset the Done condition
- Line 332-335: We define the method `Write()` for a single byte write, this simply calls the other `Write()` method
- Line 344-433: We define the method `Write()` for one or more bytes
  - Line 346: We assert that the `Initialize()` method was correctly called
  - Line 348-351: We check that the address is within the right range and if not set an error code as the result
  - Line 353-356: We check that the buffer is valid and the requested byte count is not zero and if not set an error code as the result
  - Line 363: We set the I2C addres
  - Line 366: We clear the FIFO
  - Line 368: We reset the Clock Stretch Timeout, Error (Nack) and Done conditions
  - Line 369: We set the data length
  - Line 372-373: We read the I2C Control Register and Status Register
  - Line 376-381: We write data to the FIFO until done or the FIFO is full
  - Line 384: We set write mode, enable the I2C controller, and start the transfer
  - Line 387-397: As long as the Done condition is not set, we read the status and check whether there is space in the FIFO to write data.
If there is space and we need to write more data, we write to the FIFO
  - Line 404: We read the I2C Status Register
  - Line 405-411: If there was an Error condition (no Ack received) we reset the Error condition and return an error code
  - Line 412-416: If there was a Clock Stretch Timeout, we reset the Error condition and return an error code
  - Line 417-420: If there is still data to be written, we return an error code
  - Line 423: We reset the Done bit
  - Line 425-431: If there is data to be read we read it
- Line 445-550: We define the method `WriteReadRepeatedStart()` to write and read data simultaneously
  - Line 447: We assert that the `Initialize()` method was correctly called
  - Line 449-452: We check that the address is within the right range and if not set an error code as the result
  - Line 454-459: We check that the read and write buffer are valid and the requested send byte count is not zero and not more than the FIFO can hold, as well as that the requested receive count is not zero, and if not set an error code as the result
  - Line 466: We set the I2C addres
  - Line 469: We clear the FIFO
  - Line 471: We reset the Clock Stretch Timeout, Error (Nack) and Done conditions
  - Line 473: We set the data length with the number of bytes to send
  - Line 476-482: We write data to the FIFO until done or the FIFO is full
  - Line 485: We set write mode, enable the I2C controller, and start the transfer
  - Line 488-494: If the transfer is done, we check is the Done condition is set, and continue if it is.
  - Line 498: We set the data length with the number of bytes to receive
  - Line 501: We set read mode, enable the I2C controller, and start the transfer
  - Line 503-504: We wait a bit depending on the number of bytes sent and the I2C clock rate
  - Line 507-516: As long as the Done condition is not set, we read the status and check whether there is receive data available.
If so we read the data from the FIFO.
  - Line 519-525: As long as the there is receive data available, we read the data from the FIFO.
  - Line 528: We read the I2C Status Register
  - Line 529-535: If there was an Error condition (no Ack received) we reset the Error condition and return an error code
  - Line 536-540: If there was a Clock Stretch Timeout, we reset the Error condition and return an error code
  - Line 541-544: If we could not read the requested amount of bytes, we return an error code
  - Line 547: We reset the Done bit
- Line 556-571: We define the method `ReadControlRegister()`
- Line 577-591: We define the method `WriteControlRegister()`
- Line 596-599: We define the method `StartTransfer()`
- Line 604-607: We define the method `ClearFIFO()`
- Line 612-615: We define the method `SetReadTransfer()`
- Line 620-623: We define the method `SetWriteTransfer()`
- Line 629-635: We define the method `WriteAddressRegister()`
- Line 641-647: We define the method `WriteDataLengthRegister()`
- Line 653-663: We define the method `WriteStatusRegister()`
- Line 669-687: We define the method `ReadStatusRegister()`
- Line 693-697: We define the method `HasClockStretchTimeout()`
- Line 702-705: We define the method `HasAck()`
- Line 711-714: We define the method `HasNAck()`
- Line 720-723: We define the method `ReceiveFIFOFull()`
- Line 729-732: We define the method `ReceiveFIFOHasData()`
- Line 738-741: We define the method `ReceiveFIFONeedsReading()`
- Line 747-750: We define the method `TransmitFIFOEmpty()`
- Line 756-759: We define the method `TransmitFIFOHasSpace()`
- Line 765-768: We define the method `TransmitFIFONeedsWriting()`
- Line 774-777: We define the method `TransferDone()`
- Line 783-786: We define the method `TransferActive()`
- Line 791-794: We define the method `ClearClockStretchTimeout()`
- Line 799-802: We define the method `ClearNAck()`
- Line 807-810: We define the method `ClearDone()`
- Line 816-822: We define the method `WriteFIFORegister()`
- Line 828-835: We define the method `ReadFIFORegister()`

In principle we could start writing an application, but we'll fake the I2C (and GPIO) functionality first.

### IMemoryAccess.h {#TUTORIAL_21_I2C_BASIC_I2C_FUNCTIONALITY___FAKING_IT___STEP_1_IMEMORYACCESSH}

As we'll be implementing the same kind of functions multiple times, we should see if there is any potential code duplication we can get around.
The methods `ReadModifyWrite8`, `ReadModifyWrite16` and `ReadModifyWrite32` all read a value, manipulate it and then write the result back.
This will be the same for all derived classes, so we'll implement them as part of the interface.

Update the file `code/libraries/baremetal/include/baremetal/IMemoryAccess.h`

```cpp
File: code/libraries/baremetal/include/baremetal/IMemoryAccess.h
...
49: /// <summary>
50: /// Abstract memory access interface
51: /// </summary>
52: class IMemoryAccess
53: {
54: public:
55:     /// <summary>
56:     /// Default destructor needed for abstract interface
57:     /// </summary>
58:     virtual ~IMemoryAccess() = default;
59: 
60:     /// <summary>
61:     /// Read a 8 bit value from register at address
62:     /// </summary>
63:     /// <param name="address">Address of register</param>
64:     /// <returns>8 bit register value</returns>
65:     virtual uint8  Read8(regaddr address) = 0;
66:     /// <summary>
67:     /// Write a 8 bit value to register at address
68:     /// </summary>
69:     /// <param name="address">Address of register</param>
70:     /// <param name="data">Data to write</param>
71:     virtual void   Write8(regaddr address, uint8 data) = 0;
72:     /// <summary>
73:     /// Read, modify and write a 8 bit value to register at address
74:     /// 
75:     /// The operation will read the value from the specified register, then AND it with the inverse of the mask (8 bits) provided
76:     /// The data provided (8 bits) will be masked with the mask provided, shifted left bit shift bits, and then OR'ed with the mask read data
77:     /// The result will then be written back to the register
78:     /// </summary>
79:     /// <param name="address">Address of register</param>
80:     /// <param name="mask">Mask to apply. Value read will be masked with the inverse of mask, then the data (after shift) will be masked with mask before OR'ing with the value read</param>
81:     /// <param name="data">Data to write (after shifting left by shift bits)</param>
82:     /// <param name="shift">Shift to apply to the data to write (shift left)</param>
83:     void ReadModifyWrite8(regaddr address, uint8 mask, uint8 data, uint8 shift)
84:     {
85:         auto value = Read8(address);
86:         value &= ~mask;
87:         value |= ((data << shift) & mask);
88:         Write8(address, value);
89:     }
90: 
91:     ///     /// <summary>
92:     /// Read a 16 bit value from register at address
93:     /// </summary>
94:     /// <param name="address">Address of register</param>
95:     /// <returns>16 bit register value</returns>
96:     virtual uint16 Read16(regaddr address) = 0;
97:     /// <summary>
98:     /// Write a 16 bit value to register at address
99:     /// </summary>
100:     /// <param name="address">Address of register</param>
101:     /// <param name="data">Data to write</param>
102:     virtual void   Write16(regaddr address, uint16 data) = 0;
103:     /// <summary>
104:     /// Read, modify and write a 16 bit value to register at address
105:     /// 
106:     /// The operation will read the value from the specified register, then AND it with the inverse of the mask (16 bits) provided
107:     /// The data provided (16 bits) will be masked with the mask provided, shifted left bit shift bits, and then OR'ed with the mask read data
108:     /// The result will then be written back to the register
109:     /// </summary>
110:     /// <param name="address">Address of register</param>
111:     /// <param name="mask">Mask to apply. Value read will be masked with the inverse of mask, then the data (after shift) will be masked with mask before OR'ing with the value read</param>
112:     /// <param name="data">Data to write (after shifting left by shift bits)</param>
113:     /// <param name="shift">Shift to apply to the data to write (shift left)</param>
114:     void ReadModifyWrite16(regaddr address, uint16 mask, uint16 data, uint8 shift)
115:     {
116:         auto value = Read16(address);
117:         value &= ~mask;
118:         value |= ((data << shift) & mask);
119:         Write16(address, value);
120:     }
121: 
122:     /// <summary>
123:     /// Read a 32 bit value from register at address
124:     /// </summary>
125:     /// <param name="address">Address of register</param>
126:     /// <returns>32 bit register value</returns>
127:     virtual uint32 Read32(regaddr address) = 0;
128:     /// <summary>
129:     /// Write a 32 bit value to register at address
130:     /// </summary>
131:     /// <param name="address">Address of register</param>
132:     /// <param name="data">Data to write</param>
133:     virtual void   Write32(regaddr address, uint32 data) = 0;
134:     /// <summary>
135:     /// Read, modify and write a 32 bit value to register at address
136:     /// 
137:     /// The operation will read the value from the specified register, then AND it with the inverse of the mask (32 bits) provided
138:     /// The data provided (32 bits) will be masked with the mask provided, shifted left bit shift bits, and then OR'ed with the mask read data
139:     /// The result will then be written back to the register
140:     /// </summary>
141:     /// <param name="address">Address of register</param>
142:     /// <param name="mask">Mask to apply. Value read will be masked with the inverse of mask, then the data (after shift) will be masked with mask before OR'ing with the value read</param>
143:     /// <param name="data">Data to write (after shifting left by shift bits)</param>
144:     /// <param name="shift">Shift to apply to the data to write (shift left)</param>
145:     void ReadModifyWrite32(regaddr address, uint32 mask, uint32 data, uint8 shift)
146:     {
147:         auto value = Read32(address);
148:         value &= ~mask;
149:         value |= ((data << shift) & mask);
150:         Write32(address, value);
151:     }
152: 
153: };
...
```

- Line 83-89: Instead of declaring a pure virtual method `ReadModifyWrite8()`, we implement it directly in the interface
- Line 114--120: Instead of declaring a pure virtual method `ReadModifyWrite16()`, we implement it directly in the interface
- Line 145-151: Instead of declaring a pure virtual method `ReadModifyWrite32()`, we implement it directly in the interface

### MemoryAccess.h {#TUTORIAL_21_I2C_BASIC_I2C_FUNCTIONALITY___FAKING_IT___STEP_1_MEMORYACCESSH}

We'll remove the three methods mentioned above from `MemoryAccess`.

Update the file `code/libraries/baremetal/include/baremetal/MemoryAccess.h`

```cpp
File: code/libraries/baremetal/include/baremetal/MemoryAccess.h
...
49: /// <summary>
50: /// Memory access interface
51: /// </summary>
52: class MemoryAccess : public IMemoryAccess
53: {
54: public:
55:     uint8  Read8(regaddr address) override;
56:     void   Write8(regaddr address, uint8 data) override;
57: 
58:     uint16 Read16(regaddr address) override;
59:     void   Write16(regaddr address, uint16 data) override;
60: 
61:     uint32 Read32(regaddr address) override;
62:     void   Write32(regaddr address, uint32 data) override;
63: };
...
```

### MemoryAccess.cpp {#TUTORIAL_21_I2C_BASIC_I2C_FUNCTIONALITY___FAKING_IT___STEP_1_MEMORYACCESSCPP}

We'll also remove the three methods mentioned above from the `MemoryAccess` implementation.

Update the file `code/libraries/baremetal/src/MemoryAccess.cpp`

```cpp
File: code/libraries/baremetal/src/MemoryAccess.cpp
...
47: /// <summary>
48: /// Read a 8 bit value from register at address
49: /// </summary>
50: /// <param name="address">Address of register</param>
51: /// <returns>8 bit register value</returns>
52: uint8 MemoryAccess::Read8(regaddr address)
53: {
54:     return *reinterpret_cast<uint8 volatile *>(address);
55: }
56: 
57: /// <summary>
58: /// Write a 8 bit value to register at address
59: /// </summary>
60: /// <param name="address">Address of register</param>
61: /// <param name="data">Data to write</param>
62: void MemoryAccess::Write8(regaddr address, uint8 data)
63: {
64:     *reinterpret_cast<uint8 volatile *>(address) = data;
65: }
66: 
67: /// <summary>
68: /// Read a 16 bit value from register at address
69: /// </summary>
70: /// <param name="address">Address of register</param>
71: /// <returns>16 bit register value</returns>
72: uint16 MemoryAccess::Read16(regaddr address)
73: {
74:     return *reinterpret_cast<uint16 volatile *>(address);
75: }
76: 
77: /// <summary>
78: /// Write a 16 bit value to register at address
79: /// </summary>
80: /// <param name="address">Address of register</param>
81: /// <param name="data">Data to write</param>
82: void MemoryAccess::Write16(regaddr address, uint16 data)
83: {
84:     *reinterpret_cast<uint16 volatile *>(address) = data;
85: }
86: 
87: /// <summary>
88: /// Read a 32 bit value from register at address
89: /// </summary>
90: /// <param name="address">Address of register</param>
91: /// <returns>32 bit register value</returns>
92: uint32 MemoryAccess::Read32(regaddr address)
93: {
94:     return *reinterpret_cast<uint32 volatile *>(address);
95: }
96: 
97: /// <summary>
98: /// Write a 32 bit value to register at address
99: /// </summary>
100: /// <param name="address">Address of register</param>
101: /// <param name="data">Data to write</param>
102: void MemoryAccess::Write32(regaddr address, uint32 data)
103: {
104:     *reinterpret_cast<uint32 volatile *>(address) = data;
105: }
106: 
107: /// <summary>
108: /// Construct the singleton memory access interface if needed, and return a reference to the instance
109: /// </summary>
110: /// <returns>Reference to the singleton memory access interface</returns>
111: MemoryAccess &baremetal::GetMemoryAccess()
112: {
113:     static MemoryAccess value;
114:     return value;
115: }
...
```

### MemoryAccessStubGPIO.h {#TUTORIAL_21_I2C_BASIC_I2C_FUNCTIONALITY___FAKING_IT___STEP_1_MEMORYACCESSSTUBGPIOH}

We'll define a `MemoryAccess` implementation that will fake the GPIO register access.

Create the file `code/libraries/baremetal/include/baremetal/stubs/MemoryAccessStubGPIO.h`

```cpp
File: code/libraries/baremetal/include/baremetal/stubs/MemoryAccessStubGPIO.h
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MemoryAccessStubGPIO.h
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : MemoryAccessStubGPIO
9: //
10: // Description : GPIO register memory access stub
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39: 
40: #pragma once
41: 
42: #include <stdlib/Macros.h>
43: #include <baremetal/IMemoryAccess.h>
44: 
45: /// @file
46: /// MemoryAccessStubGPIO
47: 
48: namespace baremetal {
49: 
50: /// @brief GPIO registers storage
51: struct GPIORegisters
52: {
53:     /// @brief RPI_GPIO_GPFSEL0 value
54:     uint32 FunctionSelect0;             // 0x00
55:     /// @brief RPI_GPIO_GPFSEL1 value
56:     uint32 FunctionSelect1;             // 0x04
57:     /// @brief RPI_GPIO_GPFSEL2 value
58:     uint32 FunctionSelect2;             // 0x08
59:     /// @brief RPI_GPIO_GPFSEL3 value
60:     uint32 FunctionSelect3;             // 0x0C
61:     /// @brief RPI_GPIO_GPFSEL4 value
62:     uint32 FunctionSelect4;             // 0x10
63:     /// @brief RPI_GPIO_GPFSEL5 value
64:     uint32 FunctionSelect5;             // 0x14
65:     /// @brief Reserved value
66:     uint32 Reserved_1;                  // 0x18
67:     /// @brief RPI_GPIO_GPSET0 value
68:     uint32 Set0;                        // 0x1C
69:     /// @brief RPI_GPIO_GPSET1 value
70:     uint32 Set1;                        // 0x20
71:     /// @brief Reserved value
72:     uint32 Reserved_2;                  // 0x24
73:     /// @brief RPI_GPIO_GPCLR0 value
74:     uint32 Clear0;                      // 0x28
75:     /// @brief RPI_GPIO_GPCLR1 value
76:     uint32 Clear1;                      // 0x2C
77:     /// @brief Reserved value
78:     uint32 Reserved_3;                  // 0x30
79:     /// @brief RPI_GPIO_GPLEV0 value
80:     uint32 PinLevel0;                   // 0x34
81:     /// @brief RPI_GPIO_GPLEV1 value
82:     uint32 PinLevel1;                   // 0x38
83:     /// @brief Reserved value
84:     uint32 Reserved_4;                  // 0x3C
85:     /// @brief RPI_GPIO_GPEDS0 value
86:     uint32 EventDetectStatus0;          // 0x40
87:     /// @brief RPI_GPIO_GPEDS1 value
88:     uint32 EventDetectStatus1;          // 0x44
89:     /// @brief Reserved value
90:     uint32 Reserved_5;                  // 0x48
91:     /// @brief RPI_GPIO_GPREN0 value
92:     uint32 RisingEdgeDetectEn0;         // 0x4C
93:     /// @brief RPI_GPIO_GPREN1 value
94:     uint32 RisingEdgeDetectEn1;         // 0x50
95:     /// @brief Reserved value
96:     uint32 Reserved_6;                  // 0x54
97:     /// @brief RPI_GPIO_GPFEN0 value
98:     uint32 FallingEdgeDetectEn0;        // 0x58
99:     /// @brief RPI_GPIO_GPFEN1 value
100:     uint32 FallingEdgeDetectEn1;        // 0x5C
101:     /// @brief Reserved value
102:     uint32 Reserved_7;                  // 0x60
103:     /// @brief RPI_GPIO_GPHEN0 value
104:     uint32 HighDetectEn0;               // 0x64
105:     /// @brief RPI_GPIO_GPHEN1 value
106:     uint32 HighDetectEn1;               // 0x68
107:     /// @brief Reserved value
108:     uint32 Reserved_8;                  // 0x6C
109:     /// @brief RPI_GPIO_GPLEN0 value
110:     uint32 LowDetectEn0;                // 0x70
111:     /// @brief RPI_GPIO_GPLEN1 value
112:     uint32 LowDetectEn1;                // 0x74
113:     /// @brief Reserved value
114:     uint32 Reserved_9;                  // 0x78
115:     /// @brief RPI_GPIO_GPAREN0 value
116:     uint32 AsyncRisingEdgeDetectEn0;    // 0x7C
117:     /// @brief RPI_GPIO_GPAREN1 value
118:     uint32 AsyncRisingEdgeDetectEn1;    // 0x80
119:     /// @brief Reserved value
120:     uint32 Reserved_10;                 // 0x84
121:     /// @brief RPI_GPIO_GPAFEN0 value
122:     uint32 AsyncFallingEdgeDetectEn0;   // 0x88
123:     /// @brief RPI_GPIO_GPAFEN1 value
124:     uint32 AsyncFallingEdgeDetectEn1;   // 0x8C
125:     /// @brief Reserved value
126:     uint32 Reserved_11;                 // 0x90
127:     /// @brief RPI_GPIO_GPPUD value
128:     uint32 PullUpDownEnable;            // 0x94
129:     /// @brief RPI_GPIO_GPPUDCLK0 value
130:     uint32 PullUpDownEnableClock0;      // 0x98
131:     /// @brief RPI_GPIO_GPPUDCLK1 value
132:     uint32 PullUpDownEnableClock1;      // 0x9C
133:     /// @brief Reserved value
134:     uint32 Reserved_12[4];              // 0xA0-AC
135:     /// @brief Test register value
136:     uint32 Test;                        // 0xB0
137: #if BAREMETAL_RPI_TARGET >= 4
138:     /// @brief Reserved value
139:     uint32 Reserved_13[12];             // 0xB4-E0
140:     /// @brief RPI_GPIO_GPPUPPDN0 value
141:     uint32 PullUpDown0;                 // 0xE4
142:     /// @brief RPI_GPIO_GPPUPPDN1 value
143:     uint32 PullUpDown1;                 // 0xE8
144:     /// @brief RPI_GPIO_GPPUPPDN2 value
145:     uint32 PullUpDown2;                 // 0xEC
146:     /// @brief RPI_GPIO_GPPUPPDN3 value
147:     uint32 PullUpDown3;                 // 0xF0
148:     /// @brief Reserved value
149:     uint32 Reserved_14[3];              // 0xF4-FC: Alignment
150: #endif
151: 
152:     /// <summary>
153:     /// Constructor for GPIORegisters
154:     /// 
155:     /// Sets default register values
156:     /// </summary>
157:     GPIORegisters()
158:         : FunctionSelect0{}
159:         , FunctionSelect1{}
160:         , FunctionSelect2{}
161:         , FunctionSelect3{}
162:         , FunctionSelect4{}
163:         , FunctionSelect5{}
164:         , Reserved_1{}
165:         , Set0{}
166:         , Set1{}
167:         , Reserved_2{}
168:         , Clear0{}
169:         , Clear1{}
170:         , Reserved_3{}
171:         , PinLevel0{}
172:         , PinLevel1{}
173:         , Reserved_4{}
174:         , EventDetectStatus0{}
175:         , EventDetectStatus1{}
176:         , Reserved_5{}
177:         , RisingEdgeDetectEn0{}
178:         , RisingEdgeDetectEn1{}
179:         , Reserved_6{}
180:         , FallingEdgeDetectEn0{}
181:         , FallingEdgeDetectEn1{}
182:         , Reserved_7{}
183:         , HighDetectEn0{}
184:         , HighDetectEn1{}
185:         , Reserved_8{}
186:         , LowDetectEn0{}
187:         , LowDetectEn1{}
188:         , Reserved_9{}
189:         , AsyncRisingEdgeDetectEn0{}
190:         , AsyncRisingEdgeDetectEn1{}
191:         , Reserved_10{}
192:         , AsyncFallingEdgeDetectEn0{}
193:         , AsyncFallingEdgeDetectEn1{}
194:         , Reserved_11{}
195:         , PullUpDownEnable{}
196:         , PullUpDownEnableClock0{}
197:         , PullUpDownEnableClock1{}
198:         , Reserved_12{}
199:         , Test{}
200: #if BAREMETAL_RPI_TARGET >= 4
201:         , Reserved_13{}
202:         , PullUpDown0{0xAAA95555}
203:         , PullUpDown1{0xA0AAAAAA}
204:         , PullUpDown2{0x50AAA95A}
205:         , PullUpDown3{ 0x00055555 }
206:         , Reserved_14{}
207: #endif
208:     {
209:     }
210: } PACKED;
211: 
212: /// @brief MemoryAccess implementation for GPIO stub
213: class MemoryAccessStubGPIO:
214:     public IMemoryAccess
215: {
216: private:
217:     /// @brief Saved GPIO register values
218:     GPIORegisters m_registers;
219: 
220: public:
221:     MemoryAccessStubGPIO();
222:     uint8  Read8(regaddr address) override;
223:     void   Write8(regaddr address, uint8 data) override;
224: 
225:     uint16 Read16(regaddr address) override;
226:     void   Write16(regaddr address, uint16 data) override;
227: 
228:     uint32 Read32(regaddr address) override;
229:     void   Write32(regaddr address, uint32 data) override;
230: 
231: private:
232:     uint32 GetRegisterOffset(regaddr address);
233: };
234: 
235: } // namespace baremetal
```

- Line 51-150: We declare a struct `GPIORegisters` to hold the values of the different GPIO registers.
For Raspberry Pi 4 there are a few more registers.
Note that there are also some `Reserved_` registers which are needed for correct addressing, but are not used
- Line 157-209: We define the constructor for `GPIORegisters` to initialize to the default (power-on) values
- Line 213-234: We declare the class `MemoryAccessStubGPIO` which is the GPIO MemoryAccess stub, and implements the `IMemoryAccess` interface
  - Line 218: We declare a member variable `m_registers` that hold the GPIO register values
  - Line 232: We declare a method `GetRegisterOffset()` to convert a GPIO register address to a GPIO register offset

### MemoryAccessStubGPIO.cpp {#TUTORIAL_21_I2C_BASIC_I2C_FUNCTIONALITY___FAKING_IT___STEP_1_MEMORYACCESSSTUBGPIOCPP}

We will implement the stub.

Create file `code/libraries/baremetal/src/stubs/MemoryAccessStubGPIO.cpp`

```cpp
File: code/libraries/baremetal/src/stubs/MemoryAccessStubGPIO.cpp
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MemoryAccessStubGPIO.cpp
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : MemoryAccessStubGPIO
9: //
10: // Description : GPIO register memory access stub implementation
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39: 
40: #include <baremetal/stubs/MemoryAccessStubGPIO.h>
41: 
42: #include <baremetal/Assert.h>
43: #include <baremetal/BCMRegisters.h>
44: #include <baremetal/Format.h>
45: #include <baremetal/Logger.h>
46: #include <baremetal/String.h>
47: 
48: /// @file
49: /// MemoryAccessStubGPIO
50: 
51: /// @brief Define log name
52: LOG_MODULE("MemoryAccessStubGPIO");
53: 
54: using namespace baremetal;
55: 
56: /// @brief GPIO base address
57: static uintptr GPIOBaseAddress{ RPI_GPIO_BASE };
58: /// @brief Mask used to check whether an address is in the GPIO register range
59: static uintptr GPIOBaseAddressMask{ 0xFFFFFFFFFFFFFF00 };
60: 
61: /// <summary>
62: /// MemoryAccessStubGPIO constructor
63: /// </summary>
64: MemoryAccessStubGPIO::MemoryAccessStubGPIO()
65:     : m_registers{}
66: {
67: }
68: 
69: /// <summary>
70: /// Read a 8 bit value from register at address
71: /// </summary>
72: /// <param name="address">Address of register</param>
73: /// <returns>8 bit register value</returns>
74: uint8 MemoryAccessStubGPIO::Read8(regaddr address)
75: {
76:     LOG_PANIC("Call to Read8 should not happen");
77:     return {};
78: }
79: 
80: /// <summary>
81: /// Write a 8 bit value to register at address
82: /// </summary>
83: /// <param name="address">Address of register</param>
84: /// <param name="data">Data to write</param>
85: void MemoryAccessStubGPIO::Write8(regaddr address, uint8 data)
86: {
87:     LOG_PANIC("Call to Write8 should not happen");
88: }
89: 
90: /// <summary>
91: /// Read a 16 bit value from register at address
92: /// </summary>
93: /// <param name="address">Address of register</param>
94: /// <returns>16 bit register value</returns>
95: uint16 MemoryAccessStubGPIO::Read16(regaddr address)
96: {
97:     LOG_PANIC("Call to Read16 should not happen");
98:     return {};
99: }
100: 
101: /// <summary>
102: /// Write a 16 bit value to register at address
103: /// </summary>
104: /// <param name="address">Address of register</param>
105: /// <param name="data">Data to write</param>
106: void MemoryAccessStubGPIO::Write16(regaddr address, uint16 data)
107: {
108:     LOG_PANIC("Call to Write16 should not happen");
109: }
110: 
111: /// <summary>
112: /// Read a 32 bit value from register at address
113: /// </summary>
114: /// <param name="address">Address of register</param>
115: /// <returns>32 bit register value</returns>
116: uint32 MemoryAccessStubGPIO::Read32(regaddr address)
117: {
118:     uintptr offset = GetRegisterOffset(address);
119:     uint32* registerField = reinterpret_cast<uint32*>(reinterpret_cast<uint8*>(&m_registers) + offset);
120: //    LOG_INFO("GPIO read register %016x = %08x", offset, *registerField);
121:     switch (offset)
122:     {
123:         case RPI_GPIO_GPFSEL0_OFFSET:
124:         case RPI_GPIO_GPFSEL1_OFFSET:
125:         case RPI_GPIO_GPFSEL2_OFFSET:
126:         case RPI_GPIO_GPFSEL3_OFFSET:
127:         case RPI_GPIO_GPFSEL4_OFFSET:
128:         case RPI_GPIO_GPFSEL5_OFFSET:
129:         {
130:             uint8 pinBase = (offset - RPI_GPIO_GPFSEL0_OFFSET) / 4 * 10;
131:             string line{ "GPIO Read Pin Mode "};
132:             for (uint8 pinIndex = 0; pinIndex < 10; ++pinIndex)
133:             {
134:                 int shift = pinIndex * 3;
135:                 uint8 pin = pinBase + pinIndex;
136:                 uint8 pinMode = (*registerField >> shift) & 0x00000007;
137:                 line += Format(" - Pin %d mode %x", pin, pinMode);
138:             }
139:             LOG_INFO(line.c_str());
140:             break;
141:         }
142:         case RPI_GPIO_GPLEV0_OFFSET:
143:         case RPI_GPIO_GPLEV1_OFFSET:
144:         {
145:             uint8 pinBase = (offset - RPI_GPIO_GPLEV0_OFFSET)  / 4 * 32;
146:             string line{ "GPIO Read Pin Level "};
147:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
148:             {
149:                 int shift = pinIndex;
150:                 uint8 pin = pinBase + pinIndex;
151:                 uint8 value = (*registerField >> shift) & 0x00000001;
152:                 if (value)
153:                     line += " - Pin %d ON ";
154:                 else
155:                     line += " - Pin %d OFF";
156:             }
157:             LOG_INFO(line.c_str());
158:             break;
159:         }
160:         case RPI_GPIO_GPEDS0_OFFSET:
161:         case RPI_GPIO_GPEDS1_OFFSET:
162:         {
163:             uint8 pinBase = (offset - RPI_GPIO_GPEDS0_OFFSET)  / 4 * 32;
164:             string line{ "GPIO Read Pin Event Detect Status "};
165:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
166:             {
167:                 int shift = pinIndex;
168:                 uint8 pin = pinBase + pinIndex;
169:                 uint8 value = (*registerField >> shift) & 0x00000001;
170:                 if (value)
171:                     line += " - Pin %d ON ";
172:                 else
173:                     line += " - Pin %d OFF";
174:             }
175:             LOG_INFO(line.c_str());
176:             break;
177:         }
178:         case RPI_GPIO_GPREN0_OFFSET:
179:         case RPI_GPIO_GPREN1_OFFSET:
180:         {
181:             uint8 pinBase = (offset - RPI_GPIO_GPREN0_OFFSET)  / 4 * 32;
182:             string line{ "GPIO Read Pin Rising Edge Detect Enable "};
183:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
184:             {
185:                 int shift = pinIndex;
186:                 uint8 pin = pinBase + pinIndex;
187:                 uint8 value = (*registerField >> shift) & 0x00000001;
188:                 if (value)
189:                     line += Format(" - Pin %d ON ", pin);
190:                 else
191:                     line += Format(" - Pin %d OFF", pin);
192:             }
193:             LOG_INFO(line.c_str());
194:             break;
195:         }
196:         case RPI_GPIO_GPFEN0_OFFSET:
197:         case RPI_GPIO_GPFEN1_OFFSET:
198:         {
199:             uint8 pinBase = (offset - RPI_GPIO_GPFEN0_OFFSET)  / 4 * 32;
200:             string line{ "GPIO Read Pin Falling Edge Detect Enable "};
201:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
202:             {
203:                 int shift = pinIndex;
204:                 uint8 pin = pinBase + pinIndex;
205:                 uint8 value = (*registerField >> shift) & 0x00000001;
206:                 if (value)
207:                     line += Format(" - Pin %d ON ", pin);
208:                 else
209:                     line += Format(" - Pin %d OFF", pin);
210:             }
211:             LOG_INFO(line.c_str());
212:             break;
213:         }
214:         case RPI_GPIO_GPHEN0_OFFSET:
215:         case RPI_GPIO_GPHEN1_OFFSET:
216:         {
217:             uint8 pinBase = (offset - RPI_GPIO_GPHEN0_OFFSET)  / 4 * 32;
218:             string line{ "GPIO Read Pin High Level Detect Enable "};
219:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
220:             {
221:                 int shift = pinIndex;
222:                 uint8 pin = pinBase + pinIndex;
223:                 uint8 value = (*registerField >> shift) & 0x00000001;
224:                 if (value)
225:                     line += Format(" - Pin %d ON ", pin);
226:                 else
227:                     line += Format(" - Pin %d OFF", pin);
228:             }
229:             LOG_INFO(line.c_str());
230:             break;
231:         }
232:         case RPI_GPIO_GPLEN0_OFFSET:
233:         case RPI_GPIO_GPLEN1_OFFSET:
234:         {
235:             uint8 pinBase = (offset - RPI_GPIO_GPLEN0_OFFSET)  / 4 * 32;
236:             string line{ "GPIO Read Pin Low Level Detect Enable "};
237:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
238:             {
239:                 int shift = pinIndex;
240:                 uint8 pin = pinBase + pinIndex;
241:                 uint8 value = (*registerField >> shift) & 0x00000001;
242:                 if (value)
243:                     line += Format(" - Pin %d ON ", pin);
244:                 else
245:                     line += Format(" - Pin %d OFF", pin);
246:             }
247:             LOG_INFO(line.c_str());
248:             break;
249:         }
250:         case RPI_GPIO_GPAREN0_OFFSET:
251:         case RPI_GPIO_GPAREN1_OFFSET:
252:         {
253:             uint8 pinBase = (offset - RPI_GPIO_GPAREN0_OFFSET)  / 4 * 32;
254:             string line{ "GPIO Read Pin Async Rising Edge Detect Enable "};
255:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
256:             {
257:                 int shift = pinIndex;
258:                 uint8 pin = pinBase + pinIndex;
259:                 uint8 value = (*registerField >> shift) & 0x00000001;
260:                 if (value)
261:                     line += Format(" - Pin %d ON ", pin);
262:                 else
263:                     line += Format(" - Pin %d OFF", pin);
264:             }
265:             LOG_INFO(line.c_str());
266:             break;
267:         }
268:         case RPI_GPIO_GPAFEN0_OFFSET:
269:         case RPI_GPIO_GPAFEN1_OFFSET:
270:         {
271:             uint8 pinBase = (offset - RPI_GPIO_GPAFEN0_OFFSET)  / 4 * 32;
272:             string line{ "GPIO Read Pin Async Falling Edge Detect Enable "};
273:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
274:             {
275:                 int shift = pinIndex;
276:                 uint8 pin = pinBase + pinIndex;
277:                 uint8 value = (*registerField >> shift) & 0x00000001;
278:                 if (value)
279:                     line += Format(" - Pin %d ON ", pin);
280:                 else
281:                     line += Format(" - Pin %d OFF", pin);
282:             }
283:             LOG_INFO(line.c_str());
284:             break;
285:         }
286: #if BAREMETAL_RPI_TARGET == 3
287:         case RPI_GPIO_GPPUD_OFFSET:
288:         {
289:             uint8 value = *registerField & 0x00000003;
290:             LOG_INFO("GPIO Read Pull Up/Down Mode %x", value);
291:             break;
292:         }
293:         case RPI_GPIO_GPPUDCLK0_OFFSET:
294:         case RPI_GPIO_GPPUDCLK1_OFFSET:
295:         {
296:             uint8 pinBase = (offset - RPI_GPIO_GPPUDCLK0_OFFSET) / 4 * 32;
297:             string line{ "GPIO Read Pin Pull Up/Down Enable Clock "};
298:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
299:             {
300:                 int shift = pinIndex;
301:                 uint8 pin = pinBase + pinIndex;
302:                 uint8 value = (*registerField >> shift) & 0x00000001;
303:                 if (value)
304:                     line += Format(" - Pin %d ON ", pin);
305:                 else
306:                     line += Format(" - Pin %d OFF", pin);
307:             }
308:             LOG_INFO(line.c_str());
309:             break;
310:         }
311: #elif BAREMETAL_RPI_TARGET == 4
312:         case RPI_GPIO_GPPINMUXSD_OFFSET:
313:         {
314:             uint32 value = *registerField;
315:             LOG_INFO("GPIO Read Pin Mux Mode %x", value);
316:             break;
317:         }
318:         case RPI_GPIO_GPPUPPDN0_OFFSET:
319:         case RPI_GPIO_GPPUPPDN1_OFFSET:
320:         case RPI_GPIO_GPPUPPDN2_OFFSET:
321:         case RPI_GPIO_GPPUPPDN3_OFFSET:
322:         {
323:             uint8 pinBase = (offset - RPI_GPIO_GPPUPPDN0_OFFSET) / 4 * 16;
324:             string line{ "GPIO Read Pin Pull Up/Down Mode "};
325:             for (uint8 pinIndex = 0; pinIndex < 16; ++pinIndex)
326:             {
327:                 int shift = pinIndex * 2;
328:                 uint8 pin = pinBase + pinIndex;
329:                 uint8 value = (*registerField >> shift) & 0x00000003;
330:                 line += Format(" - Pin %d Pull up/down mode %x", pin, value);
331:             }
332:             LOG_INFO(line.c_str());
333:             break;
334:         }
335: #endif
336:         default:
337:             LOG_ERROR("Invalid register access for reading: offset %d", offset);
338:             break;
339:     }
340:     return *registerField;
341: }
342: 
343: /// <summary>
344: /// Write a 32 bit value to register at address
345: /// </summary>
346: /// <param name="address">Address of register</param>
347: /// <param name="data">Data to write</param>
348: void MemoryAccessStubGPIO::Write32(regaddr address, uint32 data)
349: {
350:     uintptr offset = GetRegisterOffset(address);
351:     uint32* registerField = reinterpret_cast<uint32*>(reinterpret_cast<uint8*>(&m_registers) + offset);
352: //    LOG_INFO("GPIO write register %016x = %08x", offset, data);
353:     switch (offset)
354:     {
355:         case RPI_GPIO_GPFSEL0_OFFSET:
356:         case RPI_GPIO_GPFSEL1_OFFSET:
357:         case RPI_GPIO_GPFSEL2_OFFSET:
358:         case RPI_GPIO_GPFSEL3_OFFSET:
359:         case RPI_GPIO_GPFSEL4_OFFSET:
360:         case RPI_GPIO_GPFSEL5_OFFSET:
361:         {
362:             uint8 pinBase = (offset - RPI_GPIO_GPFSEL0_OFFSET) / 4 * 10;
363:             uint32 diff = data ^ *registerField;
364:             for (uint8 pinIndex = 0; pinIndex < 10; ++pinIndex)
365:             {
366:                 int shift = pinIndex * 3;
367:                 if (((diff >> shift) & 0x00000007) != 0)
368:                 {
369:                     uint8 pin = pinBase + pinIndex;
370:                     uint8 pinMode = (data >> shift) & 0x00000007;
371:                     LOG_INFO("GPIO Set Pin %d mode to %x", pin, pinMode);
372:                 }
373:             }
374:             break;
375:         }
376:         case RPI_GPIO_GPSET0_OFFSET:
377:         case RPI_GPIO_GPSET1_OFFSET:
378:         {
379:             uint8 pinBase = (offset - RPI_GPIO_GPSET0_OFFSET) / 4 * 32;
380:             uint32 diff = data ^ *registerField;
381:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
382:             {
383:                 int shift = pinIndex;
384:                 if (((diff >> shift) & 0x00000001) != 0)
385:                 {
386:                     uint8 pin = pinBase + pinIndex;
387:                     uint8 value = (data >> shift) & 0x00000001;
388:                     if (value != 0)
389:                         LOG_INFO("GPIO Set Pin %d ON", pin);
390:                 }
391:             }
392:             break;
393:         }
394:         case RPI_GPIO_GPCLR0_OFFSET:
395:         case RPI_GPIO_GPCLR1_OFFSET:
396:         {
397:             uint8 pinBase = (offset - RPI_GPIO_GPCLR0_OFFSET)  / 4 * 32;
398:             uint32 diff = data ^ *registerField;
399:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
400:             {
401:                 int shift = pinIndex;
402:                 if (((diff >> shift) & 0x00000001) != 0)
403:                 {
404:                     uint8 pin = pinBase + pinIndex;
405:                     uint8 value = (data >> shift) & 0x00000001;
406:                     if (value != 0)
407:                         LOG_INFO("GPIO Set Pin %d OFF", pin);
408:                 }
409:             }
410:             break;
411:         }
412:         case RPI_GPIO_GPEDS0_OFFSET:
413:         case RPI_GPIO_GPEDS1_OFFSET:
414:         {
415:             uint8 pinBase = (offset - RPI_GPIO_GPEDS0_OFFSET)  / 4 * 32;
416:             uint32 diff = data ^ *registerField;
417:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
418:             {
419:                 int shift = pinIndex;
420:                 if (((diff >> shift) & 0x00000001) != 0)
421:                 {
422:                     uint8 pin = pinBase + pinIndex;
423:                     uint8 value = (data >> shift) & 0x00000001;
424:                     if (value != 0)
425:                         LOG_INFO("GPIO Clear Pin %d Event Status", pin);
426:                 }
427:             }
428:             break;
429:         }
430:         case RPI_GPIO_GPREN0_OFFSET:
431:         case RPI_GPIO_GPREN1_OFFSET:
432:         {
433:             uint8 pinBase = (offset - RPI_GPIO_GPREN0_OFFSET)  / 4 * 32;
434:             uint32 diff = data ^ *registerField;
435:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
436:             {
437:                 int shift = pinIndex;
438:                 if (((diff >> shift) & 0x00000001) != 0)
439:                 {
440:                     uint8 pin = pinBase + pinIndex;
441:                     uint8 value = (data >> shift) & 0x00000001;
442:                     if (value != 0)
443:                         LOG_INFO("GPIO Set Pin %d Rising Edge Detect ON", pin);
444:                     else
445:                         LOG_INFO("GPIO Set Pin %d Rising Edge Detect OFF", pin);
446:                 }
447:             }
448:             break;
449:         }
450:         case RPI_GPIO_GPFEN0_OFFSET:
451:         case RPI_GPIO_GPFEN1_OFFSET:
452:         {
453:             uint8 pinBase = (offset - RPI_GPIO_GPFEN0_OFFSET)  / 4 * 32;
454:             uint32 diff = data ^ *registerField;
455:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
456:             {
457:                 int shift = pinIndex;
458:                 if (((diff >> shift) & 0x00000001) != 0)
459:                 {
460:                     uint8 pin = pinBase + pinIndex;
461:                     uint8 value = (data >> shift) & 0x00000001;
462:                     if (value != 0)
463:                         LOG_INFO("GPIO Set Pin %d Falling Edge Detect ON", pin);
464:                     else
465:                         LOG_INFO("GPIO Set Pin %d Falling Edge Detect OFF", pin);
466:                 }
467:             }
468:             break;
469:         }
470:         case RPI_GPIO_GPHEN0_OFFSET:
471:         case RPI_GPIO_GPHEN1_OFFSET:
472:         {
473:             uint8 pinBase = (offset - RPI_GPIO_GPHEN0_OFFSET)  / 4 * 32;
474:             uint32 diff = data ^ *registerField;
475:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
476:             {
477:                 int shift = pinIndex;
478:                 if (((diff >> shift) & 0x00000001) != 0)
479:                 {
480:                     uint8 pin = pinBase + pinIndex;
481:                     uint8 value = (data >> shift) & 0x00000001;
482:                     if (value != 0)
483:                         LOG_INFO("GPIO Set Pin %d High Level Detect ON", pin);
484:                     else
485:                         LOG_INFO("GPIO Set Pin %d High Level Detect OFF", pin);
486:                 }
487:             }
488:             break;
489:         }
490:         case RPI_GPIO_GPLEN0_OFFSET:
491:         case RPI_GPIO_GPLEN1_OFFSET:
492:         {
493:             uint8 pinBase = (offset - RPI_GPIO_GPLEN0_OFFSET)  / 4 * 32;
494:             uint32 diff = data ^ *registerField;
495:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
496:             {
497:                 int shift = pinIndex;
498:                 if (((diff >> shift) & 0x00000001) != 0)
499:                 {
500:                     uint8 pin = pinBase + pinIndex;
501:                     uint8 value = (data >> shift) & 0x00000001;
502:                     if (value != 0)
503:                         LOG_INFO("GPIO Set Pin %d Low Level Detect ON", pin);
504:                     else
505:                         LOG_INFO("GPIO Set Pin %d Low Level Detect OFF", pin);
506:                 }
507:             }
508:             break;
509:         }
510:         case RPI_GPIO_GPAREN0_OFFSET:
511:         case RPI_GPIO_GPAREN1_OFFSET:
512:         {
513:             uint8 pinBase = (offset - RPI_GPIO_GPAREN0_OFFSET)  / 4 * 32;
514:             uint32 diff = data ^ *registerField;
515:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
516:             {
517:                 int shift = pinIndex;
518:                 if (((diff >> shift) & 0x00000001) != 0)
519:                 {
520:                     uint8 pin = pinBase + pinIndex;
521:                     uint8 value = (data >> shift) & 0x00000001;
522:                     if (value != 0)
523:                         LOG_INFO("GPIO Set Pin %d Async Rising Edge Detect ON", pin);
524:                     else
525:                         LOG_INFO("GPIO Set Pin %d Async Rising Edge Detect OFF", pin);
526:                 }
527:             }
528:             break;
529:         }
530:         case RPI_GPIO_GPAFEN0_OFFSET:
531:         case RPI_GPIO_GPAFEN1_OFFSET:
532:         {
533:             uint8 pinBase = (offset - RPI_GPIO_GPAFEN0_OFFSET)  / 4 * 32;
534:             uint32 diff = data ^ *registerField;
535:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
536:             {
537:                 int shift = pinIndex;
538:                 if (((diff >> shift) & 0x00000001) != 0)
539:                 {
540:                     uint8 pin = pinBase + pinIndex;
541:                     uint8 value = (data >> shift) & 0x00000001;
542:                     if (value != 0)
543:                         LOG_INFO("GPIO Set Pin %d Async Falling Edge Detect ON", pin);
544:                     else
545:                         LOG_INFO("GPIO Set Pin %d Async Falling Edge Detect OFF", pin);
546:                 }
547:             }
548:             break;
549:         }
550: #if BAREMETAL_RPI_TARGET == 3
551:         case RPI_GPIO_GPPUD_OFFSET:
552:         {
553:             uint32 diff = data ^ *registerField;
554:             if ((diff & 0x00000003) != 0)
555:             {
556:                 uint8 value = data & 0x00000003;
557:                 LOG_INFO("GPIO Set Pin Pull Up/Down Mode %x", value);
558:             }
559:             break;
560:         }
561:         case RPI_GPIO_GPPUDCLK0_OFFSET:
562:         case RPI_GPIO_GPPUDCLK1_OFFSET:
563:         {
564:             uint8 pinBase = (offset - RPI_GPIO_GPPUDCLK0_OFFSET) / 4 * 32;
565:             uint32 diff = data ^ *registerField;
566:             for (uint8 pinIndex = 0; pinIndex < 32; ++pinIndex)
567:             {
568:                 int shift = pinIndex;
569:                 if (((diff >> shift) & 0x00000001) != 0)
570:                 {
571:                     uint8 pin = pinBase + pinIndex;
572:                     uint8 value = (data >> shift) & 0x00000001;
573:                     if (value != 0)
574:                         LOG_INFO("GPIO Set Pin %d Pull Up/Down Enable Clock ON", pin);
575:                     else
576:                         LOG_INFO("GPIO Set Pin %d Pull Up/Down Enable Clock OFF", pin);
577:                 }
578:             }
579:             break;
580:         }
581: #elif BAREMETAL_RPI_TARGET == 4
582:         case RPI_GPIO_GPPINMUXSD_OFFSET:
583:         {
584:             uint32 value = *registerField;
585:             LOG_INFO("GPIO Set Pin Mux Mode %x", value);
586:             break;
587:         }
588:         case RPI_GPIO_GPPUPPDN0_OFFSET:
589:         case RPI_GPIO_GPPUPPDN1_OFFSET:
590:         case RPI_GPIO_GPPUPPDN2_OFFSET:
591:         case RPI_GPIO_GPPUPPDN3_OFFSET:
592:         {
593:             uint8 pinBase = (offset - RPI_GPIO_GPPUPPDN0_OFFSET) / 4 * 16;
594:             string line{ "GPIO Set Pin Pull Up/Down Mode "};
595:             for (uint8 pinIndex = 0; pinIndex < 16; ++pinIndex)
596:             {
597:                 int shift = pinIndex * 2;
598:                 uint8 pin = pinBase + pinIndex;
599:                 uint8 value = (*registerField >> shift) & 0x00000003;
600:                 line += Format(" - Pin %d Pull up/down mode %x", pin, value);
601:             }
602:             LOG_INFO(line.c_str());
603:             break;
604:         }
605: #endif
606:         default:
607:             LOG_ERROR("Invalid GPIO register access for writing: offset %d", offset);
608:             break;
609:     }
610:     *registerField = data;
611: }
612: 
613: /// <summary>
614: /// Determine register address offset relative to GPIO base address
615: /// 
616: /// If the address is not in the correct range, an assert is fired
617: /// </summary>
618: /// <param name="address">Address to check</param>
619: /// <returns>Offset relative to GPIO base address</returns>
620: uint32 MemoryAccessStubGPIO::GetRegisterOffset(regaddr address)
621: {
622:     assert((reinterpret_cast<uintptr>(address) & GPIOBaseAddressMask) == GPIOBaseAddress);
623:     return reinterpret_cast<uintptr>(address) - GPIOBaseAddress;
624: }
```

- Line 57: We define a variable `GPIOBaseAddress` to hold the base address of the GPIO registers
- Line 59: We define a variable `GPIOBaseAddressMask` to check whether an address is in the GPIO register range
- Line 64-67: We implement the constructor
- Line 74-78: We implement the method `Read8()` as a panic, as we will always do 32 bit read / write access
- Line 85-88: We implement the method `Write8()` as a panic, as we will always do 32 bit read / write access
- Line 95-99: We implement the method `Read16()` as a panic, as we will always do 32 bit read / write access
- Line 106-109: We implement the method `Write16()` as a panic, as we will always do 32 bit read / write access
- Line 116-341: We implement the method `Read32()`
  - Line 118: We calculate the relative register offset
  - Line 119: We read the register from the save register values
  - Line 123-141: We handle the GPIO Function Select Registers, to trace the access
  - Line 142-159: We handle the GPIO Level Registers, to trace the access
  - Line 160-177: We handle the GPIO Event Detected Registers, to trace the access
  - Line 178-195: We handle the GPIO Rising Edge Detect Registers, to trace the access
  - Line 196-213: We handle the GPIO Falling Edge Detect Registers, to trace the access
  - Line 214-231: We handle the GPIO High Level Detect Registers, to trace the access
  - Line 232-249: We handle the GPIO Low Level Detect Registers, to trace the access
  - Line 250-267: We handle the GPIO Asynchronous Rising Edge Detect Registers, to trace the access
  - Line 268-285: We handle the GPIO Asynchronous Falling Edge Detect Registers, to trace the access
  - Line 287-292: We handle the GPIO Pull up/down Mode Register for Raspberry Pi 3, to trace the access
  - Line 293-310: We handle the GPIO Pull up/down Clock Registers for Raspberry Pi 3, to trace the access
  - Line 312-317: We handle the GPIO Pull up/down Pin Mux Register for Raspberry Pi 4, to trace the access
  - Line 318-334: We handle the GPIO Pull up/down Mode Registers for Raspberry Pi 4, to trace the access
- Line 348-611: We implement the method `Write32()`
  - Line 350: We calculate the relative register offset
  - Line 351: We write the value to the save register values
  - Line 355-375: We handle the GPIO Function Select Registers, to trace the access
  - Line 376-393: We handle the GPIO Set Registers, to trace the access
  - Line 394-411: We handle the GPIO Clear Registers, to trace the access
  - Line 412-429: We handle the GPIO Event Detected Registers, to trace the access
  - Line 430-449: We handle the GPIO Rising Edge Detect Registers, to trace the access
  - Line 450-469: We handle the GPIO Falling Edge Detect Registers, to trace the access
  - Line 470-489: We handle the GPIO High Level Detect Registers, to trace the access
  - Line 490-509: We handle the GPIO Low Level Detect Registers, to trace the access
  - Line 510-529: We handle the GPIO Asynchronous Rising Edge Detect Registers, to trace the access
  - Line 530-549: We handle the GPIO Asynchronous Falling Edge Detect Registers, to trace the access
  - Line 551-560: We handle the GPIO Pull up/down Mode Register for Raspberry Pi 3, to trace the access
  - Line 561-580: We handle the GPIO Pull up/down Clock Registers for Raspberry Pi 3, to trace the access
  - Line 582-587: We handle the GPIO Pull up/down Pin Mux Register for Raspberry Pi 4, to trace the access
  - Line 588-604: We handle the GPIO Pull up/down Mode Registers for Raspberry Pi 4, to trace the access
- Line 620-624: We implement the method `GetRegisterOffset()`

### MemoryAccessStubI2C.h {#TUTORIAL_21_I2C_BASIC_I2C_FUNCTIONALITY___FAKING_IT___STEP_1_MEMORYACCESSSTUBI2CH}

We'll define a `MemoryAccess` implementation that will fake the I2C register access, and handles the case where GPIO is addressed

Create file `code/libraries/baremetal/include/baremetal/stubs/MemoryAccessStubI2C.h`

```cpp
File: code/libraries/baremetal/include/baremetal/stubs/MemoryAccessStubI2C.h
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MemoryAccessStubI2C.h
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : MemoryAccessStubI2C
9: //
10: // Description : I2C register memory access stub
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39: 
40: #pragma once
41: 
42: #include <stdlib/Macros.h>
43: #include <baremetal/stubs/MemoryAccessStubGPIO.h>
44: 
45: /// @file
46: /// MemoryAccessStubI2C
47: 
48: namespace baremetal {
49: 
50: /// @brief I2C registers storage
51: struct I2CRegisters
52: {
53:     /// @brief I2C Control Register (C)
54:     uint32 ControlRegister;
55:     /// @brief I2C Status Register (C)
56:     uint32 StatusRegister;
57:     /// @brief I2C Data Length Register (DLEN)
58:     uint32 DataLengthRegister;
59:     /// @brief I2C Address Register (A)
60:     uint32 AddressRegister;
61:     /// @brief I2C FIFO Register (FIFO)
62:     uint32 FIFORegister;
63:     /// @brief I2C ClockDivider Register (DIV)
64:     uint32 ClockDividerRegister;
65:     /// @brief I2C Data Delay Register (DEL)
66:     uint32 DataDelayRegister;
67:     /// @brief I2C Clock Stretch Timeout Register (CLKT)
68:     uint32 ClockStretchTimeoutRegister;
69: 
70:     /// <summary>
71:     /// Constructor for I2CRegisters
72:     /// 
73:     /// Sets default register values
74:     /// </summary>
75:     I2CRegisters()
76:         : ControlRegister{}
77:         , StatusRegister{0x00000050}
78:         , DataLengthRegister{}
79:         , AddressRegister{}
80:         , FIFORegister{}
81:         , ClockDividerRegister{0x000005DC}
82:         , DataDelayRegister{0x00300030}
83:         , ClockStretchTimeoutRegister{0x00000040}
84:     {
85:     }
86: } PACKED;
87: 
88: /// @brief FIFO template class
89: template<int N>
90: class FIFO
91: {
92: private:
93:     /// @brief Data in FIFO (max 16 bytes)
94:     uint8 m_data[N];    // Size 16
95:     /// @brief Read index. If m_readIndex == m_writeIndex, the FIFO is either empty or full, depending on the full flag
96:     int   m_readIndex;  // Size 4
97:     /// @brief Write index. If m_readIndex == m_writeIndex, the FIFO is either empty or full, depending on the full flag
98:     int   m_writeIndex; // Size 4
99:     /// @brief Flag whether the FIFO is full
100:     bool  m_isFull;     // Size 1
101:     /// @brief Force alignment to 16 bytes
102:     uint8 align[7];     // Size 7
103: 
104: public:
105:     /// <summary>
106:     /// FIFO constructor
107:     /// </summary>
108:     FIFO()
109:         : m_data{}
110:         , m_readIndex{}
111:         , m_writeIndex{}
112:         , m_isFull{}
113:     {
114:     }
115:     /// <summary>
116:     /// Read a byte from the FIFO
117:     /// </summary>
118:     /// <returns>Byte read. If nothing can be read, returns 0</returns>
119:     uint8 Read()
120:     {
121:         uint8 result{};
122:         if (m_isFull | ((m_writeIndex - m_readIndex + N) % N > 0))
123:         {
124:             result = m_data[m_readIndex];
125:             m_readIndex = (m_readIndex + 1) % N;
126:             m_isFull = false;
127:         }
128:         return result;
129:     }
130:     /// <summary>
131:     /// Write a byte to the FIFO
132:     /// </summary>
133:     /// <param name="data">Data to write</param>
134:     void Write(uint8 data)
135:     {
136:         if (!m_isFull)
137:         {
138:             m_data[m_writeIndex] = data;
139:             m_writeIndex = (m_writeIndex + 1) % N;
140:             if (m_readIndex == m_writeIndex)
141:                 m_isFull = true;
142:         }
143:     }
144: };
145: 
146: using SendAddressByteCallback = bool(uint8 address);
147: using RecvDataByteCallback = bool(uint8 &data);
148: using SendDataByteCallback = bool(uint8 data);
149: 
150: /// @brief MemoryAccess implementation for I2C stub
151: class MemoryAccessStubI2C:
152:     public MemoryAccessStubGPIO
153: {
154: private:
155:     /// @brief Storage for I2C registers
156:     I2CRegisters m_registers;
157:     /// @brief I2C master base address
158:     uintptr m_i2cMasterBaseAddress;
159:     /// @brief Receive FIFO
160:     FIFO<16> m_rxFifo;
161:     /// @brief Send FIFO
162:     FIFO<16> m_txFifo;
163:     /// @brief Pointer to send address callback
164:     SendAddressByteCallback* m_sendAddressByteCallback;
165:     /// @brief Pointer to receive data callback
166:     RecvDataByteCallback* m_recvDataByteCallback;
167:     /// @brief Pointer to send data callback
168:     SendDataByteCallback* m_sendDataByteCallback;
169: 
170: public:
171:     MemoryAccessStubI2C();
172:     void SetBus(uint8 bus);
173:     uint8  Read8(regaddr address) override;
174:     void   Write8(regaddr address, uint8 data) override;
175: 
176:     uint16 Read16(regaddr address) override;
177:     void   Write16(regaddr address, uint16 data) override;
178: 
179:     uint32 Read32(regaddr address) override;
180:     void   Write32(regaddr address, uint32 data) override;
181: 
182:     void SetSendAddressByteCallback(SendAddressByteCallback callback);
183:     void SetRecvDataByteCallback(RecvDataByteCallback callback);
184:     void SetSendDataByteCallback(SendDataByteCallback callback);
185: 
186: private:
187:     uint32 GetRegisterOffset(regaddr address);
188: };
189: 
190: } // namespace baremetal
```

- Line 51-86: We declare a struct `I2CRegisters` to hold the register values for the I2C device
  - Line 54: The member variable `ControlRegister` holds the Control Register value
  - Line 56: The member variable `StatusRegister` holds the Status Register value
  - Line 58: The member variable `DataLengthRegister` holds the DataLength  Register value
  - Line 60: The member variable `AddressRegister` holds the Address Register value
  - Line 62: The member variable `FIFORegister` holds the FIFO Register entry point
  - Line 64: The member variable `ClockDividerRegister` holds the Clock Divider Register value
  - Line 66: The member variable `DataDelayRegister` holds the Data Delay Register value
  - Line 68: The member variable `ClockStretchTimeoutRegister` holds the Clock Stretch Timeout Register value
  - Line 75-85: We define the constructor, which initialize the register values to their defaults
- Line 89-144: We declare and implement the FIFO template class. The template parameter form the size of the FIFO queue
  - Line 94: The member variable `m_data` holds the actual FIFO data
  - Line 96: The member variable `m_readIndex` holds the location in `m_data` that will be read from next
  - Line 98: The member variable `m_writeIndex` holds the location in `m_data` that will be written to next
  - Line 100: The member variable `m_isFull` flags whether the FIFO queue is full.
This is needed to distinguish between two cases where `m_readIndex` and `m_writeIndex` are equal.
This can mean the queue is either empty or full. The variable `m_isFull` distinguishes between the two cases
  - Line 102: The member variable `m_align` is simply there to make sure the class size is a multiple of 16 bytes
- Line 108-114: We define the constructor
- Line 119-129: We define the method `Read()` to read a single byte from the queue
- Line 134-144: We define the method `Write()` to write a single byte to the queue
- Line 146: We define the type `SendAddressByteCallback` as a callback function when the I2C address is written
- Line 147: We define the type `RecvDataByteCallback` as a callback function when data is read from the I2C device
- Line 148: We define the type `SendvDataByteCallback` as a callback function when data is written to the I2C device
- Line 151-187: We declare the class `MemoryAccessStubI2C` which acts as the `MemoryAccess` class for fake I2C access.
Note that it derives from `MemoryAccessStubGPIO`
  - Line 156: The member variable `m_registers` contains the values of the I2C device registers
  - Line 158: The member variable `m_i2cMasterBaseAddress` holds the register base address of the selected I2C device
  - Line 160: The member variable `m_sendAddressByteCallback` holds the callback function pointer for sending the address byte
  - Line 162: The member variable `m_recvDataByteCallback` holds the callback function pointer for receiving a data byte
  - Line 164: The member variable `m_sendDataByteCallback` holds the callback function pointer for sending a data byte
  - Line 171: We Declare the constructor
  - Line 172: We declare the method `SetBus()` to set the I2C bus to use
  - Line 173-180: We override the read / write methods for the interface
  - Line 182-184: We declare methods so set the respective callback function pointers
  - Lien 187: We declare the method `GetRegisterOffset()` to calculate the register offset relative to the register base address for the I2C device

### MemoryAccessStubI2C.cpp {#TUTORIAL_21_I2C_BASIC_I2C_FUNCTIONALITY___FAKING_IT___STEP_1_MEMORYACCESSSTUBI2CCPP}

@todo Continue here. Either write / read using FIFO, or remove FIFO

We'll define a `MemoryAccess` implementation that will fake the I2C register access, and handles the case where GPIO is addressed

Create file `code/libraries/baremetal/src/stubs/MemoryAccessStubI2C.cpp`

```cpp
File: code/libraries/baremetal/src/stubs/MemoryAccessStubI2C.cpp
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MemoryAccessStubI2C.cpp
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : MemoryAccessStubI2C
9: //
10: // Description : I2C register memory access stub implementation
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39: 
40: #include <baremetal/stubs/MemoryAccessStubI2C.h>
41: 
42: #include <baremetal/Assert.h>
43: #include <baremetal/BCMRegisters.h>
44: #include <baremetal/Format.h>
45: #include <baremetal/Logger.h>
46: #include <baremetal/String.h>
47: 
48: /// @file
49: /// MemoryAccessStubI2C
50: 
51: /// @brief Define log name
52: LOG_MODULE("MemoryAccessStubI2c");
53: 
54: using namespace baremetal;
55: 
56: /// @brief I2C bus 0 register base address
57: static regaddr I2CBaseAddress0{ RPI_I2C0_BASE };
58: /// @brief I2C bus 1 register base address
59: static regaddr I2CBaseAddress1{ RPI_I2C1_BASE };
60: #if BAREMETAL_RPI_TARGET == 3
61: /// @brief I2C bus 2 register base address
62: static regaddr I2CBaseAddress2{ RPI_I2C2_BASE };
63: #elif BAREMETAL_RPI_TARGET == 4
64: /// @brief I2C bus 3 register base address
65: static regaddr I2CBaseAddress3{ RPI_I2C3_BASE };
66: /// @brief I2C bus 4 register base address
67: static regaddr I2CBaseAddress4{ RPI_I2C4_BASE };
68: /// @brief I2C bus 5 register base address
69: static regaddr I2CBaseAddress5{ RPI_I2C5_BASE };
70: /// @brief I2C bus 6 register base address
71: static regaddr I2CBaseAddress6{ RPI_I2C6_BASE };
72: #endif
73: /// @brief Mask to check whether an address is in the range for a specific I2C bus
74: static uintptr I2CBaseAddressMask{ 0xFFFFFFFFFFFFFFE0 };
75: 
76: /// <summary>
77: /// MemoryAccessStubI2C constructor
78: /// </summary>
79: MemoryAccessStubI2C::MemoryAccessStubI2C()
80: {
81: }
82: 
83: /// <summary>
84: /// Read a 8 bit value from register at address
85: /// </summary>
86: /// <param name="address">Address of register</param>
87: /// <returns>8 bit register value</returns>
88: uint8 MemoryAccessStubI2C::Read8(regaddr address)
89: {
90:     LOG_PANIC("Call to Read8 should not happen");
91:     return {};
92: }
93: 
94: /// <summary>
95: /// Write a 8 bit value to register at address
96: /// </summary>
97: /// <param name="address">Address of register</param>
98: /// <param name="data">Data to write</param>
99: void MemoryAccessStubI2C::Write8(regaddr address, uint8 data)
100: {
101:     LOG_PANIC("Call to Write8 should not happen");
102: }
103: 
104: /// <summary>
105: /// Read, modify and write a 8 bit value to register at address
106: /// 
107: /// The operation will read the value from the specified register, then AND it with the inverse of the mask (8 bits) provided
108: /// The data provided (8 bits) will be masked with the mask provided, shifted left bit shift bits, and then OR'ed with the mask read data
109: /// The result will then be written back to the register
110: /// </summary>
111: /// <param name="address">Address of register</param>
112: /// <param name="mask">Mask to apply. Value read will be masked with the inverse of mask, then the data (after shift) will be masked with mask before OR'ing with the value read</param>
113: /// <param name="data">Data to write (after shifting left by shift bits)</param>
114: /// <param name="shift">Shift to apply to the data to write (shift left)</param>
115: void MemoryAccessStubI2C::ReadModifyWrite8(regaddr address, uint8 mask, uint8 data, uint8 shift)
116: {
117:     auto value = Read8(address);
118:     value &= ~mask;
119:     value |= ((data << shift) & mask);
120:     Write8(address, value);
121: }
122: 
123: /// <summary>
124: /// Read a 16 bit value from register at address
125: /// </summary>
126: /// <param name="address">Address of register</param>
127: /// <returns>16 bit register value</returns>
128: uint16 MemoryAccessStubI2C::Read16(regaddr address)
129: {
130:     LOG_PANIC("Call to Read16 should not happen");
131:     return {};
132: }
133: 
134: /// <summary>
135: /// Write a 16 bit value to register at address
136: /// </summary>
137: /// <param name="address">Address of register</param>
138: /// <param name="data">Data to write</param>
139: void MemoryAccessStubI2C::Write16(regaddr address, uint16 data)
140: {
141:     LOG_PANIC("Call to Write16 should not happen");
142: }
143: 
144: /// <summary>
145: /// Read, modify and write a 16 bit value to register at address
146: /// 
147: /// The operation will read the value from the specified register, then AND it with the inverse of the mask (16 bits) provided
148: /// The data provided (16 bits) will be masked with the mask provided, shifted left bit shift bits, and then OR'ed with the mask read data
149: /// The result will then be written back to the register
150: /// </summary>
151: /// <param name="address">Address of register</param>
152: /// <param name="mask">Mask to apply. Value read will be masked with the inverse of mask, then the data (after shift) will be masked with mask before OR'ing with the value read</param>
153: /// <param name="data">Data to write (after shifting left by shift bits)</param>
154: /// <param name="shift">Shift to apply to the data to write (shift left)</param>
155: void MemoryAccessStubI2C::ReadModifyWrite16(regaddr address, uint16 mask, uint16 data, uint8 shift)
156: {
157:     auto value = Read16(address);
158:     value &= ~mask;
159:     value |= ((data << shift) & mask);
160:     Write16(address, value);
161: }
162: 
163: /// <summary>
164: /// Read a 32 bit value from register at address
165: /// </summary>
166: /// <param name="address">Address of register</param>
167: /// <returns>32 bit register value</returns>
168: uint32 MemoryAccessStubI2C::Read32(regaddr address)
169: {
170:     uintptr addr = reinterpret_cast<uintptr>(address);
171:     if ((addr >= RPI_GPIO_BASE) && (addr < RPI_GPIO_END))
172:     {
173:         return MemoryAccessStubGPIO::Read32(address);
174:     }
175: 
176:     uintptr offset = GetRegisterOffset(address);
177:     uint32 *registerField = reinterpret_cast<uint32 *>(reinterpret_cast<uint8 *>(&m_registers) + offset);
178:     LOG_INFO("I2C Read register %016x = %08x", offset, *registerField);
179:     switch (offset)
180:     {
181:         case 0x00:
182:         {
183:             string line{ "I2C Read Control Register "};
184:             if (*registerField & RPI_I2C_C_ENABLE)
185:                 line += "Enable ON  ";
186:             else
187:                 line += "Enable OFF ";
188:             if (*registerField & RPI_I2C_C_INTR_ENABLE)
189:                 line += "RX Interrupt ON  ";
190:             else
191:                 line += "RX Interrupt OFF ";
192:             if (*registerField & RPI_I2C_C_INTT_ENABLE)
193:                 line += "TX Interrupt ON  ";
194:             else
195:                 line += "TX Interrupt OFF ";
196:             if (*registerField & RPI_I2C_C_INTD_ENABLE)
197:                 line += "DONE Interrupt ON  ";
198:             else
199:                 line += "DONE Interrupt OFF ";
200:             if (*registerField & RPI_I2C_C_READ)
201:                 line += "Read ";
202:             else
203:                 line += "Write ";
204:             LOG_INFO(line.c_str());
205:             break;
206:         }
207:         case 0x04:
208:         {
209:             string line{ "I2C Read Control Register "};
210:             if (*registerField & RPI_I2C_S_CLKT)
211:                 line += "CLKT ";
212:             else
213:                 line += "     ";
214:             if (*registerField & RPI_I2C_S_ERR)
215:                 line += "NACK ";
216:             else
217:                 line += "ACK  ";
218:             if (*registerField & RPI_I2C_S_RXF)
219:                 line += "RXF ";
220:             else
221:                 line += "    ";
222:             if (*registerField & RPI_I2C_S_TXE)
223:                 line += "TXE ";
224:             else
225:                 line += "    ";
226:             if (*registerField & RPI_I2C_S_RXD)
227:                 line += "RXD ";
228:             else
229:                 line += "    ";
230:             if (*registerField & RPI_I2C_S_TXD)
231:                 line += "TXD ";
232:             else
233:                 line += "    ";
234:             if (*registerField & RPI_I2C_S_RXR)
235:                 line += "RXR ";
236:             else
237:                 line += "    ";
238:             if (*registerField & RPI_I2C_S_TXW)
239:                 line += "TXW ";
240:             else
241:                 line += "    ";
242:             if (*registerField & RPI_I2C_S_DONE)
243:                 line += "DONE ";
244:             else
245:                 line += "     ";
246:             if (*registerField & RPI_I2C_S_TA)
247:                 line += "TA ";
248:             else
249:                 line += "   ";
250:             LOG_INFO(line.c_str());
251:             break;
252:         }
253:         case 0x08:
254:         {
255:             LOG_INFO("I2C Get Data Length %d", *registerField);
256:             break;
257:         }
258:         case 0x0C:
259:         {
260:             LOG_INFO("I2C Get Address %d", *registerField);
261:             break;
262:         }
263:         case 0x10:
264:         {
265:             LOG_INFO("I2C Read FIFO %02x", *registerField);
266:             break;
267:         }
268:         case 0x14:
269:         {
270:             LOG_INFO("I2C Set Clock Divider %d", *registerField);
271:             break;
272:         }
273:         case 0x18:
274:         {
275:             if (*registerField & 0xFFFF0000)
276:             {
277:                 LOG_INFO("I2C Get Falling Edge Delay %d", (*registerField >> 16));
278:             }
279:             if (*registerField & 0x0000FFFF)
280:             {
281:                 LOG_INFO("I2C Get Rising Edge Delay %d", (*registerField & 0x0000FFFF));
282:             }
283:             break;
284:         }
285:         case 0x1C:
286:         {
287:             LOG_INFO("I2C Get Clock Stretch Timeout %d", (*registerField & 0x0000FFFF));
288:             break;
289:         }
290:         default:
291:             LOG_ERROR("Invalid I2C register access for reading: offset %d", offset);
292:             break;
293:     }
294: 
295:     return *registerField;
296: }
297: 
298: /// <summary>
299: /// Write a 32 bit value to register at address
300: /// </summary>
301: /// <param name="address">Address of register</param>
302: /// <param name="data">Data to write</param>
303: void MemoryAccessStubI2C::Write32(regaddr address, uint32 data)
304: {
305:     uintptr addr = reinterpret_cast<uintptr>(address);
306:     if ((addr >= RPI_GPIO_BASE) && (addr < RPI_GPIO_END))
307:     {
308:         MemoryAccessStubGPIO::Write32(address, data);
309:         return;
310:     }
311: 
312:     uintptr offset = GetRegisterOffset(address);
313:     uint32 *registerField = reinterpret_cast<uint32 *>(reinterpret_cast<uint8 *>(&m_registers) + offset);
314:     LOG_INFO("I2C Write register %016x = %08x", offset, data);
315:     switch (offset)
316:     {
317:         case 0x00:
318:         {
319:             uint32 diff = (data ^ *registerField) | 0x00B0;
320:             if (diff & RPI_I2C_C_ENABLE)
321:             {
322:                 if (data & RPI_I2C_C_ENABLE)
323:                     LOG_INFO("I2C Enable Controller");
324:                 else
325:                     LOG_INFO("I2C Disable Controller");
326:             }
327:             if (diff & RPI_I2C_C_INTR_ENABLE)
328:             {
329:                 if (data & RPI_I2C_C_INTR_ENABLE)
330:                     LOG_INFO("I2C Enable RX Interrupt");
331:                 else
332:                     LOG_INFO("I2C Disable RX Interrupt");
333:             }
334:             if (diff & RPI_I2C_C_INTT_ENABLE)
335:             {
336:                 if (data & RPI_I2C_C_INTT_ENABLE)
337:                     LOG_INFO("I2C Enable TX Interrupt");
338:                 else
339:                     LOG_INFO("I2C Disable TX Interrupt");
340:             }
341:             if (diff & RPI_I2C_C_INTD_ENABLE)
342:             {
343:                 if (data & RPI_I2C_C_INTD_ENABLE)
344:                     LOG_INFO("I2C Enable Done Interrupt");
345:                 else
346:                     LOG_INFO("I2C Disable Done Interrupt");
347:             }
348:             if (diff & RPI_I2C_C_READ)
349:             {
350:                 if (data & RPI_I2C_C_READ)
351:                     LOG_INFO("I2C Read Mode");
352:                 else
353:                     LOG_INFO("I2C Write Mode");
354:             }
355:             if (data & RPI_I2C_C_CLEAR)
356:                 LOG_INFO("I2C Clear FIFO");
357:             if (data & RPI_I2C_C_ST)
358:                 LOG_INFO("I2C Start Transfer");
359:             break;
360:         }
361:         case 0x04:
362:         {
363:             if (data & RPI_I2C_S_CLKT)
364:                 LOG_INFO("I2C Reset Clock Stretch Timeout");
365:             if (data & RPI_I2C_S_ERR)
366:                 LOG_INFO("I2C Reset Ack Error");
367:             if (data & RPI_I2C_S_DONE)
368:                 LOG_INFO("I2C Reset Done");
369:             break;
370:         }
371:         case 0x08:
372:         {
373:             LOG_INFO("I2C Set Data Length %d", data);
374:             break;
375:         }
376:         case 0x0C:
377:         {
378:             LOG_INFO("I2C Set Address %d", data);
379:             break;
380:         }
381:         case 0x10:
382:         {
383:             LOG_INFO("I2C Write FIFO %02x", data);
384:             break;
385:         }
386:         case 0x14:
387:         {
388:             if (data != *registerField)
389:             {
390:                 LOG_INFO("I2C Set Clock Divider %d", data);
391:             }
392:             break;
393:         }
394:         case 0x18:
395:         {
396:             uint32 diff = data & *registerField;
397:             if (diff & 0xFFFF0000)
398:             {
399:                 LOG_INFO("I2C Set Falling Edge Delay %d", (data >> 16));
400:             }
401:             if (diff & 0x0000FFFF)
402:             {
403:                 LOG_INFO("I2C Set Rising Edge Delay %d", (data & 0x0000FFFF));
404:             }
405:             break;
406:         }
407:         case 0x1C:
408:         {
409:             uint32 diff = data & *registerField;
410:             if (diff & 0x0000FFFF)
411:             {
412:                 LOG_INFO("I2C Set Clock Stretch Timeout %d", (data & 0x0000FFFF));
413:             }
414:             break;
415:         }
416:         default:
417:             LOG_ERROR("Invalid I2C register access for writing: offset %d", offset);
418:             break;
419:     }
420:     *registerField = data;
421: }
422: 
423: /// <summary>
424: /// Read, modify and write a 32 bit value to register at address
425: /// 
426: /// The operation will read the value from the specified register, then AND it with the inverse of the mask (32 bits) provided
427: /// The data provided (32 bits) will be masked with the mask provided, shifted left bit shift bits, and then OR'ed with the mask read data
428: /// The result will then be written back to the register
429: /// </summary>
430: /// <param name="address">Address of register</param>
431: /// <param name="mask">Mask to apply. Value read will be masked with the inverse of mask, then the data (after shift) will be masked with mask before OR'ing with the value read</param>
432: /// <param name="data">Data to write (after shifting left by shift bits)</param>
433: /// <param name="shift">Shift to apply to the data to write (shift left)</param>
434: void MemoryAccessStubI2C::ReadModifyWrite32(regaddr address, uint32 mask, uint32 data, uint8 shift)
435: {
436:     auto value = Read32(address);
437:     value &= ~mask;
438:     value |= ((data << shift) & mask);
439:     Write32(address, value);
440: }
441: 
442: /// <summary>
443: /// Determine register address offset, by checking against the different bus numbers
444: /// 
445: /// If no bus matches the address, an assert if fired
446: /// </summary>
447: /// <param name="address">Address to check</param>
448: /// <returns>Offset relative to the base address for the respective bus, if one exists. Will return 0 (but assert) otherwise</returns>
449: uint32 MemoryAccessStubI2C::GetRegisterOffset(regaddr address)
450: {
451:     uintptr baseAddress = reinterpret_cast<uintptr>(address) & I2CBaseAddressMask;
452:     if (baseAddress == reinterpret_cast<uintptr>(I2CBaseAddress0))
453:         return reinterpret_cast<uintptr>(address) - reinterpret_cast<uintptr>(I2CBaseAddress0);
454:     if (baseAddress == reinterpret_cast<uintptr>(I2CBaseAddress1))
455:         return reinterpret_cast<uintptr>(address) - reinterpret_cast<uintptr>(I2CBaseAddress1);
456: #if BAREMETAL_RPI_TARGET == 3
457:     if (baseAddress == reinterpret_cast<uintptr>(I2CBaseAddress2))
458:         return reinterpret_cast<uintptr>(address) - reinterpret_cast<uintptr>(I2CBaseAddress2);
459: #elif BAREMETAL_RPI_TARGET == 4
460:     if (baseAddress == reinterpret_cast<uintptr>(I2CBaseAddress3))
461:         return reinterpret_cast<uintptr>(address) - reinterpret_cast<uintptr>(I2CBaseAddress3);
462:     if (baseAddress == reinterpret_cast<uintptr>(I2CBaseAddress4))
463:         return reinterpret_cast<uintptr>(address) - reinterpret_cast<uintptr>(I2CBaseAddress4);
464:     if (baseAddress == reinterpret_cast<uintptr>(I2CBaseAddress5))
465:         return reinterpret_cast<uintptr>(address) - reinterpret_cast<uintptr>(I2CBaseAddress5);
466:     if (baseAddress == reinterpret_cast<uintptr>(I2CBaseAddress6))
467:         return reinterpret_cast<uintptr>(address) - reinterpret_cast<uintptr>(I2CBaseAddress6);
468: #endif
469:     assert(false);
470:     return {};
471: }
472: 
473: /// <summary>
474: /// Set callback function for address send
475: /// </summary>
476: /// <param name="callback">Address of callback function</param>
477: void MemoryAccessStubI2C::SetSendAddressByteCallback(SendAddressByteCallback callback)
478: {
479:     m_sendAddressByteCallback = callback;
480: }
481: 
482: /// <summary>
483: /// Set callback function for data receive
484: /// </summary>
485: /// <param name="callback">Address of callback function</param>
486: void MemoryAccessStubI2C::SetRecvDataByteCallback(RecvDataByteCallback callback)
487: {
488:     m_recvDataByteCallback = callback;
489: }
490: 
491: /// <summary>
492: /// Set callback function for data send
493: /// </summary>
494: /// <param name="callback">Address of callback function</param>
495: void MemoryAccessStubI2C::SetSendDataByteCallback(SendDataByteCallback callback)
496: {
497:     m_sendDataByteCallback = callback;
498: }
499: 
```


Next: [22-i2s](22-i2s.md)
