# Tutorial 22: I2C {#TUTORIAL_22_I2C}

@tableofcontents

## Tutorial setup {#TUTORIAL_22_I2C_TUTORIAL_SETUP}

As in the previous tutorial, you will find the code integrated into the CMake structure, in `tutorial/22-i2c`.
In the same way, the project names are adapted to make sure there are no conflicts.

### Tutorial results {#TUTORIAL_22_I2C_TUTORIAL_SETUP_TUTORIAL_RESULTS}

This tutorial will result in (next to the main project structure):
- a library `output/Debug/lib/baremetal-22.a`
- a library `output/Debug/lib/device-22.a`
- a library `output/Debug/lib/stdlib-22.a`
- an application `output/Debug/bin/22-i2c.elf`
- an image in `deploy/Debug/22-i2c-image`

## What is I2C {#TUTORIAL_22_I2C_WHAT_IS_I2C}

`Inter IC Communication` or IIC, or I2C (I-square-C) is a very simple serial bus meant for communication on short distance, initially meant for IC to IC communication.
Hence its name `Inter IC Communication`.
The bus has a clock signal, named SCL, and a data signal, called SDA. This is why it is also sometimes called Two Wire Communication (TWC).

<img src="images/i2c-single-master-single-slave.png"  alt="I2C bus" width="600"/>

I2C uses the concept of a master and slave. The master is in control of the clock, the slave listens to it.
However the roles of master and slave can be reversed, and there can be multiple masters and slaves, but only one master can exist on a "bus" at any time.
Both SCL and SDA are pulled up with a resistor, meaning the idle state for each signal is high or `1`.

I2C was initially intended to run at a 100 KHz clock, but nowadays can also be run at 400 KHz, 1 MHz, 1.7MHz, 3.4 MHz and 5 MHz.
The baseline is that the bus can run at the highest speed supported by all devices on the bus.
Raspberry Pi 3 and 4 support 100 Kbps and 400 kbps mode, Raspberry Pi also support 1000 kbps mode.

I will not go into all the details of the protocol, as there is a lot of information available, e.g. [Wikipedia](https://en.wikipedia.org/wiki/I%C2%B2C).

However, a few things need to be said to make things clear.

If a master wants to read or write a device, it will create a so-called `start condition`. It will then send the address, which will be acknowldged by the device being addressed, if any.
Then either the master (write) or the addressed slave device (read) will send data, until a `stop condition` is created.
Whether a read or write operation takes place is determined by the R/<u>W</u> bit (Read = 1, Write = 0) in the first byte sent containing the address.
This then leaves 7 bits for the address by default.
The data sent can be any number of bytes, although most devices only support blocks of up to 256 bytes.
Addresses in I2C are either 7 or 10 bits, using a special pattern for 10 bit addresses:

| Address  | Bit 6 | Bit 5 | Bit 4 | Bit 3 | Bit 2 | Bit 1 | Bit 0 | Address               |
|----------|-------|-------|-------|-------|-------|-------|-------|-----------------------|
| 7 bit    |    A6 |    A5 |    A4 |    A3 |    A2 |    A1 |    A0 | Bit A2-A0 are often selectable in HW, bit A6-A3 are fixed by the device
| reserved |     0 |     0 |     0 |     0 |     X |     X |     X | Reserved addresses, not usable by devices
| 10 bit   |     1 |     1 |     1 |     1 |     0 |    A9 |    A8 | Special pattern A6-A2 = 11110 means 10 bit address, another byte with A7-A0 follows

The way data is read or written in I2C is shown in the image below.

<img src="images/i2c-protocol.png"  alt="I2C message protocol" width="800"/>

Slaves each have a fixed address, which is preprogrammed. Many ICs however allow some pins to be pulled high or low to choose from a subset of addresses.

In the original protocol, there were 7 address bits, meaning 128 different addresses, however the first and last 8 addresses in this range are reserved, limiting the number of usable addresses to 112.
The 10 bit address mode, which would mean 1024 addresses, again reserves the same 16 addresses, so the maximum number of different addresses in this case is 1008.
Data is sent or received in chunks of 8 bits, but multiple such chuncks can be sent or received in one message.

Important is the <u>ACK</u>/NACK bit, which is a pause between two bytes.
By pulling the ACK bit low, the slave or master device acknowledges receiving.
If at any time the ack is not given, communication stops.

When scanning for devices on a bus, this is the way to determine whether a device is present at the specified address, simply by reading a single byte from the slave address.

There are many devices on the market supporting I2C, ranging from sensors, EEPROMs, memory modules, real time clocks, hardware monitors, actuators, DACs and ADCs, to displays.
The EDID (Extended Display Identification Data) such as used by HDMI is also I2C based.

Due to the fact that a chip has a preprogrammed address, how do we then support multiple of the same devices?
The answer is simple, we use a multiplexer, which splits up in mostly 8 new busses. One such multiplexer is [TCA9548](pdf/tca9548a.pdf).

Many devices however have extra pins to set the address within a subset, allowing multiple of the same devices to be addressed in parallel.

There are also devices that allow for direct input and output, so GPIO pins can also be controlled through I2C devices.
Two such devices are [MCP23008](pdf/mcp23008.pdf) (8 I/O) and [MCP23017](pdf/mcp23017.pdf) (16 I/O).

It would be nice to be able to control a simple 2 x 16 or 4 x 20 character display this way, however, as the programming of this device is quite some work, we'll postpone that until the next tutorial.
We'll start with a simpler device, the MCP23017, and control some LEDs from it.

## Actual hardware - MCP23017 {#TUTORIAL_22_I2C_ACTUAL_HARDWARE___MCP23017}

We'll use a circuit as depicted in [this diagram](pdf/MCP23017_LEDs.pdf):

<img src="images/MCP23017_LEDs.png" alt="MCP23017 controlling LEDs" width="1400"/>

You can build your own if you like, if not, just try to follow the tutorial, and look forward to where we will use an off-the-shelf LCD display.
We'll also be creating a stub for I2C, and implement the behaviour of the circuit, so you can at least follow what happens even if you don't have the actual hardware.

Raspberry Pi supports 7 and 10 bit addresses, and between 2 and 7 I2C buses.
The speed supported is either 100 Kbps, 400 Kbps or 1 Mbps.
See [Raspberry Pi I2C](#RASPBERRY_PI_I2C) for more information.

## Faking it - Step 1 {#TUTORIAL_22_I2C_FAKING_IT___STEP_1}

Before really attaching any devices, let's see if we can fake the I2C functionality, so we can debug our code a bit.
We'll do this, as in the previous tutorial for GPIO, by creating a IMemoryAccess instance that handling the access to I2C registers.
As we'll see, we'll also be re-using the GPIO stub due to the fact that we also need to program GPIO to correctly assign the I2C pins.

### BCMRegisters.h {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_BCMREGISTERSH}

First, we need to define register for the I2C devices.

Update the file `code/libraries/baremetal/include/baremetal/BCMRegisters.h`

```cpp
File: code/libraries/baremetal/include/baremetal/BCMRegisters.h
...
473: //---------------------------------------------
474: // Raspberry Pi I2C
475: //---------------------------------------------
476:
477: /// @brief Raspberry Pi I2C bus 0 registers base address.
478: #define RPI_I2C0_BASE         reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205000)
479: /// @brief Raspberry Pi I2C bus 1 registers base address.
480: #define RPI_I2C1_BASE         reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00804000)
481:
482: #if BAREMETAL_RPI_TARGET == 3
483: /// @brief Raspberry Pi I2C bus 2 registers base address.
484: #define RPI_I2C2_BASE reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00805000)
485: #elif BAREMETAL_RPI_TARGET == 4
486: /// @brief Raspberry Pi I2C bus 3 registers base address.
487: #define RPI_I2C3_BASE reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205600)
488: /// @brief Raspberry Pi I2C bus 4 registers base address.
489: #define RPI_I2C4_BASE reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205800)
490: /// @brief Raspberry Pi I2C bus 5 registers base address.
491: #define RPI_I2C5_BASE reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205A80)
492: /// @brief Raspberry Pi I2C bus 6 registers base address.
493: #define RPI_I2C6_BASE reinterpret_cast<regaddr>(RPI_BCM_IO_BASE + 0x00205C00)
494: #endif
495:
496: /// @brief Raspberry Pi I2C control register (R/W) offset relative to RPI_I2Cx_BASE
497: #define RPI_I2C_C_OFFSET                       0x00000000
498: /// @brief Disable BSC (I2C) controller
499: #define RPI_I2C_C_DISABLE                      BIT0(15)
500: /// @brief Enable BSC (I2C) controller
501: #define RPI_I2C_C_ENABLE                       BIT1(15)
502: /// @brief Disable interrupt on receive 3/4 full
503: #define RPI_I2C_C_INTR_DISABLE                 BIT0(10)
504: /// @brief Enable interrupt on receive 3/4 full
505: #define RPI_I2C_C_INTR_ENABLE                  BIT1(10)
506: /// @brief Disable interrupt on transmit 1/4 full
507: #define RPI_I2C_C_INTT_DISABLE                 BIT0(9)
508: /// @brief Enable interrupt on transmit 1/4 full
509: #define RPI_I2C_C_INTT_ENABLE                  BIT1(9)
510: /// @brief Disable interrupt on transfer done
511: #define RPI_I2C_C_INTD_DISABLE                 BIT0(8)
512: /// @brief Enable interrupt on transfer done
513: #define RPI_I2C_C_INTD_ENABLE                  BIT1(8)
514: /// @brief Transfer start (start condition)
515: #define RPI_I2C_C_ST                           BIT1(7)
516: /// @brief Clear FIFO
517: #define RPI_I2C_C_CLEAR                        BITS(4, 5)
518: /// @brief Write transfer
519: #define RPI_I2C_C_WRITE                        BIT0(0)
520: /// @brief Read transfer
521: #define RPI_I2C_C_READ                         BIT1(0)
522:
523: /// @brief Raspberry Pi I2C status register (R/W) offset relative to RPI_I2Cx_BASE
524: #define RPI_I2C_S_OFFSET                       0x00000004
525: /// @brief Clock stretch timeout
526: #define RPI_I2C_S_CLKT                         BIT1(9)
527: /// @brief ACK error
528: #define RPI_I2C_S_ERR                          BIT1(8)
529: /// @brief Receive FIFO full
530: #define RPI_I2C_S_RXF                          BIT1(7)
531: /// @brief Transmit FIFO empty
532: #define RPI_I2C_S_TXE                          BIT1(6)
533: /// @brief Receive FIFO has data
534: #define RPI_I2C_S_RXD                          BIT1(5)
535: /// @brief Transmit FIFO has space
536: #define RPI_I2C_S_TXD                          BIT1(4)
537: /// @brief Receive FIFO is 3/4 full
538: #define RPI_I2C_S_RXR                          BIT1(3)
539: /// @brief Transmit FIFO is 1/4 full
540: #define RPI_I2C_S_TXW                          BIT1(2)
541: /// @brief Transfer is done
542: #define RPI_I2C_S_DONE                         BIT1(1)
543: /// @brief Transfer is active
544: #define RPI_I2C_S_TA                           BIT1(0)
545:
546: /// /// @brief Raspberry Pi I2C data length register (R/W) offset relative to RPI_I2Cx_BASE
547: #define RPI_I2C_DLEN_OFFSET                    0x00000008
548: /// @brief Raspberry Pi I2C slave address register (R/W) offset relative to RPI_I2Cx_BASE
549: #define RPI_I2C_A_OFFSET                       0x0000000C
550: /// @brief Raspberry Pi I2C data FIFO register (R/W) offset relative to RPI_I2Cx_BASE
551: #define RPI_I2C_FIFO_OFFSET                    0x00000010
552: /// @brief Raspberry Pi I2C clock divider register (R/W) offset relative to RPI_I2Cx_BASE
553: #define RPI_I2C_DIV_OFFSET                     0x00000014
554: /// @brief Raspberry Pi I2C data delay register (R/W) offset relative to RPI_I2Cx_BASE
555: #define RPI_I2C_DEL_OFFSET                     0x00000018
556: /// @brief Raspberry Pi I2C clock stretch timeout register (R/W) offset relative to RPI_I2Cx_BASE
557: #define RPI_I2C_CLKT_OFFSET                    0x0000001C
558: /// @brief Raspberry Pi I2C register address from base address and offset
559: #define RPI_I2C_REG_ADDRESS(base, offset)      reinterpret_cast<regaddr>((base) + (offset))
560:
```

- Line 477-494: We define the base address for each I2C bus, depending on the model.
Raspberry Pi 3 has buses 0, 1 and 2, Raspberry Pi 4 has bus 0, 1, 3, 4, 5, 6.
As the registers used for Raspberry Pi 5 are different, we'll skip these for now
- Line 496-497: We define the offset relative to the base address for the Control Register.
The actual address is calculated using the `RPI_I2C_REG_ADDRESS` macro
- Line 498-521: We define the bits for the Control Register.
Notice that some bits are defined as BIT0, basically meaning the bit has value 0, defined for clarity.
For more information on registers refer to [Raspberry Pi I2C](#RASPBERRY_PI_I2C)
- Line 523-524: We define the offset relative to the base address for the Status Register.
The actual address is calculated using the `RPI_I2C_REG_ADDRESS` macro
- Line 525-544: We define the bits for the Status Register
- Line 546-547: We define the offset relative to the base address for the Data Length Register
- Line 548-549: We define the offset relative to the base address for the Address Register
- Line 550-551: We define the offset relative to the base address for the FIFO Register
- Line 552-553: We define the offset relative to the base address for the Clock Divider Register
- Line 554-555: We define the offset relative to the base address for the Data Delay Register
- Line 556-557: We define the offset relative to the base address for the Clock Stretch Register
- Line 558-559: We define the macro `RPI_I2C_REG_ADDRESS` to calculate the register address from the I2C bus register base address and the relative register offset.
Each block of I2C bus registers has the same shape for Raspberry Pi 3 and 4.

### II2CMaster.h {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_II2CMASTERH}

We'll create an abstract class `II2CMaster` which is an interface to a master on the I2C bus.

Create the file `code/libraries/baremetal/include/baremetal/II2CMaster.h`

```cpp
File: code/libraries/baremetal/include/baremetal/II2CMaster.h
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : II2CMaster.h
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : I2CMaster
9: //
10: // Description : I2C Master abstract interface
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39:
40: #pragma once
41:
42: #include "baremetal/I2CErrorCodes.h"
43: #include "stdlib/Types.h"
44:
45: /// @file
46: /// I2C Master abstract interface
47:
48: namespace baremetal {
49:
50: #if BAREMETAL_RPI_TARGET <= 4
51:
52: /// <summary>
53: /// I2C speed selection
54: /// </summary>
55: enum class I2CClockMode
56: {
57:     /// @brief I2C @ 100 KHz
58:     Normal,
59:     /// @brief I2C @ 400 KHz
60:     Fast,
61:     /// @brief I2C @ 1 MHz
62:     FastPlus,
63: };
64:
65: /// <summary>
66: /// I2CMaster abstract interface. Can be inherited for creating a mock
67: /// </summary>
68: class II2CMaster
69: {
70: public:
71:     /// <summary>
72:     /// Default destructor needed for abstract class
73:     /// </summary>
74:     virtual ~II2CMaster() = default;
75:
76:     /// <summary>
77:     /// Read a single byte
78:     /// </summary>
79:     /// <param name="address">I2C address</param>
80:     /// <param name="data">Data read</param>
81:     /// <returns>Number of bytes actually read. Should be 1 for successful read, 0 if failed, negative if an error occurs</returns>
82:     virtual size_t Read(uint16 address, uint8& data) = 0;
83:     /// <summary>
84:     /// Read multiple bytes into buffer
85:     /// </summary>
86:     /// <param name="address">I2C address</param>
87:     /// <param name="buffer">Pointer to buffer to store data received</param>
88:     /// <param name="count">Requested byte count for read</param>
89:     /// <returns>Number of bytes actually read, or negative if an error occurs</returns>
90:     virtual size_t Read(uint16 address, void* buffer, size_t count) = 0;
91:     /// <summary>
92:     /// Write a single byte
93:     /// </summary>
94:     /// <param name="address">I2C address</param>
95:     /// <param name="data">Data byte to write</param>
96:     /// <returns>Number of bytes actually written. Should be 1 for successful write, 0 if failed, negative if an error occurs</returns>
97:     virtual size_t Write(uint16 address, uint8 data) = 0;
98:     /// <summary>
99:     /// Write multiple bytes to device
100:     /// </summary>
101:     /// <param name="address">I2C address</param>
102:     /// <param name="buffer">Pointer to buffer containing data to be sent</param>
103:     /// <param name="count">Requested byte count for write</param>
104:     /// <returns>Number of bytes actually written, or negative if an error occurs</returns>
105:     virtual size_t Write(uint16 address, const void* buffer, size_t count) = 0;
106:     /// <summary>
107:     /// Write then read from device
108:     /// </summary>
109:     /// <param name="address">I2C address</param>
110:     /// <param name="writeBuffer">Pointer to buffer containing data to be sent</param>
111:     /// <param name="writeCount">Requested byte count for write</param>
112:     /// <param name="readBuffer">Pointer to buffer to store data received</param>
113:     /// <param name="readCount">Requested byte count for read</param>
114:     /// <returns>Number of bytes actually written and read (cumulated), or negative if an error occurs</returns>
115:     virtual size_t WriteReadRepeatedStart(uint16 address, const void* writeBuffer, size_t writeCount, void* readBuffer, size_t readCount) = 0;
116: };
117:
118: #else
119:
120: #error RPI 5 not supported yet
121:
122: #endif
123:
124: } // namespace baremetal
```

- Line 42: We include a header containg error codes we will return for I2C operations.
We'll need to add this later
- Line 50: We only support Raspberry Pi model 3 and 4 for now, as Raspberry Pi 5 behaves differently
- Line 52-63: We declare an enum class `I2CClockMode` for the different I2C speeds.
Note that although we define the speed `FastPlus` which uses a 1 MHz clock, but this is only supported on Raspberry Pi 5
- Line 65-116: We declare the abstract class II2CMaster
  - Line 71-74: We declare the virtual destructor as required for abstract classes, and make it the default implementation
  - Line 76-82: We declare the pure virtual method `Read()` for reading a single byte
  - Line 83-90: We declare the pure virtual method `Read()` for reading multiple bytes
  - Line 91-97: We declare the pure virtual method `Write()` for writinging a single byte
  - Line 98-105: We declare the pure virtual method `Write()` for writing multiple bytes
  - Line 106-115: We declare the pure virtual method `WriteReadRepeatedStart()` for repeated cycles of writing data, then reading the result, until the required number of bytes is received

### I2CErrorCodes.h {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_I2CERRORCODESH}

We'll add the definitions of error codes used in `II2CMaster.h`.

Create the file `code/libraries/baremetal/include/baremetal/I2CErrorCodes.h`

```cpp
File: code/libraries/baremetal/include/baremetal/I2CErrorCodes.h
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : ErrorCodes.h
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : -
9: //
10: // Description : Error codes
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM CharDevices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39:
40: #pragma once
41:
42: /// @brief Generic error group
43: #define GENERIC_ERROR           0x0000
44: /// @brief Unexpected null pointer specified
45: #define GENERIC_NULL_POINTER    -(GENERIC_ERROR + 1)
46:
47: /// @brief I2C error group
48: #define I2C_BASE                0x1000
49: /// @brief Invalid parameter
50: #define I2C_MASTER_INVALID_PARM -(I2C_BASE + 1)
51: /// @brief Received a NACK
52: #define I2C_MASTER_ERROR_NACK   -(I2C_BASE + 2)
53: /// @brief Received clock stretch timeout
54: #define I2C_MASTER_ERROR_CLKT   -(I2C_BASE + 3)
55: /// @brief Not all data has been sent/received
56: #define I2C_MASTER_DATA_LEFT    -(I2C_BASE + 4)
```

The codes are all negative, and indicate which type of error occurred.
We'll be using these in the implementation of the I2C master.

### I2CMaster.h {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_I2CMASTERH}

We'll create a class `I2CMaster` which functions as a master on a I2C bus.
It derives from

Create the file `code/libraries/baremetal/include/baremetal/I2CMaster.h`

```cpp
File: code/libraries/baremetal/include/baremetal/I2CMaster.h
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : I2CMaster.h
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : I2CMaster
9: //
10: // Description : I2C Master functionality
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39:
40: #pragma once
41:
42: #include "baremetal/II2CMaster.h"
43: #include "baremetal/BCMRegisters.h"
44: #include "baremetal/IMemoryAccess.h"
45: #include "baremetal/PhysicalGPIOPin.h"
46:
47: /// @file
48: /// I2C Master
49:
50: namespace baremetal {
51:
52: /// <summary>
53: /// Driver for I2C master devices
54: ///
55: /// GPIO pin mapping (Raspberry Pi 3-4)
56: /// bus       | config 0      | config 1      | config 2      | Boards
57: /// :-------: | :-----------: | :-----------: | :-----------: | :-----
58: /// ^         | SDA    SCL    | SDA    SCL    | SDA    SCL    | ^
59: /// 0         | GPIO0  GPIO1  | GPIO28 GPIO29 | GPIO44 GPIO45 | Raspberry Pi 3 / 4
60: /// 1         | GPIO2  GPIO3  |               |               | Raspberry Pi 3 only
61: /// 2         |               |               |               | None
62: /// 3         | GPIO2  GPIO3  | GPIO4  GPIO5  |               | Raspberry Pi 4 only
63: /// 4         | GPIO6  GPIO7  | GPIO8  GPIO9  |               | Raspberry Pi 4 only
64: /// 5         | GPIO10 GPIO11 | GPIO12 GPIO13 |               | Raspberry Pi 4 only
65: /// 6         | GPIO22 GPIO23 |               |               | Raspberry Pi 4 only
66: ///
67: /// GPIO pin mapping (Raspberry Pi 5)
68: /// bus       | config 0      | config 1      | config 2      | Boards
69: /// :-------: | :-----------: | :-----------: | :-----------: | :-----
70: /// ^         | SDA    SCL    | SDA    SCL    | SDA    SCL    | ^
71: /// 0         | GPIO0  GPIO1  | GPIO8  GPIO9  |               | Raspberry Pi 5 only
72: /// 1         | GPIO2  GPIO3  | GPIO10 GPIO11 |               | Raspberry Pi 5 only
73: /// 2         | GPIO4  GPIO5  | GPIO12 GPIO13 |               | Raspberry Pi 5 only
74: /// 3         | GPIO6  GPIO7  | GPIO14 GPIO15 | GPIO22 GPIO23 | Raspberry Pi 5 only
75: /// </summary>
76: class I2CMaster
77:     : public II2CMaster
78: {
79: private:
80:     /// @brief Memory access interface reference for accessing registers.
81:     IMemoryAccess&  m_memoryAccess;
82:     /// @brief I2C bus index
83:     uint8           m_bus;
84:     /// @brief I2C bus base register address
85:     regaddr         m_baseAddress;
86:     /// @brief I2C bus clock rate
87:     I2CClockMode    m_clockMode;
88:     /// @brief I2C bus GPIO configuration index used
89:     uint32          m_config;
90:     /// @brief True if class is already initialized
91:     bool            m_isInitialized;
92:
93:     /// @brief GPIO pin for SDA wire
94:     PhysicalGPIOPin m_sdaPin;
95:     /// @brief GPIO pin for SCL wire
96:     PhysicalGPIOPin m_sclPin;
97:
98:     /// @brief Core clock rate used to determine I2C clock rate in Hz
99:     unsigned        m_coreClockRate;
100:     /// @brief I2C clock rate in Hz
101:     unsigned        m_clockSpeed;
102:
103: public:
104:     I2CMaster(IMemoryAccess &memoryAccess = GetMemoryAccess());
105:
106:     virtual ~I2CMaster();
107:
108:     bool Initialize(uint8 bus, I2CClockMode mode = I2CClockMode::Normal, uint32 config = 0);
109:
110:     void SetClock(unsigned clockRate);
111:     bool Scan(uint16 address);
112:     size_t Read(uint16 address, uint8 &data) override;
113:     size_t Read(uint16 address, void *buffer, size_t count) override;
114:     size_t Write(uint16 address, uint8 data) override;
115:     size_t Write(uint16 address, const void *buffer, size_t count) override;
116:     size_t WriteReadRepeatedStart(uint16 address, const void *writeBuffer, size_t writeCount, void *readBuffer, size_t readCount) override;
117:
118: private:
119:     uint32 ReadControlRegister();
120:     void WriteControlRegister(uint32 data);
121:     void StartReadTransfer();
122:     void StartWriteTransfer();
123:     void ClearFIFO();
124:     void WriteAddressRegister(uint8 data);
125:     void WriteDataLengthRegister(uint8 data);
126:     uint32 ReadStatusRegister();
127:     void WriteStatusRegister(uint32 data);
128:     bool HasClockStretchTimeout();
129:     bool HasAck();
130:     bool HasNAck();
131:     bool ReceiveFIFOFull();
132:     bool ReceiveFIFOHasData();
133:     bool ReceiveFIFONeedsReading();
134:     bool TransmitFIFOEmpty();
135:     bool TransmitFIFOHasSpace();
136:     bool TransmitFIFONeedsWriting();
137:     bool TransferDone();
138:     bool TransferActive();
139:     void ClearClockStretchTimeout();
140:     void ClearNAck();
141:     void ClearDone();
142:     void ClearAllStatus();
143:     uint8 ReadFIFORegister();
144:     void WriteFIFORegister(uint8 data);
145: };
146:
147: } // namespace baremetal
```

Notice that the I2C addresses all have type uint16, meaning we are supporting both 7 bit and 10 bit addresses.

- Line 52-145: We declare the class `I2CMaster` which derives from `II2CMaster`
  - Line 80-81: We declare a member variable `m_memoryAccess` to access registers
  - Line 82-83: We declare a member variable `m_bus` to hold the I2C bus index
  - Line 84-85: We declare a member variable `m_baseAddress` to hold the I2C bus register base address
  - Line 86-87: We declare a member variable `m_clockMode` to hold the I2C clock rate setting
  - Line 88-89: We declare a member variable `m_config` to hold the configuration used to set GPIO pins for the I2C bus.
This has a direct relationship to the GPIO number used for the two I2C wires
  - Line 90-91: We declare a member variable `m_isInitialized` to guard aginst multiple initialization
  - Line 93-94: We declare a member variable `m_sdaPin` to hold the physical GPIO used for the SDA wire
  - Line 95-95: We declare a member variable `m_sclPin` to hold the physical GPIO used for the SCL wire
  - Line 98-99: We declare a member variable `m_coreClockRate` to hold the SoC core clock rate (in Hz), which is used to derive the I2C clock rate
  - Line 100-101: We declare a member variable `m_clockSpeed` to hold the I2C clock rate (in Hz) set for the specified clock mode
  - Line 104: We declare the constructor, which either takes the singleton `MemoryAccess` instance, or any other passed `IMemoryAccess` instance (for testing)
  - Line 106: We declare the destructor
  - Line 108: We declare the method `Initialize()` to initialize the master for the specified bus, using the specified clock mode and configuration
  - Line 110: We declare the method `SetClock()` to set the I2C clock rate in Hz
  - Line 111: We declate the method `Scan()` to scan a specific address for existence of a I2C device
  - Line 112: We override the method `Read()` in `II2CMaster` to read a single byte from an I2C device
  - Line 113: We override the method `Read()` in `II2CMaster` to read one or more bytes from an I2C device
  - Line 114: We override the method `Write()` in `II2CMaster` to write a single byte to an I2C device
  - Line 115: We override the method `Write()` in `II2CMaster` to write one of more bytes to an I2C device
  - Line 116: We override the method `WriteReadRepeatedStart()` in `II2CMaster` which send and receives data until the specific number of bytes is read
  - Line 119: We declare a method `ReadControlRegister()` to read from the I2C Control Register
  - Line 120: We declare a method `WriteControlRegister()` to write to the I2C Control Register
  - Line 121: We declare a method `StartReadTransfer()` to start a data read transfer
  - Line 122: We declare a method `StartWriteTransfer()` to start a data write transfer
  - Line 123: We declare a method `ClearFIFO()` to clear both read and write FIFO
  - Line 124: We declare a method `WriteAddressRegister()` to write to the I2C Address Register
  - Line 125: We declare a method `WriteDataLengthRegister()` to write to the I2C DataLength Register
  - Line 126: We declare a method `ReadStatusRegister()` to read from the I2C Status Register
  - Line 127: We declare a method `WriteStatusRegister()` to write to the I2C Status Register
  - Line 128: We declare a method `HasClockStretchTimeout()` to check whether a Clock Stretch Timeout has occurred
  - Line 129: We declare a method `HasAck()` to check whether an Ack was received
  - Line 130: We declare a method `HasNAck()` to check whether no Ack was received
  - Line 131: We declare a method `ReceiveFIFOFull()` to check whether the receive FIFO is full
  - Line 132: We declare a method `ReceiveFIFOHasData()` to check whether the receive FIFO contains data
  - Line 133: We declare a method `ReceiveFIFONeedsReading()` to check whether the receive FIFO needs reading, i.e. when the receive FIFO is at least 3/4 full
  - Line 134: We declare a method `TransmitFIFOEmpty()` to check whether the transmit FIFO is empty
  - Line 135: We declare a method `TransmitFIFOHasSpace()` to check whether the transmit FIFO has space to write
  - Line 136: We declare a method `TransmitFIFONeedsWriting()` to check whether the transmit FIFO needs writing, i.e. when the transmit FIFO is 1/4 full or less
  - Line 137: We declare a method `TransferDone()` to check whether the transfer is done
  - Line 138: We declare a method `TransferActive()` to check whether there is an active transfer
  - Line 139: We declare a method `ClearClockStretchTimeout()` to clear the Clock Stretch Timeout condition
  - Line 140: We declare a method `ClearNAck()` to clear the NAck condition
  - Line 141: We declare a method `ClearDone()` to clear the done status
  - Line 142: We declare a method `ClearAllStatus()` to clear the clock stretch timeout, NAck condition and done status
  - Line 143: We declare a method `ReadFIFORegister()` to read from the I2C FIFO
  - Line 144: We declare a method `WriteFIFORegister()` to write to the I2C FIFO

### I2CMaster.cpp {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_I2CMASTERCPP}

Let's implement the `I2CMaster` class.

Create the file `code/libraries/baremetal/src/I2CMaster.cpp`

```cpp
File: code/libraries/baremetal/src/I2CMaster.cpp
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : I2CMaster.cpp
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : I2CMaster
9: //
10: // Description : I2C Master functionality
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39:
40: #include "baremetal/I2CMaster.h"
41:
42: #include "baremetal/Assert.h"
43: #include "baremetal/Logger.h"
44: #include "baremetal/MachineInfo.h"
45: #include "baremetal/String.h"
46: #include "baremetal/Timer.h"
47:
48: /// @file
49: /// I2CMaster
50:
51: using namespace baremetal;
52:
53: /// @brief Define log name
54: LOG_MODULE("I2CMaster");
55:
56: #if BAREMETAL_RPI_TARGET == 3
57: /// @brief Number of I2C buses for RPI 3
58: #define I2C_BUSES 2
59: #else
60: /// @brief Number of I2C buses for RPI 4
61: #define I2C_BUSES 7
62: #endif
63:
64: /// @brief Total number of different GPIO pin configurations for I2C pins
65: #define I2C_CONFIGURATIONS    3
66:
67: /// @brief Total number of GPIO pins used for I2C (SCL / SDA)
68: #define I2C_GPIOS             2
69: /// @brief Index of I2C SDA pin
70: #define I2C_GPIO_SDA          0
71: /// @brief Index of I2C SCL pin
72: #define I2C_GPIO_SCL          1
73:
74: /// @brief Value in configuration table to flag invalid combination
75: #define NONE                  {10000, 10000}
76:
77: /// @brief I2C addresses below RESERVED_ADDRESS_LOW are reserved
78: #define RESERVED_ADDRESS_LOW  0x07
79: /// @brief I2C addresses staring from RESERVED_ADDRESS_HIGH are reserved
80: #define RESERVED_ADDRESS_HIGH 0x78
81: /// @brief Highest 10 bit address
82: #define ADDRESS_10BIT_HIGH    0x3FF
83:
84: /// @brief GPIO pin configurations for I2C pins. For every bus there are multiple configurations for the two I2C pins
85: static unsigned s_gpioConfig[I2C_BUSES][I2C_CONFIGURATIONS][I2C_GPIOS] = {
86:     // SDA, SCL
87:     {{0, 1},   {28, 29}, {44, 45}}, // Alt0, Alt0, Alt1
88:     {{2, 3},   NONE,     NONE    }, // Alt0
89: #if BAREMETAL_RPI_TARGET == 4
90:     {NONE,     NONE,     NONE    }, // unused
91:     {{2, 3},   {4, 5},   NONE    }, // Alt5, Alt5
92:     {{6, 7},   {8, 9},   NONE    }, // Alt5, Alt5
93:     {{10, 11}, {12, 13}, NONE    }, // Alt5, Alt5
94:     {{22, 23}, NONE,     NONE    }  // Alt5
95: #endif
96: };
97:
98: /// @brief I2C register bases addresses for each bus, depening on the RPI model
99: static regaddr s_baseAddress[I2C_BUSES] = {
100:     RPI_I2C0_BASE,
101:     RPI_I2C1_BASE,
102: #if BAREMETAL_RPI_TARGET == 4
103:     0,
104:     RPI_I2C3_BASE,
105:     RPI_I2C4_BASE,
106:     RPI_I2C5_BASE,
107:     RPI_I2C6_BASE,
108: #endif
109: };
110:
111: /// @brief FIFO register mask. Only one byte can be written at once
112: #define RPI_I2C_FIFO_MASK     0xFF
113:
114: /// @brief Size of FIFO for both read and write operations
115: #define RPI_I2C_FIFO_SIZE     16
116:
117: /// @brief Macro to determine GPIO function to be selected for a specific bus and configuration
118: #define ALT_FUNC(bus, config) ((bus) == 0 && (config) == 2 ? GPIOMode::AlternateFunction1 : ((bus) < 2 ? GPIOMode::AlternateFunction0 : GPIOMode::AlternateFunction5))
119:
120: /// <summary>
121: /// Constructor for I2CMaster
122: ///
123: /// The default value for memoryAccess will use the singleton MemoryAccess instance. A different reference to a IMemoryAccess instance can be passed for testing
124: /// </summary>
125: /// <param name="memoryAccess">MemoryAccess instance to be used for register access</param>
126: I2CMaster::I2CMaster(IMemoryAccess& memoryAccess /* = GetMemoryAccess()*/)
127:     : m_memoryAccess{memoryAccess}
128:     , m_bus{}
129:     , m_baseAddress{}
130:     , m_clockMode{}
131:     , m_config{}
132:     , m_isInitialized{}
133:     , m_sdaPin{memoryAccess}
134:     , m_sclPin{memoryAccess}
135:     , m_coreClockRate{}
136:     , m_clockSpeed{}
137: {
138: }
139:
140: /// <summary>
141: /// Destructor for I2CMaster
142: /// </summary>
143: I2CMaster::~I2CMaster()
144: {
145:     if (m_isInitialized)
146:     {
147:         m_sdaPin.SetMode(GPIOMode::InputPullUp);
148:         m_sclPin.SetMode(GPIOMode::InputPullUp);
149:     }
150:     m_isInitialized = false;
151:     m_baseAddress = nullptr;
152: }
153:
154: /// <summary>
155: /// Initialize the I2CMaster for a specific bus, using the specified configuration index, and setting the clock as specified.
156: /// </summary>
157: /// <param name="bus">Device number (see: comment for I2CMaster class</param>
158: /// <param name="mode">I2C clock rate to be used</param>
159: /// <param name="config">Configuration index to be used. Determines which GPIO pins are to be used for the I2C bus</param>
160: /// <returns></returns>
161: bool I2CMaster::Initialize(uint8 bus, I2CClockMode mode, uint32 config)
162: {
163:     if (m_isInitialized)
164:         return true;
165:
166:     LOG_INFO("Initialize bus %d, mode %d, config %d", bus, static_cast<int>(mode), config);
167:     if ((bus >= I2C_BUSES) || (config >= I2C_CONFIGURATIONS) || (s_gpioConfig[bus][config][I2C_GPIO_SDA] >= NUM_GPIO))
168:         return false;
169:
170:     m_bus = bus;
171:     m_clockMode = mode;
172:     m_config = config;
173:     m_baseAddress = s_baseAddress[m_bus];
174:     m_coreClockRate = GetMachineInfo().GetClockRate(ClockID::CORE);
175:
176:     assert(m_baseAddress != 0);
177:
178:     m_sdaPin.AssignPin(s_gpioConfig[m_bus][m_config][I2C_GPIO_SDA]);
179:     m_sdaPin.SetMode(ALT_FUNC(m_bus, m_config));
180:
181:     m_sclPin.AssignPin(s_gpioConfig[m_bus][m_config][I2C_GPIO_SCL]);
182:     m_sclPin.SetMode(ALT_FUNC(m_bus, m_config));
183:
184:     assert(m_coreClockRate > 0);
185:
186:     m_isInitialized = true;
187:
188:     SetClock(m_clockMode == I2CClockMode::FastPlus ? 1000000 : (m_clockMode == I2CClockMode::Fast ? 400000 : 100000));
189:
190:     LOG_INFO("Set up bus %d, config %d, base address %08X", bus, config, m_baseAddress);
191:     return true;
192: }
193:
194: /// <summary>
195: /// Set I2C clock rate
196: /// </summary>
197: /// <param name="clockRate">Clock rate in Hz</param>
198: void I2CMaster::SetClock(unsigned clockRate)
199: {
200:     assert(m_isInitialized);
201:
202:     assert(clockRate > 0);
203:     m_clockSpeed = clockRate;
204:
205:     uint16 divider = static_cast<uint16>(m_coreClockRate / clockRate);
206:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_DIV_OFFSET), divider);
207:     LOG_INFO("Set clock %d", clockRate);
208: }
209:
210: /// <summary>
211: /// Scan I2C bus for existing of a device at the specified address
212: /// </summary>
213: /// <param name="address">I2C address to be scanned</param>
214: /// <returns>Returns true if a device was found, false otherwise</returns>
215: bool I2CMaster::Scan(uint16 address)
216: {
217:     uint8 data{};
218:     return Write(address, data) == 1;
219: }
220:
221: /// <summary>
222: /// Read a single byte from the I2C device with specified address
223: /// </summary>
224: /// <param name="address">Device address</param>
225: /// <param name="data">Data to be received</param>
226: /// <returns>Returns number of bytes read, or errorcode < 0 on failure</returns>
227: size_t I2CMaster::Read(uint16 address, uint8& data)
228: {
229:     return Read(address, &data, 1);
230: }
231:
232: /// <summary>
233: /// Read a requested number of bytes from the I2C device with specified address
234: /// </summary>
235: /// <param name="address">Device address</param>
236: /// <param name="buffer">Pointer to buffer to store data read</param>
237: /// <param name="count">Requested number of bytes to read</param>
238: /// <returns>Returns number of bytes read, or errorcode < 0 on failure</returns>
239: size_t I2CMaster::Read(uint16 address, void* buffer, size_t count)
240: {
241:     assert(m_isInitialized);
242:
243:     if ((address >= ADDRESS_10BIT_HIGH) || (count == 0))
244:     {
245:         return I2C_MASTER_INVALID_PARM;
246:     }
247:     if (address >= RESERVED_ADDRESS_HIGH)
248:     {
249:         // We need to start a write / read cycle
250:         // The address part contains bits 8 and 9 of the address, the first write data byte the bits 0 through 7 of the address.
251:         // After this we read the device
252:         uint8 secondAddressByte = address & 0xFF;
253:         uint8 firstAddressByte = static_cast<uint8>(0x78 | ((address >> 8) & 0x03));
254:         return WriteReadRepeatedStart(firstAddressByte, &secondAddressByte, 1, buffer, count);
255:     }
256:
257:     uint8 addressByte{static_cast<uint8>(address & 0x7F)};
258:
259:     uint8* data = reinterpret_cast<uint8*>(buffer);
260:     assert(data != nullptr);
261:
262:     size_t result = 0;
263:
264:     WriteAddressRegister(addressByte);
265:
266:     ClearFIFO();
267:     ClearAllStatus();
268:     WriteDataLengthRegister(count);
269:     StartReadTransfer();
270:
271:     // Transfer active
272:     while (!TransferDone())
273:     {
274:         while (ReceiveFIFOHasData())
275:         {
276:             *data++ = ReadFIFORegister();
277:             TRACE_DEBUG("Read byte from %02x, data %02x", address, *(data - 1));
278:
279:             count--;
280:             result++;
281:         }
282:     }
283:
284:     // Transfer has finished, grab any remaining stuff from FIFO
285:     while ((count > 0) && ReceiveFIFOHasData())
286:     {
287:         *data++ = ReadFIFORegister();
288:         TRACE_DEBUG("Read extra byte from %02x, data %02x", address, *(data - 1));
289:
290:         count--;
291:         result++;
292:     }
293:
294:     TRACE_DEBUG("Read result = %d", result);
295:
296:     uint32 status = ReadStatusRegister();
297:     if (status & RPI_I2C_S_ERR)
298:     {
299:         // Clear error bit
300:         ClearNAck();
301:
302:         result = I2C_MASTER_ERROR_NACK;
303:     }
304:     else if (status & RPI_I2C_S_CLKT)
305:     {
306:         ClearClockStretchTimeout();
307:         result = I2C_MASTER_ERROR_CLKT;
308:     }
309:     else if (count > 0)
310:     {
311:         result = I2C_MASTER_DATA_LEFT;
312:     }
313:
314:     // Clear done bit
315:     ClearDone();
316:
317:     return result;
318: }
319:
320: /// <summary>
321: /// Write a single byte to the I2C device with specified address
322: /// </summary>
323: /// <param name="address">Device address</param>
324: /// <param name="data">Data to write</param>
325: /// <returns>Returns number of bytes written, or errorcode < 0 on failure</returns>
326: size_t I2CMaster::Write(uint16 address, uint8 data)
327: {
328:     return Write(address, &data, 1);
329: }
330:
331: /// <summary>
332: /// Write a requested number of bytes to the I2C device with specified address
333: /// </summary>
334: /// <param name="address">Device address</param>
335: /// <param name="buffer">Pointer to buffer containing data to sebd</param>
336: /// <param name="count">Requested number of bytes to write</param>
337: /// <returns>Returns number of bytes written, or errorcode < 0 on failure</returns>
338: size_t I2CMaster::Write(uint16 address, const void* buffer, size_t count)
339: {
340:     assert(m_isInitialized);
341:
342:     if (address >= ADDRESS_10BIT_HIGH)
343:     {
344:         return I2C_MASTER_INVALID_PARM;
345:     }
346:
347:     if ((count != 0) && (buffer == nullptr))
348:     {
349:         return I2C_MASTER_INVALID_PARM;
350:     }
351:
352:     const uint8* data = reinterpret_cast<const uint8*>(buffer);
353:     assert(data != nullptr);
354:
355:     int result = 0;
356:
357:     ClearFIFO();
358:
359:     unsigned bytesWritten{};
360:     uint8 addressByte{static_cast<uint8>(address & 0x7F)};
361:     if (address >= RESERVED_ADDRESS_HIGH)
362:     {
363:         // We need to write the low 8 bits of the address first
364:         // The address part contains bits 8 and 9 of the address, the first write data byte the bits 0 through 7 of the address.
365:         uint8 secondAddressByte = address & 0xFF;
366:         addressByte = static_cast<uint8>(0x78 | ((address >> 8) & 0x03));
367:         WriteFIFORegister(secondAddressByte);
368:         bytesWritten++;
369:     }
370:
371:     WriteAddressRegister(addressByte);
372:     ClearAllStatus();
373:     WriteDataLengthRegister(static_cast<uint8>(bytesWritten + count));
374:
375:     // Fill FIFO
376:     for (; count > 0 && bytesWritten < RPI_I2C_FIFO_SIZE; bytesWritten++)
377:     {
378:         WriteFIFORegister(*data++);
379:         count--;
380:         result++;
381:     }
382:
383:     StartWriteTransfer();
384:
385:     // Transfer active
386:     while (!TransferDone())
387:     {
388:         while ((count > 0) && TransmitFIFOHasSpace())
389:         {
390:             TRACE_DEBUG("Write extra byte to %02x, data %02x", address, *data);
391:             WriteFIFORegister(*data++);
392:             count--;
393:             result++;
394:         }
395:         Timer::WaitMilliSeconds(1);
396:     }
397:
398:     TRACE_DEBUG("Write result = %d", result);
399:
400:     // Check status
401:     uint32 status = ReadStatusRegister();
402:     if (status & RPI_I2C_S_ERR)
403:     {
404:         // Clear error bit
405:         ClearNAck();
406:
407:         result = I2C_MASTER_ERROR_NACK;
408:     }
409:     else if (status & RPI_I2C_S_CLKT)
410:     {
411:         ClearClockStretchTimeout();
412:         result = I2C_MASTER_ERROR_CLKT;
413:     }
414:     else if (count > 0)
415:     {
416:         result = I2C_MASTER_DATA_LEFT;
417:     }
418:
419:     // Clear done bit
420:     ClearDone();
421:
422:     while (ReceiveFIFOHasData())
423:     {
424:         uint8 data = ReadFIFORegister();
425:         TRACE_DEBUG("Read byte = %02x", data);
426:     }
427:
428:     return result;
429: }
430:
431: /// <summary>
432: /// Consecutive write and read operation with repeated start
433: /// </summary>
434: /// <param name="address">I2C address of target device</param>
435: /// <param name="writeBuffer">Write data for will be taken from here</param>
436: /// <param name="writeCount">Number of bytes to be written (max. 16)</param>
437: /// <param name="readBuffer">Read data will be stored here</param>
438: /// <param name="readCount">Number of bytes to be read</param>
439: /// <returns>Returns number of bytes read, or errorcode < 0 on failure</returns>
440: size_t I2CMaster::WriteReadRepeatedStart(uint16 address, const void* writeBuffer, size_t writeCount, void* readBuffer, size_t readCount)
441: {
442:     assert(m_isInitialized);
443:
444:     if (address >= ADDRESS_10BIT_HIGH)
445:     {
446:         return I2C_MASTER_INVALID_PARM;
447:     }
448:
449:     if ((writeCount == 0) || (writeCount > ((address >= 0x78) ? RPI_I2C_FIFO_SIZE - 1 : RPI_I2C_FIFO_SIZE)) || (writeBuffer == nullptr) || (readCount == 0) || (readBuffer == nullptr))
450:     {
451:         return I2C_MASTER_INVALID_PARM;
452:     }
453:
454:     const uint8* writeData = reinterpret_cast<const uint8*>(writeBuffer);
455:     assert(writeData != nullptr);
456:
457:     int result = 0;
458:
459:     ClearFIFO();
460:
461:     unsigned bytesWritten{};
462:     uint8 addressByte{static_cast<uint8>(address & 0x7F)};
463:     if (address >= RESERVED_ADDRESS_HIGH)
464:     {
465:         // We need to write the low 8 bits of the address first
466:         // The address part contains bits 8 and 9 of the address, the first write data byte the bits 0 through 7 of the address.
467:         uint8 secondAddressByte = address & 0xFF;
468:         addressByte = static_cast<uint8>(0x78 | ((address >> 8) & 0x03));
469:         WriteFIFORegister(secondAddressByte);
470:         bytesWritten++;
471:     }
472:
473:     WriteAddressRegister(addressByte);
474:     ClearAllStatus();
475:     WriteDataLengthRegister(static_cast<uint8>(bytesWritten + writeCount));
476:
477:     // Fill FIFO
478:     for (; writeCount > 0 && bytesWritten < RPI_I2C_FIFO_SIZE; bytesWritten++)
479:     {
480:         WriteFIFORegister(*writeData++);
481:
482:         writeCount--;
483:         result++;
484:     }
485:
486:     StartWriteTransfer();
487:
488:     // Poll to check transfer has started
489:     while (!TransferActive())
490:     {
491:         if (TransferDone())
492:         {
493:             break;
494:         }
495:     }
496:
497:     uint8* readData = reinterpret_cast<uint8*>(readBuffer);
498:
499:     WriteDataLengthRegister(readCount);
500:     StartReadTransfer();
501:
502:     assert(m_clockSpeed > 0);
503:     Timer::WaitMicroSeconds((writeCount + 1) * 9 * 1000000 / m_clockSpeed);
504:
505:     // Transfer active
506:     while (!TransferDone())
507:     {
508:         while ((readCount > 0) && ReceiveFIFOHasData())
509:         {
510:             *readData++ = ReadFIFORegister();
511:
512:             readCount--;
513:             result++;
514:         }
515:     }
516:
517:     // Transfer has finished, grab any remaining stuff from FIFO
518:     while ((readCount > 0) && ReceiveFIFOHasData())
519:     {
520:         *readData++ = ReadFIFORegister();
521:
522:         readCount--;
523:         result++;
524:     }
525:
526:     // Check status
527:     uint32 status = ReadStatusRegister();
528:     if (status & RPI_I2C_S_ERR)
529:     {
530:         // Clear error bit
531:         ClearNAck();
532:
533:         result = I2C_MASTER_ERROR_NACK;
534:     }
535:     else if (status & RPI_I2C_S_CLKT)
536:     {
537:         ClearClockStretchTimeout();
538:         result = I2C_MASTER_ERROR_CLKT;
539:     }
540:     else if (readCount > 0)
541:     {
542:         result = I2C_MASTER_DATA_LEFT;
543:     }
544:
545:     // Clear done bit
546:     ClearDone();
547:
548:     return result;
549: }
550:
551: /// <summary>
552: /// Read the I2C Control Register
553: /// </summary>
554: /// <returns>Value read from I2C Control Register</returns>
555: uint32 I2CMaster::ReadControlRegister()
556: {
557:     auto result = m_memoryAccess.Read32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_C_OFFSET));
558:     if (GetLogger().IsLogSeverityEnabled(LogSeverity::Data))
559:     {
560:         String text;
561:         text += (result & RPI_I2C_C_ENABLE) ? "EN " : "   ";
562:         text += (result & RPI_I2C_C_INTR_ENABLE) ? "IR " : "  ";
563:         text += (result & RPI_I2C_C_INTT_ENABLE) ? "IT " : "  ";
564:         text += (result & RPI_I2C_C_INTD_ENABLE) ? "ID " : "  ";
565:         text += (result & RPI_I2C_C_ST) ? "ST " : "  ";
566:         text += (result & RPI_I2C_C_CLEAR) ? "CL " : "  ";
567:         text += (result & RPI_I2C_C_READ) ? "RD " : "WR ";
568:         TRACE_DATA("Read I2C Control, %s", text.c_str());
569:     }
570:     return result;
571: }
572:
573: /// <summary>
574: /// Write to the I2C Control Register
575: /// </summary>
576: /// <param name="data">Value to write</param>
577: void I2CMaster::WriteControlRegister(uint32 data)
578: {
579:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_C_OFFSET), data);
580:     if (GetLogger().IsLogSeverityEnabled(LogSeverity::Data))
581:     {
582:         String text;
583:         text += (data & RPI_I2C_C_ENABLE) ? "EN " : "   ";
584:         text += (data & RPI_I2C_C_INTR_ENABLE) ? "IR " : "  ";
585:         text += (data & RPI_I2C_C_INTT_ENABLE) ? "IT " : "  ";
586:         text += (data & RPI_I2C_C_INTD_ENABLE) ? "ID " : "  ";
587:         text += (data & RPI_I2C_C_ST) ? "ST " : "  ";
588:         text += (data & RPI_I2C_C_CLEAR) ? "CL " : "  ";
589:         text += (data & RPI_I2C_C_READ) ? "RD " : "WR ";
590:         TRACE_DATA("Write I2C Control, %s", text.c_str());
591:     }
592: }
593:
594: /// <summary>
595: /// Start a read transfer
596: /// </summary>
597: void I2CMaster::StartReadTransfer()
598: {
599:     WriteControlRegister(ReadControlRegister() | RPI_I2C_C_ENABLE | RPI_I2C_C_ST | RPI_I2C_C_READ);
600: }
601:
602: /// <summary>
603: /// Start a write transfer
604: /// </summary>
605: void I2CMaster::StartWriteTransfer()
606: {
607:     WriteControlRegister((ReadControlRegister() & ~RPI_I2C_C_READ) | RPI_I2C_C_ENABLE | RPI_I2C_C_ST | RPI_I2C_C_WRITE);
608: }
609:
610: /// <summary>
611: /// Clear the FIFO. This clears both read and write FIFO
612: /// </summary>
613: void I2CMaster::ClearFIFO()
614: {
615:     WriteControlRegister(ReadControlRegister() | RPI_I2C_C_CLEAR);
616: }
617:
618: /// <summary>
619: /// Write to the I2C Address Register
620: /// </summary>
621: /// <param name="data">Value to write</param>
622: void I2CMaster::WriteAddressRegister(uint8 data)
623: {
624:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_A_OFFSET), data);
625:     TRACE_DEBUG("Write I2C Address, %02x", data);
626: }
627:
628: /// <summary>
629: /// Write to the I2C Data Length Register
630: /// </summary>
631: /// <param name="data">Value to write</param>
632: void I2CMaster::WriteDataLengthRegister(uint8 data)
633: {
634:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_DLEN_OFFSET), data);
635:     TRACE_DEBUG("Write I2C Length, %08x", data);
636: }
637:
638: /// <summary>
639: /// Read the I2C Status Register
640: /// </summary>
641: /// <returns>Value read from I2C Status Register</returns>
642: uint32 I2CMaster::ReadStatusRegister()
643: {
644:     auto data = m_memoryAccess.Read32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_S_OFFSET));
645:     if (GetLogger().IsLogSeverityEnabled(LogSeverity::Data))
646:     {
647:         String text;
648:         text += (data & RPI_I2C_S_CLKT) ? "CLKT " : "     ";
649:         text += (data & RPI_I2C_S_ERR) ? "ERR " : "    ";
650:         text += (data & RPI_I2C_S_RXF) ? "RXF " : "    ";
651:         text += (data & RPI_I2C_S_TXE) ? "TXE " : "    ";
652:         text += (data & RPI_I2C_S_RXD) ? "RXD " : "    ";
653:         text += (data & RPI_I2C_S_TXD) ? "TXD " : "    ";
654:         text += (data & RPI_I2C_S_RXR) ? "RXR " : "    ";
655:         text += (data & RPI_I2C_S_TXW) ? "TXW " : "    ";
656:         text += (data & RPI_I2C_S_DONE) ? "DONE " : "     ";
657:         text += (data & RPI_I2C_S_TA) ? "TA " : "     ";
658:         TRACE_DATA("Read I2C Status, %s", text.c_str());
659:     }
660:     return data;
661: }
662:
663: /// <summary>
664: /// Write to the I2C Status Register
665: /// </summary>
666: /// <param name="data">Value to write</param>
667: void I2CMaster::WriteStatusRegister(uint32 data)
668: {
669:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_S_OFFSET), data);
670:     if (GetLogger().IsLogSeverityEnabled(LogSeverity::Data))
671:     {
672:         String text;
673:         text += (data & RPI_I2C_S_CLKT) ? "CLKT " : "     ";
674:         text += (data & RPI_I2C_S_ERR) ? "ERR " : "    ";
675:         text += (data & RPI_I2C_S_DONE) ? "DONE " : "     ";
676:         TRACE_DATA("Write I2C Status, %s", text.c_str());
677:     }
678: }
679:
680: /// <summary>
681: /// Check whether a clock stretch timeout has occurred
682: /// </summary>
683: /// <returns>Returns true if a clock stretch timeout has occurred</returns>
684: bool I2CMaster::HasClockStretchTimeout()
685: {
686:     return (ReadStatusRegister() & RPI_I2C_S_CLKT) != 0;
687: }
688:
689: /// <summary>
690: /// Check whether the latest byte has received an ACK
691: /// </summary>
692: /// <returns>Returns true if the latest byte has received an ACK</returns>
693: bool I2CMaster::HasAck()
694: {
695:     return (ReadStatusRegister() & RPI_I2C_S_ERR) == 0;
696: }
697:
698: /// <summary>
699: /// Check whether the latest byte has not received an ACK
700: /// </summary>
701: /// <returns>Returns true if the latest byte has not received an ACK</returns>
702: bool I2CMaster::HasNAck()
703: {
704:     return (ReadStatusRegister() & RPI_I2C_S_ERR) != 0;
705: }
706:
707: /// <summary>
708: /// Check whether the read FIFO is full
709: /// </summary>
710: /// <returns>Returns true if the read FIFO is full</returns>
711: bool I2CMaster::ReceiveFIFOFull()
712: {
713:     return (ReadStatusRegister() & RPI_I2C_S_RXF) != 0;
714: }
715:
716: /// <summary>
717: /// Check whether the read FIFO contains data
718: /// </summary>
719: /// <returns>Returns true if the read FIFO contains data</returns>
720: bool I2CMaster::ReceiveFIFOHasData()
721: {
722:     return (ReadStatusRegister() & RPI_I2C_S_RXD) != 0;
723: }
724:
725: /// <summary>
726: /// Check whether the read FIFO needs to be read. This means the FIFO is 3/4 full or more
727: /// </summary>
728: /// <returns>Returns true if the read FIFO needs to be read</returns>
729: bool I2CMaster::ReceiveFIFONeedsReading()
730: {
731:     return (ReadStatusRegister() & RPI_I2C_S_RXR) != 0;
732: }
733:
734: /// <summary>
735: /// Check whether the write FIFO is empty
736: /// </summary>
737: /// <returns>Returns true if the write FIFO is empty</returns>
738: bool I2CMaster::TransmitFIFOEmpty()
739: {
740:     return (ReadStatusRegister() & RPI_I2C_S_TXE) != 0;
741: }
742:
743: /// <summary>
744: /// Check whether the write FIFO has space to write
745: /// </summary>
746: /// <returns>Returns true if the write FIFO has space to write</returns>
747: bool I2CMaster::TransmitFIFOHasSpace()
748: {
749:     return (ReadStatusRegister() & RPI_I2C_S_TXD) != 0;
750: }
751:
752: /// <summary>
753: /// Check whether the write FIFO needs to be written to. This means the FIFO is 1/4 full or less
754: /// </summary>
755: /// <returns>Returns true if the write FIFO needs to be written to</returns>
756: bool I2CMaster::TransmitFIFONeedsWriting()
757: {
758:     return (ReadStatusRegister() & RPI_I2C_S_TXW) != 0;
759: }
760:
761: /// <summary>
762: /// Check whether the transfer is done
763: /// </summary>
764: /// <returns>Returns true if the transfer is done</returns>
765: bool I2CMaster::TransferDone()
766: {
767:     return (ReadStatusRegister() & RPI_I2C_S_DONE) != 0;
768: }
769:
770: /// <summary>
771: /// Check whether a transfer is active
772: /// </summary>
773: /// <returns>Returns true if a transfer is active</returns>
774: bool I2CMaster::TransferActive()
775: {
776:     return (ReadStatusRegister() & RPI_I2C_S_TA) != 0;
777: }
778:
779: /// <summary>
780: /// Clear the CLKT (Clock Stretch Timeout) bit in the I2C Status Register
781: /// </summary>
782: void I2CMaster::ClearClockStretchTimeout()
783: {
784:     WriteStatusRegister(RPI_I2C_S_CLKT);
785: }
786:
787: /// <summary>
788: /// Clear the ERR bit in the I2C Status Register
789: /// </summary>
790: void I2CMaster::ClearNAck()
791: {
792:     WriteStatusRegister(RPI_I2C_S_ERR);
793: }
794:
795: /// <summary>
796: /// Clear the DONE bit in the I2C Status Register
797: /// </summary>
798: void I2CMaster::ClearDone()
799: {
800:     WriteStatusRegister(RPI_I2C_S_DONE);
801: }
802:
803: /// <summary>
804: /// Clear the CLKT, ERR and DONE bits in the I2C Status Register
805: /// </summary>
806: void I2CMaster::ClearAllStatus()
807: {
808:     WriteStatusRegister(RPI_I2C_S_CLKT | RPI_I2C_S_ERR | RPI_I2C_S_DONE);
809: }
810:
811: /// <summary>
812: /// Read the I2C FIFO Register
813: /// </summary>
814: /// <returns>Value read from I2C FIFO Register</returns>
815: uint8 I2CMaster::ReadFIFORegister()
816: {
817:     uint8 data = m_memoryAccess.Read32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_FIFO_OFFSET)) & RPI_I2C_FIFO_MASK;
818:     TRACE_DEBUG("Read FIFO, data %08x", data);
819:     return data;
820: }
821:
822: /// <summary>
823: /// Write to the I2C FIFO Register
824: /// </summary>
825: /// <param name="data">Value to write</param>
826: void I2CMaster::WriteFIFORegister(uint8 data)
827: {
828:     m_memoryAccess.Write32(RPI_I2C_REG_ADDRESS(m_baseAddress, RPI_I2C_FIFO_OFFSET), data);
829:     TRACE_DEBUG("Write FIFO, data %08x", data);
830: }
```

- Line 56-62: We create a definition `I2C_BUSES` as the number of I2C buses available for the selected Raspberry Pi model
- Line 64-65: We create a definition `I2C_CONFIGURATIONS` as the maximum number of defined GPIO pin configurations for each bus
- Line 67-68: We create a definition `I2C_GPIOS` as the total number of pins defined for each bus, i.e. 2.
This is used for the configuration definition
- Line 69-70: We create a definition `I2C_GPIO_SDA` as the index of the SDA pin.
This is used for the configuration definition
- Line 71-72: We create a definition `I2C_GPIO_SCL` as the index of the SCL pin.
This is used for the configuration definition
- Line 74-75: We create a definition `NONE` as an unused or invalid pin configuration
- Line 77-78: We create a definition `RESERVED_ADDRESS_LOW` as the last I2C address in the low range which is reserved.
For I2C all addresses between 0 (0x00) and 7 (0x07) are reserved
- Line 79-80: We create a definition `RESERVED_ADDRESS_HIGH` as the first I2C address in the high range which is reserved.
For I2C all addresses between 120 (0x78) and 127 (0x7F) are reserved
- Line 81-82: We create a definition `ADDRESS_10BIT_HIGH` as the highest value supported for 10 bit I2C addresses
- Line 84-96: We define and initialize a variable `s_gpioConfig` which holds the different GPIO pin configurations for the I2C pins in each bus.
As can be seen there is no valid configuration for bus 2, as it is not on the GPIO header
- Line 98-109: We define and initialize a variable `s_baseAddress` which holds the register base address for each bus.
As can be seen there is no address specified for bus 2, as it is not on the GPIO header, so addressing it would be useless
- Line 111-112: We create a definition `RPI_I2C_FIFO_MASK` to denote the mask to be placed on the FIFO register when reading or writing.
The FIFO can only be read and written per single byte
- Line 114-115: We create a definition `RPI_I2C_FIFO_SIZE` to denote the size of the read and write FIFO
- Line 117-118: We create a macro `ALT_FUNC` to determine the GPIO pin function for a specific configuration on a specified bus index.
This relates to the pin numbers in `s_gpioConfig`.
Notice that the function is the same for SCL and SDA pins
- Line 120-138: We define the constructor
- Line 140-152: We define the destructor.
If initialized, this will reset the GPIO pins used to input mode with pull up
- Line 154-192: We define the method `Initialize()`
  - Line 163-164: If already initialized we simply return true
  - Line 167-168: We check for the validity of the specified bus index and configuration number, and whether this specifies valid GPIO pins.
If not we return false
  - Line 170-173: We save the parameters passed, and determine the register base address for the bus
  - Line 174: We request and save the core clock rate
  - Line 176: We assert that we have a valid register base address
  - Line 178-182: We assign the GPIO pins for SDA and SCL, and set them to the correct function
  - Line 184: We assert that we have a valid core clock rate
  - Line 186: We set the initialized flag
  - Line 188: We set the I2C clock rate depending on the mode
- Line 194-208: We define the method `SetClock()` to set the I2C clock rate.
This calculates the divider to be used to get from the core clock rate to the desired clock rate, and writes this value to the I2C Clock Divider register
- Line 210-219: We define the method `Scan()` to scan the bus for a specific I2C address.
It does this by trying to read from the specified address
- Line 221-230: We define the method `Read()` for a single byte read, this simply calls the `Read()` method for multiple bytes
- Line 232-320: We define the method `Read()` for one or more bytes
  - Line 241: We assert that the `Initialize()` method was correctly called
  - Line 243-246: We check that the I2C address is not out of range, and we're not trying to receive zero length data.
Notice that we support both 7 bit and 10 bit addresses.
If the address is not in range, we return an error code
  - Line 247-255: We check if the address is larger than the value address for 7 bits (larger or equal to 0x78).
If so we set the first data byte to write to the low 8 bits of the address, and set the new address byte to 0x78 OR'ed with the upper two bits of the address.
We then perform write-read operation to the new slave address, with the byte to be written equal to the low 8 bits of the address.
If the write fails, we return an error code
  - Line 257: We convert the low 7 bits to an address byte as we are dealing with a 7 bit address
  - Line 259-260: We convert the buffer pointer to a byte pointer and assert it is valid
  - Line 264: We set the I2C address with the new slave address
  - Line 266: We clear the FIFO
  - Line 267: We reset the Clock Stretch Timeout, Error (Nack) and Done conditions
  - Line 268: We set the data length
  - Line 269: We set read mode, enable the I2C controller, and start the transfer
  - Line 271-282: As long as the Done condition is not set, we read the status and check for available data.
If there is data, we read it and place it in the buffer
  - Line 284-292: Even when the Done condition is true, we read data as long as more is available and requested
  - Line 296: We read the status register
  - Line 297-303: We check for an Error condition (meaning no Ack was received), and if so reset the condition and set an error code as the result
  - Line 304-308: We check for an Clock Stretch Timeout condition, and if so reset the condition and set an error code as the result
  - Line 309-312: We check that all requested data was read, and if not set an error code as the result
  - Line 315: We reset the Done condition
- Line 320-329: We define the method `Write()` for a single byte write, this simply calls the other `Write()` method
- Line 331-429: We define the method `Write()` for one or more bytes
  - Line 340: We assert that the `Initialize()` method was correctly called
  - Line 342-345: We check that the address is within the right range and if not return an error code
  - Line 347-350: We check that the buffer is valid and the requested byte count is not zero and if not return an error code
  - Line 352-353: We convert the buffer pointer to a byte pointer and assert it is valid
  - Line 357: We clear the FIFO
  - Line 360: We convert the low 7 bits to an address byte, which is the default behaviour for the 7 bit address case
  - Line 361-369: We check if the address is larger than the value address for 7 bits (larger or equal to 0x78).
If so we set the first data byte to write to the low 8 bits of the address, and set the address byte to 0x78 OR'ed with the upper two bits of the address.
We then add the low 8 bits to the FIFO, and increment the write count to signal that one byte is already in the transmit FIFO
  - Line 371: We set the I2C address with the new slave address
  - Line 372: We reset the Clock Stretch Timeout, Error (Nack) and Done conditions
  - Line 373: We set the data length
  - Line 375-381: We write data to the FIFO until done or the FIFO is full
  - Line 383: We set write mode, enable the I2C controller, and start the transfer
  - Line 385-396: As long as the Done condition is not set, we read the status and check whether there is space in the FIFO to write data.
If there is space and we need to write more data, we write to the FIFO
  - Line 401: We read the I2C Status Register
  - Line 402-408: If there was an Error condition (no Ack received) we reset the Error condition and return an error code
  - Line 409-413: If there was a Clock Stretch Timeout, we reset the Error condition and return an error code
  - Line 414-417: If there is still data to be written, we return an error code
  - Line 420: We reset the Done bit
  - Line 422-426: If there is data to be read we read it. This is to avoid confusion between transfers
- Line 431-548: We define the method `WriteReadRepeatedStart()` to write and read data simultaneously
  - Line 442: We assert that the `Initialize()` method was correctly called
  - Line 444-447: We check that the address is within the right range and if not return an error code
  - Line 449-452: We check that the read and write buffer are valid and the requested send byte count is not zero and not more than the FIFO can hold, as well as that the requested receive count is not zero, and if not return an error code
  - Line 454-455: We convert the write buffer pointer to a byte pointer and assert it is valid
  - Line 459: We clear the FIFO
  - Line 462: We convert the low 7 bits to an address byte, which is the default behaviour for the 7 bit address case
  - Line 463-471: We check if the address is larger than the value address for 7 bits (larger or equal to 0x78).
If so we set the first data byte to write to the low 8 bits of the address, and set the address byte to 0x78 OR'ed with the upper two bits of the address.
We then add the low 8 bits to the FIFO, and increment the write count to signal that one byte is already in the transmit FIFO
  - Line 473: We set the I2C address with the new slave address
  - Line 474: We reset the Clock Stretch Timeout, Error (Nack) and Done conditions
  - Line 475: We set the data length with the number of bytes to send
  - Line 477-484: We write data to the FIFO until done or the FIFO is full
  - Line 486: We set write mode, enable the I2C controller, and start the transfer
  - Line 488-495: If no transfer is active, we check is the Done condition is set, and continue if it is.
  - Line 497: We convert the read buffer pointer to a byte pointer
  - Line 499: We set the data length with the number of bytes to receive
  - Line 500: We set read mode, enable the I2C controller, and start the transfer
  - Line 502-503: We wait a bit depending on the number of bytes sent and the I2C clock rate
  - Line 505-515: As long as the Done condition is not set, we read the status and check whether there is receive data available.
If so we read the data from the FIFO
  - Line 517-524: As long as the there is receive data available, we read the data from the FIFO.
  - Line 527: We read the I2C Status Register
  - Line 528-534: If there was an Error condition (no Ack received) we reset the Error condition and return an error code
  - Line 535-539: If there was a Clock Stretch Timeout, we reset the Error condition and return an error code
  - Line 540-543: If we could not read the requested amount of bytes, we return an error code
  - Line 546: We reset the Done bit
- Line 551-571: We define the method `ReadControlRegister()`. We trace the register contents if enabled
- Line 573-592: We define the method `WriteControlRegister()`. We trace the register contents if enabled
- Line 594-600: We define the method `StartReadTransfer()`
- Line 602-608: We define the method `StartWriteTransfer()`
- Line 610-616: We define the method `ClearFIFO()`
- Line 618-626: We define the method `WriteAddressRegister()`. We trace the register contents if enabled
- Line 628-636: We define the method `WriteDataLengthRegister()`. We trace the register contents if enabled
- Line 638-661: We define the method `ReadStatusRegister()`. We trace the register contents if enabled
- Line 663-678: We define the method `WriteStatusRegister()`. We trace the register contents if enabled
- Line 680-687: We define the method `HasClockStretchTimeout()`
- Line 689-696: We define the method `HasAck()`
- Line 698-705: We define the method `HasNAck()`
- Line 707-714: We define the method `ReceiveFIFOFull()`
- Line 716-723: We define the method `ReceiveFIFOHasData()`
- Line 725-732: We define the method `ReceiveFIFONeedsReading()`
- Line 734-741: We define the method `TransmitFIFOEmpty()`
- Line 743-750: We define the method `TransmitFIFOHasSpace()`
- Line 752-759: We define the method `TransmitFIFONeedsWriting()`
- Line 761-768: We define the method `TransferDone()`
- Line 770-777: We define the method `TransferActive()`
- Line 779-785: We define the method `ClearClockStretchTimeout()`
- Line 787-793: We define the method `ClearNAck()`
- Line 795-801: We define the method `ClearDone()`
- Line 803-809: We define the method `ClearAllStatus()`
- Line 811-820: We define the method `ReadFIFORegister()`
- Line 822-830: We define the method `WriteFIFORegister()`

In principle we could start writing an application, but we'll fake the I2C functionality first.

### MemoryAccessStubI2C.h {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_MEMORYACCESSSTUBI2CH}

We'll define a `IMemoryAccess` implementation that will fake the I2C register access, and also handles the case where GPIO is addressed.

Create file `code/libraries/baremetal/include/baremetal/stubs/MemoryAccessStubI2C.h`

```cpp
File: code/libraries/baremetal/include/baremetal/stubs/MemoryAccessStubI2C.h
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MemoryAccessStubI2C.h
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : MemoryAccessStubI2C
9: //
10: // Description : I2C register memory access stub
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39:
40: #pragma once
41:
42: #include "baremetal/stubs/MemoryAccessStubGPIO.h"
43: #include "stdlib/Macros.h"
44:
45: /// @file
46: /// MemoryAccessStubI2C
47:
48: namespace baremetal {
49:
50: /// @brief I2C registers storage
51: struct I2CRegisters
52: {
53:     /// @brief I2C Control Register (C)
54:     uint32 ControlRegister;
55:     /// @brief I2C Status Register (C)
56:     uint32 StatusRegister;
57:     /// @brief I2C Data Length Register (DLEN)
58:     uint32 DataLengthRegister;
59:     /// @brief I2C Address Register (A)
60:     uint32 AddressRegister;
61:     /// @brief I2C FIFO Register (FIFO)
62:     uint32 FIFORegister;
63:     /// @brief I2C ClockDivider Register (DIV)
64:     uint32 ClockDividerRegister;
65:     /// @brief I2C Data Delay Register (DEL)
66:     uint32 DataDelayRegister;
67:     /// @brief I2C Clock Stretch Timeout Register (CLKT)
68:     uint32 ClockStretchTimeoutRegister;
69:
70:     /// <summary>
71:     /// Constructor for I2CRegisters
72:     ///
73:     /// Sets default register values
74:     /// </summary>
75:     I2CRegisters()
76:         : ControlRegister{}
77:         , StatusRegister{0x00000050}
78:         , DataLengthRegister{}
79:         , AddressRegister{}
80:         , FIFORegister{}
81:         , ClockDividerRegister{0x000005DC}
82:         , DataDelayRegister{0x00300030}
83:         , ClockStretchTimeoutRegister{0x00000040}
84:     {
85:     }
86: } PACKED;
87:
88: /// @brief FIFO size (both read and write)
89: #define I2C_FIFO_SIZE 16
90:
91: /// @brief FIFO template class
92: template <int N>
93: class FIFO
94: {
95: private:
96:     /// @brief Data in FIFO (max 16 bytes)
97:     uint8 m_data[N]; // Size 16
98:     /// @brief Read index. If m_readIndex == m_writeIndex, the FIFO is either empty or full, depending on the full flag
99:     int m_readIndex; // Size 4
100:     /// @brief Write index. If m_readIndex == m_writeIndex, the FIFO is either empty or full, depending on the full flag
101:     int m_writeIndex; // Size 4
102:     /// @brief Flag whether the FIFO is full
103:     bool m_isFull; // Size 1
104:     /// @brief Force alignment to 16 bytes
105:     uint8 align[7]; // Size 7
106:
107: public:
108:     /// <summary>
109:     /// FIFO constructor
110:     /// </summary>
111:     FIFO()
112:         : m_data{}
113:         , m_readIndex{}
114:         , m_writeIndex{}
115:         , m_isFull{}
116:     {
117:     }
118:     /// <summary>
119:     /// Read a byte from the FIFO
120:     /// </summary>
121:     /// <returns>Byte read. If nothing can be read, returns 0</returns>
122:     uint8 Read()
123:     {
124:         uint8 result{};
125:         if (!IsEmpty())
126:         {
127:             result = m_data[m_readIndex];
128:             m_readIndex = (m_readIndex + 1) % N;
129:             m_isFull = false;
130:         }
131:         return result;
132:     }
133:     /// <summary>
134:     /// Write a byte to the FIFO
135:     /// </summary>
136:     /// <param name="data">Data to write</param>
137:     void Write(uint8 data)
138:     {
139:         if (!IsFull())
140:         {
141:             m_data[m_writeIndex] = data;
142:             m_writeIndex = (m_writeIndex + 1) % N;
143:             if (m_readIndex == m_writeIndex)
144:                 m_isFull = true;
145:         }
146:     }
147:     /// <summary>
148:     /// Check if FIFO is empty
149:     /// </summary>
150:     /// <returns>true if FIFO is empty, false otherwise</returns>
151:     bool IsEmpty()
152:     {
153:         return (m_readIndex == m_writeIndex) && !m_isFull;
154:     }
155:     /// <summary>
156:     /// Check if FIFO is full
157:     /// </summary>
158:     /// <returns>true if FIFO is full, false otherwise</returns>
159:     bool IsFull()
160:     {
161:         return (m_readIndex == m_writeIndex) && m_isFull;
162:     }
163:     /// <summary>
164:     /// Check if FIFO is at most 25% full
165:     /// </summary>
166:     /// <returns>true if FIFO is at most 25% full, false otherwise</returns>
167:     bool IsOneQuarterOrLessFull()
168:     {
169:         return ((m_writeIndex - m_readIndex + I2C_FIFO_SIZE) % I2C_FIFO_SIZE) <= (I2C_FIFO_SIZE / 4);
170:     }
171:     /// <summary>
172:     /// Check if FIFO is at least 75% full (at most 25% empty)
173:     /// </summary>
174:     /// <returns>true if FIFO is at least 75% full, false otherwise</returns>
175:     bool IsThreeQuartersOrMoreFull()
176:     {
177:         return ((m_readIndex - m_writeIndex + I2C_FIFO_SIZE) % I2C_FIFO_SIZE) <= (I2C_FIFO_SIZE / 4);
178:     }
179:     /// <summary>
180:     /// Flush the FIFO
181:     /// </summary>
182:     void Flush()
183:     {
184:         m_readIndex = m_writeIndex = 0;
185:         m_isFull = false;
186:     }
187: };
188:
189: /// @brief Callback for sending address
190: using SendAddressByteCallback = bool(I2CRegisters& registers, uint8 address);
191: /// @brief Callback for receiving data
192: using RecvDataByteCallback = bool(I2CRegisters& registers, uint8& data);
193: /// @brief Callback for sending data
194: using SendDataByteCallback = bool(I2CRegisters& registers, uint8 data);
195:
196: /// @brief MemoryAccess implementation for I2C stub
197: class MemoryAccessStubI2C : public MemoryAccessStubGPIO
198: {
199: private:
200:     /// @brief Storage for I2C registers
201:     I2CRegisters m_registers;
202:     /// @brief I2C master base address
203:     uintptr m_i2cMasterBaseAddress;
204:     /// @brief Receive FIFO
205:     FIFO<I2C_FIFO_SIZE> m_rxFifo;
206:     /// @brief Send FIFO
207:     FIFO<I2C_FIFO_SIZE> m_txFifo;
208:     /// @brief Pointer to send address callback
209:     SendAddressByteCallback* m_sendAddressByteCallback;
210:     /// @brief Pointer to receive data callback
211:     RecvDataByteCallback* m_recvDataByteCallback;
212:     /// @brief Pointer to send data callback
213:     SendDataByteCallback* m_sendDataByteCallback;
214:     /// @brief Number of data bytes received
215:     uint8 m_numBytesReceived;
216:     /// @brief Number of data bytes sent
217:     uint8 m_numBytesSent;
218:
219: public:
220:     MemoryAccessStubI2C();
221:     void SetBus(uint8 bus);
222:
223:     uint8 Read8(regaddr address) override;
224:     void Write8(regaddr address, uint8 data) override;
225:
226:     uint16 Read16(regaddr address) override;
227:     void Write16(regaddr address, uint16 data) override;
228:
229:     uint32 Read32(regaddr address) override;
230:     void Write32(regaddr address, uint32 data) override;
231:
232:     void SetSendAddressByteCallback(SendAddressByteCallback callback);
233:     void SetRecvDataByteCallback(RecvDataByteCallback callback);
234:     void SetSendDataByteCallback(SendDataByteCallback callback);
235:
236: private:
237:     uint32 GetRegisterOffset(regaddr address);
238:     void HandleWriteControlRegister(uint32 data);
239:     void HandleWriteStatusRegister(uint32 data);
240:     void HandleWriteFIFORegister(uint8 data);
241:     uint8 HandleReadFIFORegister();
242:     void HandleSendData();
243:     void HandleRecvData();
244:     void UpdateFIFOStatus();
245:     void CancelTransfer();
246:     void EndTransfer();
247: };
248:
249: } // namespace baremetal
```

- Line 50-86: We declare a struct `I2CRegisters` to hold the register values for the I2C device
  - Line 53-54: The member variable `ControlRegister` holds the Control Register value
  - Line 55-56: The member variable `StatusRegister` holds the Status Register value
  - Line 57-58: The member variable `DataLengthRegister` holds the DataLength Register value
  - Line 59-60: The member variable `AddressRegister` holds the Address Register value
  - Line 61-62: The member variable `FIFORegister` holds the FIFO Register value
  - Line 63-64: The member variable `ClockDividerRegister` holds the Clock Divider Register value
  - Line 65-66: The member variable `DataDelayRegister` holds the Data Delay Register value
  - Line 67-68: The member variable `ClockStretchTimeoutRegister` holds the Clock Stretch Timeout Register value
  - Line 70-85: We define the constructor, which initializes the register values to their defaults
- Line 88-89: We define `I2C_FIFO_SIZE` as the size of the receive and transmit FIFO
- Line 91-187: We declare and define the template class `FIFO` with the FIFO size as its parameter.
This class acts as the FIFO for receiving and transmitting data
  - Ling 96-97: The member variable `m_data` holds the FIFO data
  - Line 98-99: The member variable `m_readIndex` is the index of the next item to be read from the FIFO
  - Line 100-101: The member variable `m_writeIndex` is the index of the next item to be written to the FIFO
  - Line 102-103: The member variable `m_isFull` denotes whether the FIFO is full. The FIFO is implemented as a cyclic buffer, so when the read and write index are equal, this can both mean it is empty or full.
This variable distinguishes the two cases
  - Line 104-105: The member variable `align` is a fake variable to make sure the FIFO size is a multiple of 16 bytes.
If this is not the case we will end up getting alignment faults
  - Line 108-117: We implement the constructor
  - Line 118-132: We define the method `Read()` which reads an element from the FIFO.
This reads the element at the read position and increments the position, if the FIFO is not empty.
Otherwise, a dummy value is returned
  - Line 133-146: We define the method `Write()` which writes an element to the FIFO.
This write the element at the write position and increments the position, if the FIFO is not full.
Otherwise, nothing is written
  - Line 147-154: We define the method `IsEmpty()` which returns true if the FIFO is empty
  - Line 155-162: We define the method `IsFull()` which returns true if the FIFO is full
  - Line 163-170: We define the method `IsOneQuarterOrLessFull()` which returns true if the FIFO is 25% or less filled
  - Line 171-178: We define the method `IsThreeQuartersOrMoreFull()` which returns true if the FIFO is 75% or more filled
  - Line 179-186: We define the method `Flush()` which flushes the FIFO, i.e. makes it empty
- Line 189-190: We define the type `SendAddressByteCallback` as a callback function when the I2C address is written
- Line 191-192: We define the type `RecvDataByteCallback` as a callback function when data is read from the I2C device
- Line 193-194: We define the type `SendvDataByteCallback` as a callback function when data is written to the I2C device
- Line 196-247: We declare the class `MemoryAccessStubI2C` which acts as the `MemoryAccess` class for fake I2C access.
Note that it derives from `MemoryAccessStubGPIO`
  - Line 200-201: The member variable `m_registers` contains the values of the I2C device registers
  - Line 202-203: The member variable `m_i2cMasterBaseAddress` holds the register base address of the selected I2C device
  - Line 204-205: The member variable `m_rxFifo` holds receive FIFO
  - Line 206-207: The member variable `m_txFifo` holds transmit FIFO
  - Line 208-209: The member variable `m_sendAddressByteCallback` holds the callback function pointer for sending the address byte
  - Line 210-211: The member variable `m_recvDataByteCallback` holds the callback function pointer for receiving a data byte
  - Line 212-213: The member variable `m_sendDataByteCallback` holds the callback function pointer for sending a data byte
  - Line 214-215: The member variable `m_numBytesReceived` holds the number of bytes received in the current transaction
  - Line 216-217: The member variable `m_numBytesSent` holds the number of bytes sent in the current transaction
  - Line 220: We declare the constructor
  - Line 221: We declare the method `SetBus()` to set the I2C bus to use
  - Line 223-230: We override the read / write methods for the interface
  - Line 232-234: We declare methods to set the respective callback function pointers
  - Line 237: We declare the method `GetRegisterOffset()` to calculate the register offset relative to the register base address for the I2C device
  - Line 238: We declare the method `HandleWriteControlRegister()` to handle writing to the control register.
As this can change state, this has to be specifically handled
  - Line 239: We declare the method `HandleWriteStatusRegister()` to handle writing to the status register.
As this can change state, this has to be specifically handled
  - Line 240: We declare the method `HandleWriteFIFORegister()` to handle writing to the FIFO register.
This will update the FIFO and its status bits
  - Line 241: We declare the method `HandleReadFIFORegister()` to handle reading to the FIFO register.
This will update the FIFO and its status bits
  - Line 242: We declare the method `HandleSendData()` to handle receiving data from a (fake) device
  - Line 243: We declare the method `HandleRecvData()` to handle sending data to a (fake) device
  - Line 244: We declare the method `UpdateFIFOStatus()` to update the status for the FIFO in the status register
  - Line 245: We declare the method `CancelTransfer()` to cancel a transaction.
The transaction will be set to done, but with a failed ACK
  - Line 246: We declare the method `EndTransfer()` to finish a transaction.
The transaction will be set to done

### MemoryAccessStubI2C.cpp {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_MEMORYACCESSSTUBI2CCPP}

We'll implement the MemoryAccess stub for I2C.

Create file `code/libraries/baremetal/src/stubs/MemoryAccessStubI2C.cpp`

```cpp
File: code/libraries/baremetal/src/stubs/MemoryAccessStubI2C.cpp
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MemoryAccessStubI2C.cpp
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : MemoryAccessStubI2C
9: //
10: // Description : I2C register memory access stub implementation
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39:
40: #include "baremetal/stubs/MemoryAccessStubI2C.h"
41:
42: #include "baremetal/Assert.h"
43: #include "baremetal/BCMRegisters.h"
44: #include "baremetal/Format.h"
45: #include "baremetal/Logger.h"
46: #include "baremetal/String.h"
47:
48: /// @file
49: /// MemoryAccessStubI2C
50:
51: /// @brief Define log name
52: LOG_MODULE("MemoryAccessStubI2C");
53:
54: using namespace baremetal;
55:
56: /// @brief I2C bus 0 register base address
57: static regaddr I2CBaseAddress0{RPI_I2C0_BASE};
58: /// @brief I2C bus 1 register base address
59: static regaddr I2CBaseAddress1{RPI_I2C1_BASE};
60: #if BAREMETAL_RPI_TARGET == 3
61: /// @brief I2C bus 2 register base address
62: static regaddr I2CBaseAddress2{RPI_I2C2_BASE};
63: #elif BAREMETAL_RPI_TARGET == 4
64: /// @brief I2C bus 3 register base address
65: static regaddr I2CBaseAddress3{RPI_I2C3_BASE};
66: /// @brief I2C bus 4 register base address
67: static regaddr I2CBaseAddress4{RPI_I2C4_BASE};
68: /// @brief I2C bus 5 register base address
69: static regaddr I2CBaseAddress5{RPI_I2C5_BASE};
70: /// @brief I2C bus 6 register base address
71: static regaddr I2CBaseAddress6{RPI_I2C6_BASE};
72: #endif
73: /// @brief Mask to check whether an address is in the range for a specific I2C bus
74: static uintptr I2CBaseAddressMask{0xFFFFFFFFFFFFFFE0};
75:
76: /// <summary>
77: /// MemoryAccessStubI2C constructor
78: /// </summary>
79: MemoryAccessStubI2C::MemoryAccessStubI2C()
80:     : m_registers{}
81:     , m_i2cMasterBaseAddress{}
82:     , m_rxFifo{}
83:     , m_txFifo{}
84:     , m_sendAddressByteCallback{}
85:     , m_recvDataByteCallback{}
86:     , m_sendDataByteCallback{}
87:     , m_numBytesReceived{}
88:     , m_numBytesSent{}
89: {
90: }
91:
92: /// <summary>
93: /// Set I2C device bus number
94: /// </summary>
95: /// <param name="bus">I2C device bus number (0..6) depending on Raspberry Pi model</param>
96: void MemoryAccessStubI2C::SetBus(uint8 bus)
97: {
98:     switch (bus)
99:     {
100:     case 0:
101:         m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress0);
102:         break;
103:     case 1:
104:         m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress1);
105:         break;
106: #if BAREMETAL_RPI_TARGET == 3
107:     case 2:
108:         m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress2);
109:         break;
110: #elif BAREMETAL_RPI_TARGET == 4
111:     case 3:
112:         m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress3);
113:         break;
114:     case 4:
115:         m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress4);
116:         break;
117:     case 5:
118:         m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress5);
119:         break;
120:     case 6:
121:         m_i2cMasterBaseAddress = reinterpret_cast<uintptr>(I2CBaseAddress6);
122:         break;
123: #endif
124:     default:
125:         assert(false);
126:     }
127: }
128:
129: /// <summary>
130: /// Read a 8 bit value from register at address
131: /// </summary>
132: /// <param name="address">Address of register</param>
133: /// <returns>8 bit register value</returns>
134: uint8 MemoryAccessStubI2C::Read8(regaddr address)
135: {
136:     LOG_PANIC("Call to Read8 should not happen");
137:     return {};
138: }
139:
140: /// <summary>
141: /// Write a 8 bit value to register at address
142: /// </summary>
143: /// <param name="address">Address of register</param>
144: /// <param name="data">Data to write</param>
145: void MemoryAccessStubI2C::Write8(regaddr address, uint8 data)
146: {
147:     LOG_PANIC("Call to Write8 should not happen");
148: }
149:
150: /// <summary>
151: /// Read a 16 bit value from register at address
152: /// </summary>
153: /// <param name="address">Address of register</param>
154: /// <returns>16 bit register value</returns>
155: uint16 MemoryAccessStubI2C::Read16(regaddr address)
156: {
157:     LOG_PANIC("Call to Read16 should not happen");
158:     return {};
159: }
160:
161: /// <summary>
162: /// Write a 16 bit value to register at address
163: /// </summary>
164: /// <param name="address">Address of register</param>
165: /// <param name="data">Data to write</param>
166: void MemoryAccessStubI2C::Write16(regaddr address, uint16 data)
167: {
168:     LOG_PANIC("Call to Write16 should not happen");
169: }
170:
171: /// <summary>
172: /// Read a 32 bit value from register at address
173: /// </summary>
174: /// <param name="address">Address of register</param>
175: /// <returns>32 bit register value</returns>
176: uint32 MemoryAccessStubI2C::Read32(regaddr address)
177: {
178:     uintptr addr = reinterpret_cast<uintptr>(address);
179:     if ((addr >= RPI_GPIO_BASE) && (addr < RPI_GPIO_END))
180:     {
181:         return MemoryAccessStubGPIO::Read32(address);
182:     }
183:
184:     uintptr offset = GetRegisterOffset(address);
185:     uint32* registerField = reinterpret_cast<uint32*>(reinterpret_cast<uint8*>(&m_registers) + offset);
186:     LOG_DEBUG("I2C Read register %016x = %08x", offset, *registerField);
187:     switch (offset)
188:     {
189:     case RPI_I2C_C_OFFSET:
190:         {
191:             String line{"I2C Read Control Register "};
192:             if (*registerField & RPI_I2C_C_ENABLE)
193:                 line += "Enable ON  ";
194:             else
195:                 line += "Enable OFF ";
196:             if (*registerField & RPI_I2C_C_INTR_ENABLE)
197:                 line += "RX Interrupt ON  ";
198:             else
199:                 line += "RX Interrupt OFF ";
200:             if (*registerField & RPI_I2C_C_INTT_ENABLE)
201:                 line += "TX Interrupt ON  ";
202:             else
203:                 line += "TX Interrupt OFF ";
204:             if (*registerField & RPI_I2C_C_INTD_ENABLE)
205:                 line += "DONE Interrupt ON  ";
206:             else
207:                 line += "DONE Interrupt OFF ";
208:             if (*registerField & RPI_I2C_C_READ)
209:                 line += "Read ";
210:             else
211:                 line += "Write ";
212:             LOG_DEBUG(line.c_str());
213:             break;
214:         }
215:     case RPI_I2C_S_OFFSET:
216:         {
217:             String line{"I2C Read Status Register "};
218:             if (*registerField & RPI_I2C_S_CLKT)
219:                 line += "CLKT ";
220:             else
221:                 line += "     ";
222:             if (*registerField & RPI_I2C_S_ERR)
223:                 line += "NACK ";
224:             else
225:                 line += "ACK  ";
226:             if (*registerField & RPI_I2C_S_RXF)
227:                 line += "RXF ";
228:             else
229:                 line += "    ";
230:             if (*registerField & RPI_I2C_S_TXE)
231:                 line += "TXE ";
232:             else
233:                 line += "    ";
234:             if (*registerField & RPI_I2C_S_RXD)
235:                 line += "RXD ";
236:             else
237:                 line += "    ";
238:             if (*registerField & RPI_I2C_S_TXD)
239:                 line += "TXD ";
240:             else
241:                 line += "    ";
242:             if (*registerField & RPI_I2C_S_RXR)
243:                 line += "RXR ";
244:             else
245:                 line += "    ";
246:             if (*registerField & RPI_I2C_S_TXW)
247:                 line += "TXW ";
248:             else
249:                 line += "    ";
250:             if (*registerField & RPI_I2C_S_DONE)
251:                 line += "DONE ";
252:             else
253:                 line += "     ";
254:             if (*registerField & RPI_I2C_S_TA)
255:                 line += "TA ";
256:             else
257:                 line += "   ";
258:             LOG_DEBUG(line.c_str());
259:             break;
260:         }
261:     case RPI_I2C_DLEN_OFFSET:
262:         {
263:             LOG_DEBUG("I2C Get Data Length %d", *registerField);
264:             break;
265:         }
266:     case RPI_I2C_A_OFFSET:
267:         {
268:             LOG_DEBUG("I2C Get Address %02x", *registerField);
269:             break;
270:         }
271:     case RPI_I2C_FIFO_OFFSET:
272:         {
273:             LOG_DEBUG("I2C Read FIFO %02x", *registerField);
274:             *registerField = HandleReadFIFORegister();
275:             break;
276:         }
277:     case RPI_I2C_DIV_OFFSET:
278:         {
279:             LOG_DEBUG("I2C Set Clock Divider %d", *registerField);
280:             break;
281:         }
282:     case RPI_I2C_DEL_OFFSET:
283:         {
284:             if (*registerField & 0xFFFF0000)
285:             {
286:                 LOG_DEBUG("I2C Get Falling Edge Delay %d", (*registerField >> 16));
287:             }
288:             if (*registerField & 0x0000FFFF)
289:             {
290:                 LOG_DEBUG("I2C Get Rising Edge Delay %d", (*registerField & 0x0000FFFF));
291:             }
292:             break;
293:         }
294:     case RPI_I2C_CLKT_OFFSET:
295:         {
296:             LOG_DEBUG("I2C Get Clock Stretch Timeout %d", (*registerField & 0x0000FFFF));
297:             break;
298:         }
299:     default:
300:         LOG_ERROR("Invalid I2C register access for reading: offset %d", offset);
301:         break;
302:     }
303:
304:     return *registerField;
305: }
306:
307: /// <summary>
308: /// Write a 32 bit value to register at address
309: /// </summary>
310: /// <param name="address">Address of register</param>
311: /// <param name="data">Data to write</param>
312: void MemoryAccessStubI2C::Write32(regaddr address, uint32 data)
313: {
314:     uintptr addr = reinterpret_cast<uintptr>(address);
315:     if ((addr >= RPI_GPIO_BASE) && (addr < RPI_GPIO_END))
316:     {
317:         MemoryAccessStubGPIO::Write32(address, data);
318:         return;
319:     }
320:
321:     uintptr offset = GetRegisterOffset(address);
322:     uint32* registerField = reinterpret_cast<uint32*>(reinterpret_cast<uint8*>(&m_registers) + offset);
323:     LOG_DEBUG("I2C Write register %016x = %08x", offset, data);
324:     switch (offset)
325:     {
326:     case RPI_I2C_C_OFFSET:
327:         {
328:             uint32 diff = (data ^ *registerField) | 0x00B0;
329:             if (diff & RPI_I2C_C_ENABLE)
330:             {
331:                 if (data & RPI_I2C_C_ENABLE)
332:                     LOG_DEBUG("I2C Enable Controller");
333:                 else
334:                     LOG_DEBUG("I2C Disable Controller");
335:             }
336:             if (diff & RPI_I2C_C_INTR_ENABLE)
337:             {
338:                 if (data & RPI_I2C_C_INTR_ENABLE)
339:                     LOG_DEBUG("I2C Enable RX Interrupt");
340:                 else
341:                     LOG_DEBUG("I2C Disable RX Interrupt");
342:             }
343:             if (diff & RPI_I2C_C_INTT_ENABLE)
344:             {
345:                 if (data & RPI_I2C_C_INTT_ENABLE)
346:                     LOG_DEBUG("I2C Enable TX Interrupt");
347:                 else
348:                     LOG_DEBUG("I2C Disable TX Interrupt");
349:             }
350:             if (diff & RPI_I2C_C_INTD_ENABLE)
351:             {
352:                 if (data & RPI_I2C_C_INTD_ENABLE)
353:                     LOG_DEBUG("I2C Enable Done Interrupt");
354:                 else
355:                     LOG_DEBUG("I2C Disable Done Interrupt");
356:             }
357:             if (diff & RPI_I2C_C_READ)
358:             {
359:                 if (data & RPI_I2C_C_READ)
360:                     LOG_DEBUG("I2C Read Mode");
361:                 else
362:                     LOG_DEBUG("I2C Write Mode");
363:             }
364:             if (data & RPI_I2C_C_CLEAR)
365:                 LOG_DEBUG("I2C Clear FIFO");
366:             if (data & RPI_I2C_C_ST)
367:                 LOG_DEBUG("I2C Start Transfer");
368:             HandleWriteControlRegister(data);
369:             break;
370:         }
371:     case RPI_I2C_S_OFFSET:
372:         {
373:             if (data & RPI_I2C_S_CLKT)
374:                 LOG_DEBUG("I2C Reset Clock Stretch Timeout");
375:             if (data & RPI_I2C_S_ERR)
376:                 LOG_DEBUG("I2C Reset Ack Error");
377:             if (data & RPI_I2C_S_DONE)
378:                 LOG_DEBUG("I2C Reset Done");
379:             HandleWriteStatusRegister(data);
380:             break;
381:         }
382:     case RPI_I2C_DLEN_OFFSET:
383:         {
384:             LOG_DEBUG("I2C Set Data Length %d", data);
385:             *registerField = data;
386:             break;
387:         }
388:     case RPI_I2C_A_OFFSET:
389:         {
390:             LOG_DEBUG("I2C Set Address %02x", data);
391:             *registerField = data;
392:             break;
393:         }
394:     case RPI_I2C_FIFO_OFFSET:
395:         {
396:             LOG_DEBUG("I2C Write FIFO %02x", data);
397:             HandleWriteFIFORegister(data);
398:             break;
399:         }
400:     case RPI_I2C_DIV_OFFSET:
401:         {
402:             if (data != *registerField)
403:             {
404:                 LOG_DEBUG("I2C Set Clock Divider %d", data);
405:             }
406:             *registerField = data;
407:             break;
408:         }
409:     case RPI_I2C_DEL_OFFSET:
410:         {
411:             uint32 diff = data & *registerField;
412:             if (diff & 0xFFFF0000)
413:             {
414:                 LOG_DEBUG("I2C Set Falling Edge Delay %d", (data >> 16));
415:             }
416:             if (diff & 0x0000FFFF)
417:             {
418:                 LOG_DEBUG("I2C Set Rising Edge Delay %d", (data & 0x0000FFFF));
419:             }
420:             *registerField = data;
421:             break;
422:         }
423:     case RPI_I2C_CLKT_OFFSET:
424:         {
425:             uint32 diff = data & *registerField;
426:             if (diff & 0x0000FFFF)
427:             {
428:                 LOG_DEBUG("I2C Set Clock Stretch Timeout %d", (data & 0x0000FFFF));
429:             }
430:             *registerField = data;
431:             break;
432:         }
433:     default:
434:         LOG_ERROR("Invalid I2C register access for writing: offset %d", offset);
435:         break;
436:     }
437: }
438:
439: /// <summary>
440: /// Set callback function for address send
441: /// </summary>
442: /// <param name="callback">Address of callback function</param>
443: void MemoryAccessStubI2C::SetSendAddressByteCallback(SendAddressByteCallback callback)
444: {
445:     m_sendAddressByteCallback = callback;
446: }
447:
448: /// <summary>
449: /// Set callback function for data receive
450: /// </summary>
451: /// <param name="callback">Address of callback function</param>
452: void MemoryAccessStubI2C::SetRecvDataByteCallback(RecvDataByteCallback callback)
453: {
454:     m_recvDataByteCallback = callback;
455: }
456:
457: /// <summary>
458: /// Set callback function for data send
459: /// </summary>
460: /// <param name="callback">Address of callback function</param>
461: void MemoryAccessStubI2C::SetSendDataByteCallback(SendDataByteCallback callback)
462: {
463:     m_sendDataByteCallback = callback;
464: }
465:
466: /// <summary>
467: /// Determine register address offset, by checking against the different bus numbers
468: ///
469: /// If no bus matches the address, an assert if fired
470: /// </summary>
471: /// <param name="address">Address to check</param>
472: /// <returns>Offset relative to the base address for the respective bus, if one exists. Will return 0 (but assert) otherwise</returns>
473: uint32 MemoryAccessStubI2C::GetRegisterOffset(regaddr address)
474: {
475:     assert((reinterpret_cast<uintptr>(address) & I2CBaseAddressMask) == m_i2cMasterBaseAddress);
476:     return reinterpret_cast<uintptr>(address) - m_i2cMasterBaseAddress;
477: }
478:
479: /// <summary>
480: /// Handle writing to I2C Control Register
481: /// </summary>
482: /// <param name="data">Value to write to the register</param>
483: void MemoryAccessStubI2C::HandleWriteControlRegister(uint32 data)
484: {
485:     if ((data & RPI_I2C_C_CLEAR) != 0)
486:     {
487:         m_rxFifo.Flush();
488:         m_txFifo.Flush();
489:         m_numBytesReceived = 0;
490:         m_numBytesSent = 0;
491:     }
492:     m_registers.ControlRegister = data & ~(RPI_I2C_C_CLEAR | RPI_I2C_C_ST);
493:     if (((data & RPI_I2C_C_ENABLE) != 0) && ((data & RPI_I2C_C_ST) != 0))
494:     {
495:         // We started a (new) transaction
496:         m_registers.StatusRegister = m_registers.StatusRegister | RPI_I2C_S_TA;
497:         if (m_sendAddressByteCallback)
498:         {
499:             if (!(*m_sendAddressByteCallback)(m_registers, m_registers.AddressRegister))
500:                 m_registers.StatusRegister |= RPI_I2C_S_ERR;
501:         }
502:         if ((m_registers.ControlRegister & RPI_I2C_C_READ) != 0)
503:         {
504:             HandleRecvData();
505:         }
506:         else
507:         {
508:             HandleSendData();
509:         }
510:     }
511: }
512:
513: /// <summary>
514: /// Handle writing to I2C Status Register
515: /// </summary>
516: /// <param name="data">Value to write to the register</param>
517: void MemoryAccessStubI2C::HandleWriteStatusRegister(uint32 data)
518: {
519:     if (data & RPI_I2C_S_ERR)
520:     {
521:         m_registers.StatusRegister = m_registers.StatusRegister & ~RPI_I2C_S_ERR;
522:     }
523:     if (data & RPI_I2C_S_DONE)
524:     {
525:         m_registers.StatusRegister = m_registers.StatusRegister & ~(RPI_I2C_S_DONE | RPI_I2C_S_TA);
526:     }
527:     if (data & RPI_I2C_S_CLKT)
528:     {
529:         m_registers.StatusRegister = m_registers.StatusRegister & ~RPI_I2C_S_CLKT;
530:     }
531: }
532:
533: /// <summary>
534: /// Handle writing to I2C Transmit FIFO Register
535: /// </summary>
536: /// <param name="data">Value to write to the register</param>
537: void MemoryAccessStubI2C::HandleWriteFIFORegister(uint8 data)
538: {
539:     if (!m_txFifo.IsFull())
540:     {
541:         m_txFifo.Write(data);
542:     }
543:     UpdateFIFOStatus();
544:     HandleSendData();
545: }
546:
547: /// <summary>
548: /// Handle reading to I2C Receive FIFO Register
549: /// </summary>
550: /// <returns>Value read from the FIFO</returns>
551: uint8 MemoryAccessStubI2C::HandleReadFIFORegister()
552: {
553:     uint8 result{};
554:     HandleRecvData();
555:     if (!m_rxFifo.IsEmpty())
556:     {
557:         result = m_rxFifo.Read();
558:     }
559:     UpdateFIFOStatus();
560:     return result;
561: }
562:
563: /// <summary>
564: /// Handle transmitting data
565: /// </summary>
566: void MemoryAccessStubI2C::HandleSendData()
567: {
568:     if (((m_registers.StatusRegister & RPI_I2C_S_TA) != 0) && ((m_registers.ControlRegister & RPI_I2C_C_READ) == 0))
569:     {
570:         while (!m_txFifo.IsEmpty() && (m_numBytesSent < m_registers.DataLengthRegister))
571:         {
572:             auto data = m_txFifo.Read();
573:             UpdateFIFOStatus();
574:             bool sentData{};
575:             if (m_sendDataByteCallback)
576:                 sentData = (*m_sendDataByteCallback)(m_registers, data);
577:             if (sentData)
578:                 ++m_numBytesSent;
579:             else
580:             {
581:                 CancelTransfer();
582:                 break;
583:             }
584:         }
585:     }
586:     if (m_numBytesSent >= m_registers.DataLengthRegister)
587:         EndTransfer();
588: }
589:
590: /// <summary>
591: /// Handle receiving data
592: /// </summary>
593: void MemoryAccessStubI2C::HandleRecvData()
594: {
595:     if (((m_registers.ControlRegister & RPI_I2C_C_ENABLE) != 0) && ((m_registers.ControlRegister & RPI_I2C_C_READ) != 0))
596:     {
597:         while (!m_rxFifo.IsFull() && (m_numBytesReceived < m_registers.DataLengthRegister))
598:         {
599:             uint8 data{};
600:             bool receivedData{};
601:             if (m_recvDataByteCallback)
602:             {
603:                 receivedData = (*m_recvDataByteCallback)(m_registers, data);
604:             }
605:             if (receivedData)
606:             {
607:                 m_rxFifo.Write(data);
608:                 UpdateFIFOStatus();
609:                 ++m_numBytesReceived;
610:             }
611:             else
612:             {
613:                 CancelTransfer();
614:                 break;
615:             }
616:         }
617:     }
618:     if (m_numBytesReceived >= m_registers.DataLengthRegister)
619:         EndTransfer();
620: }
621:
622: /// <summary>
623: /// Update the FIFO status bits in the I2C Status Register
624: /// </summary>
625: void MemoryAccessStubI2C::UpdateFIFOStatus()
626: {
627:     if (m_txFifo.IsEmpty())
628:         m_registers.StatusRegister |= RPI_I2C_S_TXE;
629:     else
630:         m_registers.StatusRegister &= (~RPI_I2C_S_TXE);
631:     if (m_txFifo.IsFull())
632:         m_registers.StatusRegister |= RPI_I2C_S_TXD;
633:     else
634:         m_registers.StatusRegister &= (~RPI_I2C_S_TXD);
635:     if (m_txFifo.IsOneQuarterOrLessFull())
636:         m_registers.StatusRegister |= RPI_I2C_S_TXW;
637:     else
638:         m_registers.StatusRegister &= (~RPI_I2C_S_TXW);
639:     if (m_rxFifo.IsEmpty())
640:         m_registers.StatusRegister &= (~RPI_I2C_S_RXD);
641:     else
642:         m_registers.StatusRegister |= RPI_I2C_S_RXD;
643:     if (m_rxFifo.IsFull())
644:         m_registers.StatusRegister |= RPI_I2C_S_RXF;
645:     else
646:         m_registers.StatusRegister &= (~RPI_I2C_S_RXF);
647:     if (m_rxFifo.IsThreeQuartersOrMoreFull())
648:         m_registers.StatusRegister |= RPI_I2C_S_RXR;
649:     else
650:         m_registers.StatusRegister &= (~RPI_I2C_S_RXR);
651: }
652:
653: /// <summary>
654: /// Cancel a transfer, i.e. set error flag to denote NACK, and set done flag
655: /// </summary>
656: void MemoryAccessStubI2C::CancelTransfer()
657: {
658:     m_registers.StatusRegister |= (RPI_I2C_S_ERR | RPI_I2C_S_DONE);
659:     m_registers.StatusRegister &= (~RPI_I2C_S_TA);
660: }
661:
662: /// <summary>
663: /// Finalize a transfer, i.e. set done flag
664: /// </summary>
665: void MemoryAccessStubI2C::EndTransfer()
666: {
667:     m_registers.StatusRegister |= (RPI_I2C_S_DONE);
668:     m_registers.StatusRegister &= (~RPI_I2C_S_TA);
669: }
```

- Line 56-72: We define variables for the base addresses for each of the I2C buses, depending on the Raspberry Pi model.
- Line 73-74: We define the variable `I2CBaseAddressMask` to be able to check whether an adress is inside the range for a I2C bus
- Line 76-90: We implement the constructor
- Line 92-127: We implement the method `SetBus()`, which sets the base address for the selected I2C bus. If the bus number is invalid for the selected Raspberry Pi mode, an assertion is done
- Line 129-138: We implement the method `Read8()`. This results in a panic as we do not support 8 bit reads
- Line 140-148: We implement the method `Write8()`. This results in a panic as we do not support 8 bit writes
- Line 150-159: We implement the method `Read16()`. This results in a panic as we do not support 16 bit reads
- Line 161-169: We implement the method `Write16()`. This results in a panic as we do not support 16 bit writes
- Line 171-305: We implement the method `Read32()`
  - Line 178-182: We cast the pointer to a `uintptr`. If the address is in the GPIO range, we call the MemoryAccess stub for GPIO to handle the read
  - Line 184: We determine the I2C register offset from the address being read
  - Line 185: We determine the corresponding location in the register storage
  - Line 189-214: We handle reading the I2C Control Register, and log the respective bit values
  - Line 215-260: We handle reading the I2C Status Register, and log the respective bit values
  - Line 261-265: We handle reading the I2C Data Length Register, and log the value
  - Line 266-269: We handle reading the I2C Address Register, and log the value
  - Line 271-276: We handle reading the I2C FIFO Register, and log the value.
Here, we call `HandleReadFIFORegister()` to read the FIFO and handle the status
  - Line 277-281: We handle reading the I2C Clock Divider Register, and log the value
  - Line 282-293: We handle reading the I2C Delay Register, and log the value
  - Line 294-298: We handle reading the I2C Clock Stretch Timeout Register, and log the value
- Line 307-437: We implement the method `Write32()`
  - Line 314-319: We cast the pointer to a `uintptr`. If the address is in the GPIO range, we call the MemoryAccess stub for GPIO to handle the write
  - Line 321: We determine the I2C register offset from the address being read
  - Line 322: We determine the corresponding location in the register storage
  - Line 326-370: We handle writing the I2C Control Register, and log the respective bit values.
We call `HandleWriteControlRegister()` to handle writing to the Control Register
  - Line 371-381: We handle writing the I2C Status Register, and log the respective bit values.
We call `HandleWriteStatusRegister()` to handle writing to the Status Register
  - Line 382-386: We handle writing the I2C Data Length Register, and log the value
  - Line 388-393: We handle writing the I2C Address Register, and log the value
  - Line 394-399: We handle writing the I2C FIFO Register, and log the value.
Here, we call `HandleWriteFIFORegister()` to write the FIFO and handle the status
  - Line 400-408: We handle writing the I2C Clock Divider Register, and log the value
  - Line 409-422: We handle writing the I2C Delay Register, and log the value
  - Line 423-432: We handle writing the I2C Clock Stretch Timeout Register, and log the value
- Line 439-446: We implement the method `SetSendAddressByteCallback()`
- Line 448-455: We implement the method `SetRecvDataByteCallback()`
- Line 457-464: We implement the method `SetSendDataByteCallback()`
- Line 466-477: We implement the method `GetRegisterOffset()`.
This asserts that the address is in the range for the I2C registers, and then subtracts the base address for the selected I2C bus
- Line 479-511: We implement the method `HandleWriteControlRegister()`.
  - Line 485-491: We handle flushing the FIFO when the clear bit is set, and reset the number of bytes received / transmitted
  - Line 492: We set the Control Register value. We keep the FIFO clear bits and the start bit out of the value
  - Line 493-510: We handle starting a transaction.
This sets the TA bit in the Status Register, then sends out the address.
If this returns false we set the ERR bit.
We then call `HandleRecvData()` or `HandleSendData()` depending on whether this is a read or write transaction
- Line 513-531: We implement the method `HandleWriteStatusRegister()`.
  - Line 520-523: We handle resetting the ERR bit, i.e. when this bit is set when writing, we clear the ERR bit
  - Line 524-527: We handle resetting the DONE bit, i.e. when this bit is set when writing, we clear the DONE and TA bits
  - Line 528-531: We handle resetting the CLKT bit, i.e. when this bit is set when writing, we clear the CLKT bit
- Line 533-545: We implement the method `HandleWriteFIFORegister()`.
  - Line 539-542: If the FIFO is not full, we write the data
  - Line 543: We update the FIFO status bits
  - Line 544: We call `HandleSendData()` to send out any data from the FIFO
- Line 547-561: We implement the method `HandleReadFIFORegister()`.
  - Line 554: We call `HandleRecvData()` to receive any data into the FIFO
  - Line 555-558: If the FIFO is not empty, we read the data
  - Line 559: We update the FIFO status bits
- Line 563-588: We implement the method `HandleSendData()`.
  - Line 568-585: If there is a transmit transaction active, we read data from the FIFO while not empty and not all data has been sent (as set in the Data Length Register), and send this data.
If the result is true, we increment the number of bytes sent.
Otherwise, we cancel the transation
  - Line 586-587: If all data is sent, we finalize the transaction
- Line 590-620: We implement the method `HandleRecvData()`.
  - Line 595-617: If there is a receive transaction active, we receive data as long as the FIFO is not full and not all data has been received (as set in the Data Length Register).
If the receive call returns true, we write the data to the FIFO and update its status, and increment the number of bytes received.
Otherwise, we cancel the transation
  - Line 618-619: If all data is received, we finalize the transaction
- Line 622-651: We implement the method `UpdateFIFOStatus()`.
This updates the respective bits in the Status Register
- Line 653-661: We implement the method `CancelTransfer()`
- Line 662-669: We implement the method `EndTransfer()`

### Update application code {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_UPDATE_APPLICATION_CODE}

Next let's use the I2C stub and use I2CMaster with this stub.
We'll simply scan for a device at a specific address.

Update the file code/applications/demo/src/main.cpp.

```cpp
File: code/applications/demo/src/main.cpp
1: #include "baremetal/Format.h"
2: #include "baremetal/I2CMaster.h"
3: #include "baremetal/Logger.h"
4: #include "baremetal/PhysicalGPIOPin.h"
5: #include "baremetal/String.h"
6: #include "baremetal/System.h"
7: #include "baremetal/stubs/MemoryAccessStubI2C.h"
8:
9: LOG_MODULE("main");
10:
11: using namespace baremetal;
12:
13: bool WriteI2CAddress(I2CRegisters& registers, uint8 address)
14: {
15:     LOG_INFO("I2C Write address %02x", address);
16:     return false;
17: }
18:
19: bool ReadI2CData(I2CRegisters& registers, uint8& data)
20: {
21:     data = {};
22:     LOG_INFO("I2C Read data %02x", data);
23:     return false;
24: }
25:
26: bool WriteI2CData(I2CRegisters& registers, uint8 data)
27: {
28:     LOG_INFO("I2C Write data %02x", data);
29:     return false;
30: }
31:
32: int main()
33: {
34:     auto& console = GetConsole();
35:     GetLogger().SetLogLevel(LogSeverity::Debug);
36:
37:     MemoryAccessStubI2C fakeMemoryAccess;
38:
39:     I2CMaster master(fakeMemoryAccess);
40:     uint8 busIndex = 1;
41:     fakeMemoryAccess.SetSendAddressByteCallback(WriteI2CAddress);
42:     fakeMemoryAccess.SetRecvDataByteCallback(ReadI2CData);
43:     fakeMemoryAccess.SetSendDataByteCallback(WriteI2CData);
44:     fakeMemoryAccess.SetBus(busIndex);
45:
46:     if (!master.Initialize(busIndex))
47:     {
48:         LOG_ERROR("Cannot scan bus %d", busIndex);
49:     }
50:     uint8 address{ 0x20 };
51:     if (master.Scan(address))
52:     {
53:         LOG_INFO("On bus %d Address %02x there is a device", busIndex, address);
54:     }
55:     else
56:     {
57:         LOG_INFO("On bus %d Address %02x there is no device", busIndex, address);
58:     }
59:
60:     LOG_INFO("Rebooting");
61:
62:     return static_cast<int>(ReturnCode::ExitReboot);
63: }
```

- Line 13-17: We define a callback for writing the I2C address.
For now this will fail
- Line 19-24: We define a callback for reading data from a I2C device.
For now this will fail
- Line 26-30: We define a callback for writing data to a I2C device.
For now this will fail
- Line 37: We instantiate a I2C MemoryAccess stub
- Line 39: We instantiate a I2CMaster device, and inject the stub
- Line 41-43: We hook up the callbacks
- Line 44: We setup the stub for the I2C bus we're going to use
- Line 46: We initialize the I2CMaster to the same bus
- Line 51-58: We scan for address 0x20 (this is the address we'll be using for the MCP23017 later on).
If the scan is successful (the device answers), we print a success message, otherwise we print a failure message.
In the current case, this will of course fail

### Configuring, building and debugging : Use I2C stub {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_CONFIGURING_BUILDING_AND_DEBUGGING__USE_I2C_STUB}

We can now configure and build our code, and test.
Notice that the setup of the GPIO pins is logged by the stub.

```text
1: Setting up UART0
2: Info   0.00:00:00.000 Baremetal 0.0.1 started on Raspberry Pi 3 Model B (AArch64) using BCM2837 SoC (Logger:93)
3: Info   0.00:00:00.010 Starting up (System:213)
4: Info   0.00:00:00.010 Initialize bus 1, mode 0, config 0 (I2CMaster:166)
5: Debug  0.00:00:00.020 GetClockRate (RPIProperties.cpp:307)
6: Debug  0.00:00:00.030 Clock ID:   00000004 (RPIProperties.cpp:308)
7: Debug  0.00:00:00.030 Result: OK (RPIProperties.cpp:309)
8: Debug  0.00:00:00.030 Rate:       14DC9380 (RPIProperties.cpp:314)
9: Debug  0.00:00:00.040 GPIO Set Pin Pull Up/Down Mode None (MemoryAccessStubGPIO.cpp:628)
10: Debug  0.00:00:00.040 GPIO Set Pin 2 Pull Up/Down Enable Clock ON (MemoryAccessStubGPIO.cpp:644)
11: Debug  0.00:00:00.050 GPIO Set Pin 2 Pull Up/Down Enable Clock OFF (MemoryAccessStubGPIO.cpp:646)
12: Debug  0.00:00:00.050 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Input - Pin 3 mode Input - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO.cpp:211)
13: Debug  0.00:00:00.060 GPIO Set Pin 2 Mode Alt0 (MemoryAccessStubGPIO.cpp:444)
14: Debug  0.00:00:00.070 GPIO Set Pin Pull Up/Down Mode None (MemoryAccessStubGPIO.cpp:628)
15: Debug  0.00:00:00.070 GPIO Set Pin 3 Pull Up/Down Enable Clock ON (MemoryAccessStubGPIO.cpp:644)
16: Debug  0.00:00:00.080 GPIO Set Pin 3 Pull Up/Down Enable Clock OFF (MemoryAccessStubGPIO.cpp:646)
17: Debug  0.00:00:00.080 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Alt0 - Pin 3 mode Input - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO.cpp:211)
18: Debug  0.00:00:00.090 GPIO Set Pin 3 Mode Alt0 (MemoryAccessStubGPIO.cpp:444)
19: Debug  0.00:00:00.100 I2C Write register 0000000000000014 = 00000DAC (MemoryAccessStubI2C:323)
20: Debug  0.00:00:00.100 I2C Set Clock Divider 3500 (MemoryAccessStubI2C:404)
21: Info   0.00:00:00.100 Set clock 100000 (I2CMaster:207)
22: Info   0.00:00:00.110 Set up bus 1, config 0, base address 3F804000 (I2CMaster:190)
23: Debug  0.00:00:00.110 I2C Read register 0000000000000000 = 00000000 (MemoryAccessStubI2C:186)
24: Debug  0.00:00:00.110 I2C Read Control Register Enable OFF RX Interrupt OFF TX Interrupt OFF DONE Interrupt OFF Write  (MemoryAccessStubI2C:212)
25: Debug  0.00:00:00.120 I2C Write register 0000000000000000 = 00000030 (MemoryAccessStubI2C:323)
26: Debug  0.00:00:00.120 I2C Clear FIFO (MemoryAccessStubI2C:365)
27: Debug  0.00:00:00.130 I2C Write register 000000000000000C = 00000020 (MemoryAccessStubI2C:323)
28: Debug  0.00:00:00.130 I2C Set Address 20 (MemoryAccessStubI2C:390)
29: Debug  0.00:00:00.140 Write I2C Address, 20 (I2CMaster.cpp:625)
30: Debug  0.00:00:00.140 I2C Write register 0000000000000004 = 00000302 (MemoryAccessStubI2C:323)
31: Debug  0.00:00:00.140 I2C Reset Clock Stretch Timeout (MemoryAccessStubI2C:374)
32: Debug  0.00:00:00.150 I2C Reset Ack Error (MemoryAccessStubI2C:376)
33: Debug  0.00:00:00.150 I2C Reset Done (MemoryAccessStubI2C:378)
34: Debug  0.00:00:00.150 I2C Write register 0000000000000008 = 00000001 (MemoryAccessStubI2C:323)
35: Debug  0.00:00:00.160 I2C Set Data Length 1 (MemoryAccessStubI2C:384)
36: Debug  0.00:00:00.160 Write I2C Length, 00000001 (I2CMaster.cpp:635)
37: Debug  0.00:00:00.160 I2C Write register 0000000000000010 = 00000000 (MemoryAccessStubI2C:323)
38: Debug  0.00:00:00.170 I2C Write FIFO 00 (MemoryAccessStubI2C:396)
39: Debug  0.00:00:00.170 Write FIFO, data 00000000 (I2CMaster.cpp:829)
40: Debug  0.00:00:00.180 I2C Read register 0000000000000000 = 00000000 (MemoryAccessStubI2C:186)
41: Debug  0.00:00:00.180 I2C Read Control Register Enable OFF RX Interrupt OFF TX Interrupt OFF DONE Interrupt OFF Write  (MemoryAccessStubI2C:212)
42: Debug  0.00:00:00.190 I2C Write register 0000000000000000 = 00008080 (MemoryAccessStubI2C:323)
43: Debug  0.00:00:00.190 I2C Enable Controller (MemoryAccessStubI2C:332)
44: Debug  0.00:00:00.200 I2C Start Transfer (MemoryAccessStubI2C:367)
45: Info   0.00:00:00.200 I2C Write address 20 (main:15)
46: Info   0.00:00:00.200 I2C Write data 00 (main:28)
47: Debug  0.00:00:00.210 I2C Read register 0000000000000004 = 0000014E (MemoryAccessStubI2C:186)
48: Debug  0.00:00:00.210 I2C Read Status Register      NACK     TXE         RXR TXW DONE     (MemoryAccessStubI2C:258)
49: Debug  0.00:00:00.220 Write result = 1 (I2CMaster.cpp:398)
50: Debug  0.00:00:00.220 I2C Read register 0000000000000004 = 0000014E (MemoryAccessStubI2C:186)
51: Debug  0.00:00:00.220 I2C Read Status Register      NACK     TXE         RXR TXW DONE     (MemoryAccessStubI2C:258)
52: Debug  0.00:00:00.230 I2C Write register 0000000000000004 = 00000100 (MemoryAccessStubI2C:323)
53: Debug  0.00:00:00.230 I2C Reset Ack Error (MemoryAccessStubI2C:376)
54: Debug  0.00:00:00.240 I2C Write register 0000000000000004 = 00000002 (MemoryAccessStubI2C:323)
55: Debug  0.00:00:00.240 I2C Reset Done (MemoryAccessStubI2C:378)
56: Debug  0.00:00:00.250 I2C Read register 0000000000000004 = 0000004C (MemoryAccessStubI2C:186)
57: Debug  0.00:00:00.250 I2C Read Status Register      ACK      TXE         RXR TXW          (MemoryAccessStubI2C:258)
58: Info   0.00:00:00.260 On bus 1 Address 20 there is no device (main:57)
59: Info   0.00:00:00.260 Rebooting (main:60)
60: Debug  0.00:00:00.260 GPIO Set Pin Pull Up/Down Mode PullUp (MemoryAccessStubGPIO.cpp:628)
61: Debug  0.00:00:00.270 GPIO Set Pin 2 Pull Up/Down Enable Clock ON (MemoryAccessStubGPIO.cpp:644)
62: Debug  0.00:00:00.270 GPIO Set Pin 2 Pull Up/Down Enable Clock OFF (MemoryAccessStubGPIO.cpp:646)
63: Debug  0.00:00:00.280 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Alt0 - Pin 3 mode Alt0 - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO.cpp:211)
64: Debug  0.00:00:00.290 GPIO Set Pin 2 Mode Input (MemoryAccessStubGPIO.cpp:444)
65: Debug  0.00:00:00.290 GPIO Set Pin Pull Up/Down Mode PullUp (MemoryAccessStubGPIO.cpp:628)
66: Debug  0.00:00:00.300 GPIO Set Pin 3 Pull Up/Down Enable Clock ON (MemoryAccessStubGPIO.cpp:644)
67: Debug  0.00:00:00.300 GPIO Set Pin 3 Pull Up/Down Enable Clock OFF (MemoryAccessStubGPIO.cpp:646)
68: Debug  0.00:00:00.310 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Input - Pin 3 mode Alt0 - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO.cpp:211)
69: Debug  0.00:00:00.320 GPIO Set Pin 3 Mode Input (MemoryAccessStubGPIO.cpp:444)
70: Info   0.00:00:00.320 Reboot (System:144)
```

- Line 4: The I2C master is initialized for bus 1
- Line 5-8: We retrieve the core clock rate, which is used to derive the I2C clock. The value returned is 0x14DC9380 = 350 MHz in this case
- Line 9-13: The GPIO pin 2 (SCL for bus 1) is configured for mode Alt0 (alternate function 0) and pull up/down is switched off
- Line 14-18: The GPIO pin 3 (SDA for bus 1) is configured for mode Alt0 (alternate function 0) and pull up/down is switched off
- Line 19-21: The I2C clock is set to 100 KHz (the clock divider is set to 3500 = 350000000 / 100000)
- Line 22: The I2C master is now initialized for bus 1
- Line 23-26: The control register is first read, then written.
Notice the read value shows the mode is write, and on write the FIFO clear bits are set.
These bits are however not actually written to the Control Register.
Net result is that we clear the FIFO
- Line 27-29: The address (0x20) is written to the address register
- Line 30-33: The status register is written to reset the clock stretch timeout flas, the ack error flag, and the done flag
- Line 34-36: The data length register is written (1 byte to be received)
- Line 37-39: We write 0 to the FIFO as part of the `Scan()` call
- Line 40-46: The control register is written to set the enable bit, the start bit, and the read bit.
This will start the transfer for reading
  - Line 42: The actual data is written to the Control Register
  - Line 45: As a result the address byte is sent, calling the callback `WriteI2CAddress()`.
This returns false
  - Line 46: The the first data byte is written, calling the callback `WriteI2CData()`.
This returns false
- Line 47-51: The status register is read a couple of times, returning clock stretch timeout, ack error and done flags.
As you can see the NACK flag is set, as well as the DONE flag
- Line 52-53: The status register is written to reset the ERR flag
- Line 54-55: The status register is written to reset the DONE flag
- Line 58: The conclusion is there is no device at the specified address
- Line 60-64: GPIO pin 2 is set to input mode with pull up
- Line 65-69: GPIO pin 3 is set to input mode with pull up

### Update application code - The positive scenario {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_UPDATE_APPLICATION_CODE___THE_POSITIVE_SCENARIO}

Now let's change the code to give a positive result.

Update the file code/applications/demo/src/main.cpp.

```cpp
File: code/applications/demo/src/main.cpp
...
13: bool WriteI2CAddress(I2CRegisters& registers, uint8 address)
14: {
15:     LOG_INFO("I2C Write address %02x", address);
16:     return address == 0x20;
17: }
18:
19: bool ReadI2CData(I2CRegisters& registers, uint8& data)
20: {
21:     data = {};
22:     LOG_INFO("I2C Read data %02x", data);
23:     return false;
24: }
25:
26: bool WriteI2CData(I2CRegisters& registers, uint8 data)
27: {
28:     LOG_INFO("I2C Write data %02x", data);
29:     return true;
30: }
...
```

- Line 13-17: We change the callback for writing the I2C address.
This will succeed if we write to the correct I2C address
- Line 26-30: We define a callback for writing data to a I2C device.
This will now succeed

### Configuring, building and debugging - The positive scenario {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_CONFIGURING_BUILDING_AND_DEBUGGING___THE_POSITIVE_SCENARIO}

See that the result is now positive, a device is found.

```text
1: Setting up UART0
2: Info   0.00:00:00.000 Baremetal 0.0.1 started on Raspberry Pi 3 Model B (AArch64) using BCM2837 SoC (Logger:93)
3: Info   0.00:00:00.000 Starting up (System:213)
4: Info   0.00:00:00.010 Initialize bus 1, mode 0, config 0 (I2CMaster:166)
5: Debug  0.00:00:00.020 GetClockRate (RPIProperties.cpp:307)
6: Debug  0.00:00:00.030 Clock ID:   00000004 (RPIProperties.cpp:308)
7: Debug  0.00:00:00.030 Result: OK (RPIProperties.cpp:309)
8: Debug  0.00:00:00.030 Rate:       14DC9380 (RPIProperties.cpp:314)
9: Debug  0.00:00:00.030 GPIO Set Pin Pull Up/Down Mode None (MemoryAccessStubGPIO.cpp:628)
10: Debug  0.00:00:00.040 GPIO Set Pin 2 Pull Up/Down Enable Clock ON (MemoryAccessStubGPIO.cpp:644)
11: Debug  0.00:00:00.040 GPIO Set Pin 2 Pull Up/Down Enable Clock OFF (MemoryAccessStubGPIO.cpp:646)
12: Debug  0.00:00:00.050 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Input - Pin 3 mode Input - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO.cpp:211)
13: Debug  0.00:00:00.060 GPIO Set Pin 2 Mode Alt0 (MemoryAccessStubGPIO.cpp:444)
14: Debug  0.00:00:00.060 GPIO Set Pin Pull Up/Down Mode None (MemoryAccessStubGPIO.cpp:628)
15: Debug  0.00:00:00.070 GPIO Set Pin 3 Pull Up/Down Enable Clock ON (MemoryAccessStubGPIO.cpp:644)
16: Debug  0.00:00:00.070 GPIO Set Pin 3 Pull Up/Down Enable Clock OFF (MemoryAccessStubGPIO.cpp:646)
17: Debug  0.00:00:00.070 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Alt0 - Pin 3 mode Input - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO.cpp:211)
18: Debug  0.00:00:00.080 GPIO Set Pin 3 Mode Alt0 (MemoryAccessStubGPIO.cpp:444)
19: Debug  0.00:00:00.090 I2C Write register 0000000000000014 = 00000DAC (MemoryAccessStubI2C:323)
20: Debug  0.00:00:00.090 I2C Set Clock Divider 3500 (MemoryAccessStubI2C:404)
21: Info   0.00:00:00.100 Set clock 100000 (I2CMaster:207)
22: Info   0.00:00:00.100 Set up bus 1, config 0, base address 3F804000 (I2CMaster:190)
23: Debug  0.00:00:00.100 I2C Read register 0000000000000000 = 00000000 (MemoryAccessStubI2C:186)
24: Debug  0.00:00:00.110 I2C Read Control Register Enable OFF RX Interrupt OFF TX Interrupt OFF DONE Interrupt OFF Write  (MemoryAccessStubI2C:212)
25: Debug  0.00:00:00.110 I2C Write register 0000000000000000 = 00000030 (MemoryAccessStubI2C:323)
26: Debug  0.00:00:00.120 I2C Clear FIFO (MemoryAccessStubI2C:365)
27: Debug  0.00:00:00.120 I2C Write register 000000000000000C = 00000020 (MemoryAccessStubI2C:323)
28: Debug  0.00:00:00.120 I2C Set Address 20 (MemoryAccessStubI2C:390)
29: Debug  0.00:00:00.130 Write I2C Address, 20 (I2CMaster.cpp:625)
30: Debug  0.00:00:00.130 I2C Write register 0000000000000004 = 00000302 (MemoryAccessStubI2C:323)
31: Debug  0.00:00:00.130 I2C Reset Clock Stretch Timeout (MemoryAccessStubI2C:374)
32: Debug  0.00:00:00.140 I2C Reset Ack Error (MemoryAccessStubI2C:376)
33: Debug  0.00:00:00.140 I2C Reset Done (MemoryAccessStubI2C:378)
34: Debug  0.00:00:00.140 I2C Write register 0000000000000008 = 00000001 (MemoryAccessStubI2C:323)
35: Debug  0.00:00:00.150 I2C Set Data Length 1 (MemoryAccessStubI2C:384)
36: Debug  0.00:00:00.150 Write I2C Length, 00000001 (I2CMaster.cpp:635)
37: Debug  0.00:00:00.150 I2C Write register 0000000000000010 = 00000000 (MemoryAccessStubI2C:323)
38: Debug  0.00:00:00.160 I2C Write FIFO 00 (MemoryAccessStubI2C:396)
39: Debug  0.00:00:00.160 Write FIFO, data 00000000 (I2CMaster.cpp:829)
40: Debug  0.00:00:00.170 I2C Read register 0000000000000000 = 00000000 (MemoryAccessStubI2C:186)
41: Debug  0.00:00:00.170 I2C Read Control Register Enable OFF RX Interrupt OFF TX Interrupt OFF DONE Interrupt OFF Write  (MemoryAccessStubI2C:212)
42: Debug  0.00:00:00.180 I2C Write register 0000000000000000 = 00008080 (MemoryAccessStubI2C:323)
43: Debug  0.00:00:00.180 I2C Enable Controller (MemoryAccessStubI2C:332)
44: Debug  0.00:00:00.190 I2C Start Transfer (MemoryAccessStubI2C:367)
45: Info   0.00:00:00.190 I2C Write address 20 (main:15)
46: Info   0.00:00:00.190 I2C Write data 00 (main:28)
47: Debug  0.00:00:00.190 I2C Read register 0000000000000004 = 0000004E (MemoryAccessStubI2C:186)
48: Debug  0.00:00:00.200 I2C Read Status Register      ACK      TXE         RXR TXW DONE     (MemoryAccessStubI2C:258)
49: Debug  0.00:00:00.200 Write result = 1 (I2CMaster.cpp:398)
50: Debug  0.00:00:00.200 I2C Read register 0000000000000004 = 0000004E (MemoryAccessStubI2C:186)
51: Debug  0.00:00:00.210 I2C Read Status Register      ACK      TXE         RXR TXW DONE     (MemoryAccessStubI2C:258)
52: Debug  0.00:00:00.210 I2C Write register 0000000000000004 = 00000002 (MemoryAccessStubI2C:323)
53: Debug  0.00:00:00.220 I2C Reset Done (MemoryAccessStubI2C:378)
54: Debug  0.00:00:00.220 I2C Read register 0000000000000004 = 0000004C (MemoryAccessStubI2C:186)
55: Debug  0.00:00:00.220 I2C Read Status Register      ACK      TXE         RXR TXW          (MemoryAccessStubI2C:258)
56: Info   0.00:00:00.230 On bus 1 Address 20 there is a device (main:53)
57: Info   0.00:00:00.230 Rebooting (main:60)
58: Debug  0.00:00:00.240 GPIO Set Pin Pull Up/Down Mode PullUp (MemoryAccessStubGPIO.cpp:628)
59: Debug  0.00:00:00.240 GPIO Set Pin 2 Pull Up/Down Enable Clock ON (MemoryAccessStubGPIO.cpp:644)
60: Debug  0.00:00:00.240 GPIO Set Pin 2 Pull Up/Down Enable Clock OFF (MemoryAccessStubGPIO.cpp:646)
61: Debug  0.00:00:00.250 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Alt0 - Pin 3 mode Alt0 - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO.cpp:211)
62: Debug  0.00:00:00.260 GPIO Set Pin 2 Mode Input (MemoryAccessStubGPIO.cpp:444)
63: Debug  0.00:00:00.260 GPIO Set Pin Pull Up/Down Mode PullUp (MemoryAccessStubGPIO.cpp:628)
64: Debug  0.00:00:00.270 GPIO Set Pin 3 Pull Up/Down Enable Clock ON (MemoryAccessStubGPIO.cpp:644)
65: Debug  0.00:00:00.270 GPIO Set Pin 3 Pull Up/Down Enable Clock OFF (MemoryAccessStubGPIO.cpp:646)
66: Debug  0.00:00:00.280 GPIO Read Pin Mode  - Pin 0 mode Input - Pin 1 mode Input - Pin 2 mode Input - Pin 3 mode Alt0 - Pin 4 mode Input - Pin 5 mode Input - Pin 6 mode Input - Pin 7 mode Input - Pin 8 mode Input - Pin 9 mode Input (MemoryAccessStubGPIO.cpp:211)
67: Debug  0.00:00:00.290 GPIO Set Pin 3 Mode Input (MemoryAccessStubGPIO.cpp:444)
68: Info   0.00:00:00.290 Reboot (System:144)
```

- Line 42: The write transaction is started
- Line 45: The address is written
- Line 46: A byte is being written to the device
- Line 47-51: The Status Register is read multiple times again, the DONE bit is set, but the ERR bit is not
- Line 52-53: The DONE bit is reset
- Line 56: The conclusion is that there is a device at the address specified

### Update application code - less tracing {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_UPDATE_APPLICATION_CODE___LESS_TRACING}

Let's get rid of the large amount of tracing in the GPIO and I2C stubs.
We'll set the trace / log level to `Info`.

```cpp
File: code/applications/demo/src/main.cpp
32: int main()
33: {
34:     auto& console = GetConsole();
35:     GetLogger().SetLogLevel(LogSeverity::Info);
```

### Configuring, building and debugging - Less tracing {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_CONFIGURING_BUILDING_AND_DEBUGGING___LESS_TRACING}

We can see that the result is now a lot cleaner.

```text
Setting up UART0
Info   0.00:00:00.000 Baremetal 0.0.1 started on Raspberry Pi 3 Model B (AArch64) using BCM2837 SoC (Logger:93)
Info   0.00:00:00.000 Starting up (System:213)
Info   0.00:00:00.010 Initialize bus 1, mode 0, config 0 (I2CMaster:166)
Info   0.00:00:00.020 Set clock 100000 (I2CMaster:207)
Info   0.00:00:00.030 Set up bus 1, config 0, base address 3F804000 (I2CMaster:190)
Info   0.00:00:00.030 I2C Write address 20 (main:15)
Info   0.00:00:00.040 I2C Write data 00 (main:28)
Info   0.00:00:00.040 On bus 1 Address 20 there is a device (main:53)
Info   0.00:00:00.040 Rebooting (main:60)
Info   0.00:00:00.050 Reboot (System:144)
```

### Update application code - actual hardware {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_UPDATE_APPLICATION_CODE___ACTUAL_HARDWARE}

Now let's use actual hardware to do the same thing. I hooked up the hardware as specified in [Actual hardware - MCP23017](#TUTORIAL_22_I2C_ACTUAL_HARDWARE___MCP23017)
We we now simply use the default MemoryAccess instance, which will access the actual hardware.

Update the file code/applications/demo/src/main.cpp.

```cpp
File: code/applications/demo/src/main.cpp
1: #include "baremetal/Format.h"
2: #include "baremetal/I2CMaster.h"
3: #include "baremetal/Logger.h"
4: #include "baremetal/PhysicalGPIOPin.h"
5: #include "baremetal/String.h"
6: #include "baremetal/System.h"
7: #include "baremetal/Timer.h"
8:
9: LOG_MODULE("main");
10:
11: using namespace baremetal;
12:
13: int main()
14: {
15:     GetLogger().SetLogLevel(LogSeverity::Debug);
16:
17:     uint8 busIndex = 1;
18:     uint8 address{ 0x20 };
19:     I2CMaster master;
20:
21:     if (!master.Initialize(busIndex))
22:     {
23:         LOG_ERROR("Cannot scan bus %d", busIndex);
24:     }
25:
26:     if (master.Scan(address))
27:     {
28:         LOG_INFO("On bus %d Address %02x there is a device", busIndex, address);
29:     }
30:     else
31:     {
32:         LOG_INFO("On bus %d Address %02x there is no device", busIndex, address);
33:     }
34:
35:     LOG_INFO("Rebooting");
36:
37:     return static_cast<int>(ReturnCode::ExitReboot);
38: }
```

- Line 19: We instantiate a I2CMaster device
- Line 21: We initialize the I2CMaster to the I2C bus
- Line 26-33: We scan for address 0x20.
If the scan is successful (the device answers), we print a success message, otherwise we print a failure message.
This should succeed when we have actual hardware connected.

### Configuring, building and debugging - actual hardware {#TUTORIAL_22_I2C_FAKING_IT___STEP_1_CONFIGURING_BUILDING_AND_DEBUGGING___ACTUAL_HARDWARE}

You'll notice that the amount of tracing is a lot less, as we're not using the stub.
The result however is the same, the device is found.

```text
1: Setting up UART0
2: Info   0.00:00:00.030 Baremetal 0.0.1 started on Raspberry Pi 4 Model B (AArch64) using BCM2711 SoC (Logger:93)
3: Info   0.00:00:00.050 Starting up (System:213)
4: Info   0.00:00:00.070 Initialize bus 1, mode 0, config 0 (I2CMaster:166)
5: Debug  0.00:00:00.090 GetClockRate (RPIProperties.cpp:307)
6: Debug  0.00:00:00.110 Clock ID:   00000004 (RPIProperties.cpp:308)
7: Debug  0.00:00:00.130 Result: OK (RPIProperties.cpp:309)
8: Debug  0.00:00:00.150 Rate:       0FEEACA0 (RPIProperties.cpp:314)
9: Info   0.00:00:00.180 Set clock 100000 (I2CMaster:207)
10: Info   0.00:00:00.190 Set up bus 1, config 0, base address FE804000 (I2CMaster:190)
11: Debug  0.00:00:00.210 Write I2C Address, 20 (I2CMaster.cpp:625)
12: Debug  0.00:00:00.230 Write I2C Length, 00000001 (I2CMaster.cpp:635)
13: Debug  0.00:00:00.250 Write FIFO, data 00000000 (I2CMaster.cpp:829)
14: Debug  0.00:00:00.270 Write result = 1 (I2CMaster.cpp:398)
15: Info   0.00:00:00.280 On bus 1 Address 20 there is a device (main:28)
16: Info   0.00:00:00.310 Rebooting (main:35)
17: Info   0.00:00:00.320 Reboot (System:144)
```

- Line 4: The I2C master is initialized to bus 1
- Line 6-8: The core clock rate is retrieved
- Line 9: The clock rate is set to 100KHz
- Line 10: The I2C master is initialized, the base address is the address for bus 1
- Line 11: The Address Register is set to 0x20
- Line 12: The Data Length Register is set to 1
- Line 13: The FIFO Register is written
- Line 14: The write result is set to 1
- Line 15: The conclusion is there is a device at address 0x20

## Using MCP23017 - Step 2 {#TUTORIAL_22_I2C_USING_MCP23017___STEP_2}

Now let's start using the I2C Expander MCP 23017.

### MCP23017.h {#TUTORIAL_22_I2C_USING_MCP23017___STEP_2_MCP23017H}

We'll first declare the class for the MCP 23017 device.
This will be placed in the device library.

Create file `code/libraries/device/include/device/i2c/MCP23017.h`

```cpp
File: code/libraries/device/include/device/i2c/MCP23017.h
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MCP23017.h
5: //
6: // Namespace   : device
7: //
8: // Class       : MCP23017
9: //
10: // Description : I2C Master functionality
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39:
40: #pragma once
41:
42: #include "baremetal/I2CMaster.h"
43:
44: /// @file
45: /// MCP 23017 I2C expander support declaration
46:
47: namespace device {
48:
49: /// @brief Select register bank for MCP23017.
50: /// MCP23017 has two register banks, which differ in the relative register numbers
51: #define BANK 0
52:
53: #if BANK == 0
54:
55: /// @brief MCP23017 registers when BANK = 0
56: enum MCP23017RegisterIndex
57: {
58:     /// @brief I/O Direction Register Port A
59:     IODIRA = 0,
60:     /// @brief I/O Direction Register Port B
61:     IODIRB = 1,
62:     /// @brief Input Polarity Register Port A
63:     IPOLA = 2,
64:     /// @brief Input Polarity Register Port B
65:     IPOLB = 3,
66:     /// @brief GPIO Interrupt Enable Register Port A
67:     GPINTENA = 4,
68:     /// @brief GPIO Interrupt Enable Register Port B
69:     GPINTENB = 5,
70:     /// @brief Default Compare Register Port A
71:     DEFVALA = 6,
72:     /// @brief Default Compare Register Port B
73:     DEFVALB = 7,
74:     /// @brief Interrupt Control Register Port A
75:     INTCONA = 8,
76:     /// @brief Interrupt Control Register Port B
77:     INTCONB = 9,
78:     /// @brief I/O Control Register Port A
79:     IOCONA = 10,
80:     /// @brief I/O Control Register Port B
81:     IOCONB = 11,
82:     /// @brief GPIO Pull-up Resistor Configuration Register Port A
83:     GPPUA = 12,
84:     /// @brief GPIO Pull-up Resistor Configuration Register Port B
85:     GPPUB = 13,
86:     /// @brief Interrupt Flag Register Port A
87:     INTFA = 14,
88:     /// @brief Interrupt Flag Register Port B
89:     INTFB = 15,
90:     /// @brief Interrupt Captured Register Port A
91:     INTCAPA = 16,
92:     /// @brief Interrupt Captured Register Port B
93:     INTCAPB = 17,
94:     /// @brief GPIO Port Register Port A
95:     GPIOA = 18,
96:     /// @brief GPIO Port Register Port b
97:     GPIOB = 19,
98:     /// @brief Output Latch Register Port A
99:     OLATA = 20,
100:     /// @brief Output Latch Register Port B
101:     OLATB = 21,
102: };
103:
104: #else
105:
106: /// @brief MCP23017 registers when BANK = 1
107: enum MCP23017RegisterIndex
108: {
109:     /// @brief I/O Direction Register Port A
110:     IODIRA = 0,
111:     /// @brief I/O Direction Register Port B
112:     IODIRB = 16,
113:     /// @brief Input Polarity Register Port A
114:     IPOLA = 1,
115:     /// @brief Input Polarity Register Port B
116:     IPOLB = 17,
117:     /// @brief GPIO Interrupt Enable Register Port A
118:     GPINTENA = 2,
119:     /// @brief GPIO Interrupt Enable Register Port B
120:     GPINTENB = 18,
121:     /// @brief Default Compare Register Port A
122:     DEFVALA = 3,
123:     /// @brief Default Compare Register Port B
124:     DEFVALB = 19,
125:     /// @brief Interrupt Control Register Port A
126:     INTCONA = 4,
127:     /// @brief Interrupt Control Register Port B
128:     INTCONB = 20,
129:     /// @brief I/O Control Register Port A
130:     IOCONA = 5,
131:     /// @brief I/O Control Register Port B
132:     IOCONB = 21,
133:     /// @brief GPIO Pull-up Resistor Configuration Register Port A
134:     GPPUA = 6,
135:     /// @brief GPIO Pull-up Resistor Configuration Register Port B
136:     GPPUB = 22,
137:     /// @brief Interrupt Flag Register Port A
138:     INTFA = 7,
139:     /// @brief Interrupt Flag Register Port B
140:     INTFB = 23,
141:     /// @brief Interrupt Captured Register Port A
142:     INTCAPA = 8,
143:     /// @brief Interrupt Captured Register Port B
144:     INTCAPB = 24,
145:     /// @brief GPIO Port Register Port A
146:     GPIOA = 9,
147:     /// @brief GPIO Port Register Port b
148:     GPIOB = 25,
149:     /// @brief Output Latch Register Port A
150:     OLATA = 10,
151:     /// @brief Output Latch Register Port B
152:     OLATB = 26,
153: };
154:
155: #endif
156:
157: /// @brief IO Configuration Register Bank 0 selection
158: #define IOCON_BANK0  BIT0(7)
159: /// @brief IO Configuration Register Bank 1 selection
160: #define IOCON_BANK1  BIT1(7)
161: /// @brief IO Configuration Register Interrupt A/B mirroring
162: #define IOCON_MIRROR BIT1(6)
163: /// @brief IO Configuration Register sequential operation (automatic register index increment, subsequent write will be to next register)
164: #define IOCON_SEQOP  BIT1(5)
165: /// @brief IO Configuration Register SDA slew rate
166: #define IOCON_DISSLW BIT1(4)
167: /// @brief IO Configuration Register Hardware Address Enable (for MCP23S017 only)
168: #define IOCON_HAEN   BIT1(3)
169: /// @brief IO Configuration Register Open Drain Interrupt pin
170: #define IOCON_ODR    BIT1(2)
171: /// @brief IO Configuration Register Interrupt polarity
172: #define IOCON_INTPOL BIT1(1)
173:
174: /// @brief MCP23017 pin direction
175: enum class MCP23017PinDirection
176: {
177:     /// @brief Input pin
178:     In,
179:     /// @brief Output pin
180:     Out,
181: };
182:
183: /// @brief MCP23017 pin index
184: enum class MCP23017Pin
185: {
186:     /// @brief Port A pin 0
187:     PinA0,
188:     /// @brief Port A pin 1
189:     PinA1,
190:     /// @brief Port A pin 2
191:     PinA2,
192:     /// @brief Port A pin 3
193:     PinA3,
194:     /// @brief Port A pin 4
195:     PinA4,
196:     /// @brief Port A pin 5
197:     PinA5,
198:     /// @brief Port A pin 6
199:     PinA6,
200:     /// @brief Port A pin 7
201:     PinA7,
202:     /// @brief Port B pin 0
203:     PinB0,
204:     /// @brief Port B pin 1
205:     PinB1,
206:     /// @brief Port B pin 2
207:     PinB2,
208:     /// @brief Port B pin 3
209:     PinB3,
210:     /// @brief Port B pin 4
211:     PinB4,
212:     /// @brief Port B pin 5
213:     PinB5,
214:     /// @brief Port B pin 6
215:     PinB6,
216:     /// @brief Port B pin 7
217:     PinB7,
218: };
219:
220: /// <summary>
221: /// Driver for MCP23017 I2C expander device
222: ///
223: /// This device is normally on I2C address 20-27 depending on how its A0-A2 pins are connected.
224: /// The device support two 8 bit ports name port A and B.
225: /// Each pin can be either an input or output.
226: /// </summary>
227: class MCP23017
228: {
229: private:
230:     /// @brief I2C base device
231:     baremetal::I2CMaster m_device;
232:     /// @brief I2C device address
233:     uint8 m_address;
234:
235: public:
236:     MCP23017(baremetal::IMemoryAccess& memoryAccess = baremetal::GetMemoryAccess());
237:     ~MCP23017();
238:
239:     bool Initialize(uint8 bus, uint8 address);
240:
241:     uint8 ReadRegister(MCP23017RegisterIndex registerAddress);
242:     void WriteRegister(MCP23017RegisterIndex registerAddress, uint8 byte);
243:     void GetPinDirection(MCP23017Pin pinNumber, MCP23017PinDirection& direction);
244:     void SetPinDirection(MCP23017Pin pinNumber, const MCP23017PinDirection& direction);
245:     bool GetPinValue(MCP23017Pin pinNumber);
246:     void SetPinValue(MCP23017Pin pinNumber, bool on);
247:     void SetPortADirections(const MCP23017PinDirection& direction);
248:     uint8 GetPortAValue();
249:     void SetPortAValue(uint8 data);
250:     void SetPortBDirections(const MCP23017PinDirection& direction);
251:     uint8 GetPortBValue();
252:     void SetPortBValue(uint8 data);
253: };
254:
255: } // namespace device
```

- Line 51: We add a definition `BANK` which determines how to address registers in the MCP23017.
The default is bank 0, but it is possible to switch to bank 1 for a different register order.
We will add the definitions for both, but not support bank 1 for now.
Refer to [MCP23017/MCP23S17 - 16-Bit I/O Expander with Serial Interface](pdf/mcp23017.pdf) for more information
- Line 55-102: We declare the enum `MCP23017RegisterIndex` which holds all register indexes for the MCP23017 registers for bank 0
- Line 106-153: We declare the enum `MCP23017RegisterIndex` which holds all register indexes for the MCP23017 registers for bank 1
- Line 157-172: We add definitions for the bits in the IOCON registers.
Notice that there are bit values named `IOCON_BANK0` and `IOCON_BANK1` which can be used to select the register bank
- Line 174-181: We add a enum `MCP23017PinDirection` to define the direction of GPIO pins on the MCP23017
- Line 183-218: We add a enum `MCP23017Pin` to define the index of GPIO pins on the MCP23017
- Line 220-253: We declare the class `MCP23017`
  - Line 230-231: The member variable `m_device` holds the I2CMaster for the device
  - Line 232-233: The member variable `m_address` hold the I2C address for the device
  - Line 236: We declare the constructor
  - Line 237: We declare the destructor
  - Line 239: We declare the method `Initialize()` to initialize the device.
It receives a I2C bus index as well as and I2C address
  - Line 241: We declare a method `ReadRegister()` to read from a register on the device
  - Line 242: We declare a method `WriteRegister()` to write to a register on the device
  - Line 243: We declare a method `GetPinDirection()` to get the direction for a GPIO pin
  - Line 244: We declare a method `SetPinDirection()` to set the direction for a GPIO pin
  - Line 245: We declare a method `GetPinValue()` to get the value for a GPIO pin
  - Line 246: We declare a method `SetPinValue()` to set the value for a GPIO pin
  - Line 247: We declare a method `SetPortADirections()` to set the direction for all GPIO pins on port A
  - Line 248: We declare a method `GetPortAValue()` to get the value for all GPIO pins on port A.
Bit 0 is pin 0 on port A, Bit 7 is pin 7 on port A
  - Line 249: We declare a method `SetPortAValue()` to set the value for all GPIO pins on port A.
Bit 0 is pin 0 on port A, Bit 7 is pin 7 on port A
  - Line 250: We declare a method `SetPortBDirections()` to set the direction for all GPIO pins on port B
  - Line 251: We declare a method `GetPortBValue()` to get the value for all GPIO pins on port B.
Bit 0 is pin 0 on port B, Bit 7 is pin 7 on port B
  - Line 252: We declare a method `SetPortBValue()` to set the value for all GPIO pins on port B.
Bit 0 is pin 0 on port B, Bit 7 is pin 7 on port B

### MCP23017.cpp {#TUTORIAL_22_I2C_USING_MCP23017___STEP_2_MCP23017CPP}

We'll implement the MCP23017 device.

Create file `code/libraries/device/src/i2c/MCP23017.cpp`

```cpp
File: code/libraries/device/src/i2c/MCP23017.cpp
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MCP23017.cpp
5: //
6: // Namespace   : device
7: //
8: // Class       : MCP23017
9: //
10: // Description : I2C Master functionality
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39:
40: #include "device/i2c/MCP23017.h"
41:
42: #include "baremetal/Logger.h"
43:
44: using namespace device;
45: using namespace baremetal;
46:
47: /// @file
48: /// MCP 23017 I2C expander support declaration
49:
50: /// @brief Define log name
51: LOG_MODULE("MCP23017");
52:
53: /// <summary>
54: /// Constructor for MCP23017 class
55: /// </summary>
56: /// <param name="memoryAccess">MemoryAccess instance to be used for register access</param>
57: MCP23017::MCP23017(baremetal::IMemoryAccess& memoryAccess /*= baremetal::GetMemoryAccess()*/)
58:     : m_device{memoryAccess}
59: {
60: }
61:
62: /// <summary>
63: /// Destructor for MCP23017 class
64: /// </summary>
65: MCP23017::~MCP23017()
66: {
67:     SetPortADirections(MCP23017PinDirection::In);
68:     SetPortBDirections(MCP23017PinDirection::In);
69: }
70:
71: /// <summary>
72: /// Initialize the MCP23017 I2C expander
73: /// </summary>
74: /// <param name="bus">I2C bus index</param>
75: /// <param name="address">I2C slave address</param>
76: /// <returns>True on success, false otherwise</returns>
77: bool MCP23017::Initialize(uint8 bus, uint8 address)
78: {
79:     LOG_INFO("Initialize %02x", address);
80:     m_address = address;
81:     if (!m_device.Initialize(bus, I2CClockMode::Normal, 0))
82:         return false;
83:
84:     WriteRegister(IOCONA, IOCON_BANK0 | IOCON_SEQOP | IOCON_HAEN | IOCON_ODR);
85:     return true;
86: }
87:
88: /// <summary>
89: /// Read from the specified MCP23017 register
90: /// </summary>
91: /// <param name="registerAddress">Register index</param>
92: /// <returns>Value read</returns>
93: uint8 MCP23017::ReadRegister(MCP23017RegisterIndex registerAddress)
94: {
95:     uint8 address = static_cast<uint8>(registerAddress);
96:     uint8 data{};
97:     auto bytesTransferred = m_device.WriteReadRepeatedStart(m_address, &address, 1, &data, 1);
98:     LOG_DEBUG("Read bytes from I2C %02x Register %02x: %02x, %d bytes transferred", m_address, address, data, bytesTransferred);
99:     return data;
100: }
101:
102: /// <summary>
103: /// Write to the specified MCP23017 register
104: /// </summary>
105: /// <param name="registerAddress">Register index</param>
106: /// <param name="byte">Value to write</param>
107: void MCP23017::WriteRegister(MCP23017RegisterIndex registerAddress, uint8 byte)
108: {
109:     const size_t BufferSize{2};
110:     uint8 buffer[BufferSize];
111:     buffer[0] = static_cast<uint8>(registerAddress);
112:     buffer[1] = byte;
113:     auto bytesWritten = m_device.Write(m_address, buffer, BufferSize);
114:
115:     LOG_DEBUG("Write bytes to I2C %02x Register %02x: %02x, %d bytes written", m_address, buffer[0], buffer[1], bytesWritten);
116: }
117:
118: /// <summary>
119: /// Get the I/O pin direction for the specified pin on the MCP23017
120: /// </summary>
121: /// <param name="pinNumber">Pin index (0-7 on Port A, 8-15 on Port B)</param>
122: /// <param name="direction">Holds pin direction on return</param>
123: void MCP23017::GetPinDirection(MCP23017Pin pinNumber, MCP23017PinDirection& direction)
124: {
125:     MCP23017RegisterIndex registerAddress = (pinNumber < MCP23017Pin::PinB0) ? IODIRA : IODIRB;
126:     uint8 data = ReadRegister(registerAddress);
127:     uint8 pinShift = static_cast<uint8>(pinNumber) % 8;
128:     direction = (data & (1 << pinShift)) ? MCP23017PinDirection::In : MCP23017PinDirection::In;
129: }
130:
131: /// <summary>
132: /// Set the I/O pin direction for the specified pin on the MCP23017
133: /// </summary>
134: /// <param name="pinNumber">Pin index (0-7 on Port A, 8-15 on Port B)</param>
135: /// <param name="direction">Pin direction to set</param>
136: void MCP23017::SetPinDirection(MCP23017Pin pinNumber, const MCP23017PinDirection& direction)
137: {
138:     MCP23017RegisterIndex registerAddress = (pinNumber < MCP23017Pin::PinB0) ? IODIRA : IODIRB;
139:     uint8 data = ReadRegister(registerAddress);
140:     uint8 pinShift = static_cast<uint8>(pinNumber) % 8;
141:     uint8 mask = 1 << pinShift;
142:     uint8 pinData = (direction == MCP23017PinDirection::In) ? mask : 0;
143:     WriteRegister(registerAddress, (data & ~mask) | pinData);
144: }
145:
146: /// <summary>
147: /// Get the value of an input pin on the MCP23017
148: /// </summary>
149: /// <param name="pinNumber">Pin index (0-7 on Port A, 8-15 on Port B)</param>
150: /// <returns>Requested pin value</returns>
151: bool MCP23017::GetPinValue(MCP23017Pin pinNumber)
152: {
153:     MCP23017RegisterIndex registerAddress = (pinNumber < MCP23017Pin::PinB0) ? GPIOA : GPIOB;
154:     uint8 data = ReadRegister(registerAddress);
155:     uint8 pinShift = static_cast<uint8>(pinNumber) % 8;
156:     return (data & (1 << pinShift));
157: }
158:
159: /// <summary>
160: /// Set the value of an output pin on the MCP23017
161: /// </summary>
162: /// <param name="pinNumber">Pin index (0-7 on Port A, 8-15 on Port B)</param>
163: /// <param name="on">Value for output pin</param>
164: void MCP23017::SetPinValue(MCP23017Pin pinNumber, bool on)
165: {
166:     MCP23017RegisterIndex registerAddress = (pinNumber < MCP23017Pin::PinB0) ? GPIOA : GPIOB;
167:     uint8 data = ReadRegister(registerAddress);
168:     uint8 pinShift = static_cast<uint8>(pinNumber) % 8;
169:     uint8 mask = 1 << pinShift;
170:     uint8 pinData = on ? mask : 0;
171:     WriteRegister(registerAddress, (data & ~mask) | pinData);
172: }
173:
174: /// <summary>
175: /// Set I/O pin directions for all pin on Port A
176: /// </summary>
177: /// <param name="direction">Direction for pins</param>
178: void MCP23017::SetPortADirections(const MCP23017PinDirection& direction)
179: {
180:     WriteRegister(GPPUA, 0x00);
181:     WriteRegister(IODIRA, direction == MCP23017PinDirection::In ? 0xFF : 0x00);
182: }
183:
184: /// <summary>
185: /// Get value for all pins on Port A.
186: /// Bit 0 is the value for pin 0, etc.
187: /// </summary>
188: /// <returns></returns>
189: uint8 MCP23017::GetPortAValue()
190: {
191:     return ReadRegister(GPIOA);
192: }
193:
194: /// <summary>
195: /// Set value for all pins on Port A
196: /// </summary>
197: /// <param name="data">Value for pins. Bit 0 is the value for pin 0, etc.</param>
198: void MCP23017::SetPortAValue(uint8 data)
199: {
200:     WriteRegister(GPIOA, data);
201: }
202:
203: /// <summary>
204: /// Set I/O pin directions for all pin on Port B
205: /// </summary>
206: /// <param name="direction">Direction for pins</param>
207: void MCP23017::SetPortBDirections(const MCP23017PinDirection& direction)
208: {
209:     WriteRegister(GPPUB, 0x00);
210:     WriteRegister(IODIRB, direction == MCP23017PinDirection::In ? 0xFF : 0x00);
211: }
212:
213: /// <summary>
214: /// Get value for all pins on Port B.
215: /// Bit 0 is the value for pin 0, etc.
216: /// </summary>
217: /// <returns></returns>
218: uint8 MCP23017::GetPortBValue()
219: {
220:     return ReadRegister(GPIOB);
221: }
222:
223: /// <summary>
224: /// Set value for all pins on Port B
225: /// </summary>
226: /// <param name="data">Value for pins. Bit 0 is the value for pin 0, etc.</param>
227: void MCP23017::SetPortBValue(uint8 data)
228: {
229:     WriteRegister(GPIOB, data);
230: }
```

- Line 53-60: We implement the constructor
- Line 62-69: We implement the destructor.
This calls `SetPortADirections()`  and `SetPortBDirections()` to set the GPIO pins on the MCP23017 to input
- Line 71-86: We implement the `Initialize()` method.
The only thing worthwhile mentioning is that we set the IOCON register value with a default
- Line 88-100: We implement the `ReadRegister()` method.
This is implemented as a write/read transaction, as the register index needs to be sent before we can read it
- Line 102-116: We implement the `WriteRegister()` method.
Here we add the register index together with the byte to be written into an array that is then sent
- Line 118-129: We implement the `GetPinDirection()` method
  - Line 125: We determine the register to read from depending on the pin index
  - Line 126: We read the register value
  - Line 127-128: We extract the pin direction for the requested pin
- Line 131-144: We implement the `SetPinDirection()` method
  - Line 138: We determine the register to write to depending on the pin index
  - Line 139: We read the register value
  - Line 140-142: We determine the mask to use and the value to add (the specific bit for the requested pin)
  - Line 143: We mask out the current pin direction and add the new pin direction, then write to the register
- Line 146-157: We implement the `GetPinValue()` method.
  - Line 153: We determine the register to read from depending on the pin index
  - Line 154: We read the register value
  - Line 155-156: We extract the pin value for the requested pin
- Line 159-172: We implement the `SetPinValue()` method.
  - Line 166: We determine the register to write to depending on the pin index
  - Line 167: We read the register value
  - Line 168-170: We determine the value to add (the specific bit for the requested pin)
  - Line 171: We mask out the current pin value and add the new pin value, then write to the register
- Line 174-182: We implement the `SetPortADirections()` method.
  - Line 180: We write all 0's to the Pull-up register for port A GPPUA, so no pull-up
  - Line 181: We write all 0's to the Direction register for port A IODIRA when the pins are set output, all 1's if set to input
- Line 184-192: We implement the `GetPortAValue()` method.
We read the GPIO register for port A GPIOA
- Line 194-201: We implement the `SetPortAValue()` method.
We write the GPIO register for port A GPIOA
- Line 203-211: We implement the `SetPortBDirections()` method.
  - Line 209: We write all 0's to the Pull-up register for port B GPPUB, so no pull-up
  - Line 210: We write all 0's to the Direction register for port B IODIRB when the pins are set output, all 1's if set to input
- Line 213-221: We implement the `GetPortBValue()` method.
We read the GPIO register for port B GPIOB
- Line 223-230: We implement the `SetPortBValue()` method.
We write the GPIO register for port B GPIOB

## Faking MCP23017 - Step 3 {#TUTORIAL_22_I2C_FAKING_MCP23017___STEP_3}

In principle we could start writing an application, but again, we'll fake the functionality first.

### MemoryAccessStubMCP23017LEDs.h {#TUTORIAL_22_I2C_FAKING_MCP23017___STEP_3_MEMORYACCESSSTUBMCP23017LEDSH}

We'll define a `IMemoryAccess` implementation that will fake the I2C register access for the MCP23017 chip.

Create file `code/libraries/device/include/device/i2c/MemoryAccessStubMCP23017LEDs.h`

```cpp
File: code/libraries/device/include/device/i2c/MemoryAccessStubMCP23017LEDs.h
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MemoryAccessStubMCP23017LEDs.h
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : MemoryAccessStubMCP23017LEDs
9: //
10: // Description : MCP23017 memory access stub with LEDs on output pins, and controllable inputs on input pins
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39:
40: #pragma once
41:
42: #include "baremetal/stubs/MemoryAccessStubI2C.h"
43: #include "stdlib/Macros.h"
44:
45: /// @file
46: /// MemoryAccessStubMCP23017LEDs
47:
48: namespace device {
49:
50: /// @brief MCP23017 registers
51: class MCP23017Registers
52: {
53: public:
54:     /// @brief I/O Direction Register Port A
55:     uint8 IODIRA;
56:     /// @brief I/O Direction Register Port B
57:     uint8 IODIRB;
58:     /// @brief Input Polarity Register Port A
59:     uint8 IPOLA;
60:     /// @brief Input Polarity Register Port B
61:     uint8 IPOLB;
62:     /// @brief GPIO Interrupt Enable Register Port A
63:     uint8 GPINTENA;
64:     /// @brief GPIO Interrupt Enable Register Port B
65:     uint8 GPINTENB;
66:     /// @brief Default Compare Register Port A
67:     uint8 DEFVALA;
68:     /// @brief Default Compare Register Port B
69:     uint8 DEFVALB;
70:     /// @brief Interrupt Control Register Port A
71:     uint8 INTCONA;
72:     /// @brief Interrupt Control Register Port B
73:     uint8 INTCONB;
74:     /// @brief I/O Control Register Port A
75:     uint8 IOCONA;
76:     /// @brief I/O Control Register Port B
77:     uint8 IOCONB;
78:     /// @brief GPIO Pull-up Resistor Configuration Register Port A
79:     uint8 GPPUA;
80:     /// @brief GPIO Pull-up Resistor Configuration Register Port B
81:     uint8 GPPUB;
82:     /// @brief Interrupt Flag Register Port A
83:     uint8 INTFA;
84:     /// @brief Interrupt Flag Register Port B
85:     uint8 INTFB;
86:     /// @brief Interrupt Captured Register Port A
87:     uint8 INTCAPA;
88:     /// @brief Interrupt Captured Register Port B
89:     uint8 INTCAPB;
90:     /// @brief GPIO Port Register Port A
91:     uint8 GPIOA;
92:     /// @brief GPIO Port Register Port b
93:     uint8 GPIOB;
94:     /// @brief Output Latch Register Port A
95:     uint8 OLATA;
96:     /// @brief Output Latch Register Port B
97:     uint8 OLATB;
98:
99:     /// <summary>
100:     /// Constructor for MCP23017 register storage
101:     /// </summary>
102:     MCP23017Registers()
103:         : IODIRA{0xFF}
104:         , IODIRB{0xFF}
105:         , IPOLA{}
106:         , IPOLB{}
107:         , GPINTENA{}
108:         , GPINTENB{}
109:         , DEFVALA{}
110:         , DEFVALB{}
111:         , INTCONA{}
112:         , INTCONB{}
113:         , IOCONA{}
114:         , IOCONB{}
115:         , GPPUA{}
116:         , GPPUB{}
117:         , INTFA{}
118:         , INTFB{}
119:         , INTCAPA{}
120:         , INTCAPB{}
121:         , GPIOA{}
122:         , GPIOB{}
123:         , OLATA{}
124:         , OLATB{}
125:     {
126:     }
127: };
128:
129: /// @brief MemoryAccess implementation for I2C stub
130: class MemoryAccessStubMCP23017LEDs : public baremetal::MemoryAccessStubI2C
131: {
132: private:
133:     /// @brief Singleton instance
134:     static MemoryAccessStubMCP23017LEDs* m_pThis;
135:     /// @brief Storage for I2C registers
136:     MCP23017Registers m_registers;
137:     /// @brief A read / write register cycle was started
138:     bool m_cycleStarted;
139:     /// @brief Register selected for current read / write register cycle
140:     uint8 m_selectedRegister;
141:
142: public:
143:     MemoryAccessStubMCP23017LEDs();
144:
145:     void ResetCycle();
146:     static bool OnSendAddress(baremetal::I2CRegisters& registers, uint8 data);
147:     static bool OnRecvData(baremetal::I2CRegisters& registers, uint8& data);
148:     static bool OnSendData(baremetal::I2CRegisters& registers, uint8 data);
149: };
150:
151: } // namespace device
```

- Line 50-127: We declare a class `MCP23017Registers` to hold the register values for the MCP23017 device
  - Line 54-55: The member variable `IODIRA` holds the I/O Direction Register value for port A
  - Line 56-57: The member variable `IODIRB` holds the I/O Direction Register value for port B
  - Line 58-59: The member variable `IPOLA` holds the Input Polarity Register for port A
  - Line 60-61: The member variable `IPOLB` holds the Input Polarity Register for port B
  - Line 62-63: The member variable `GPINTENA` holds the GPIO Interrupt Enable Register for port A
  - Line 64-65: The member variable `GPINTENB` holds the GPIO Interrupt Enable Register for port B
  - Line 66-67: The member variable `DEFVALA` holds the Default Compare Register for port A
  - Line 68-69: The member variable `DEFVALB` holds the Default Compare Register for port B
  - Line 70-71: The member variable `INTCONA` holds the Interrupt Control Register for port A
  - Line 72-73: The member variable `INTCONB` holds the Interrupt Control Register for port B
  - Line 74-75: The member variable `IOCONA` holds the I/O Control Register for port A
  - Line 76-77: The member variable `IOCONB` holds the I/O Control Register for port B
  - Line 78-79: The member variable `GPPUA` holds the GPIO Pull-up Resistor Configuration Register for port A
  - Line 80-81: The member variable `GPPUB` holds the GPIO Pull-up Resistor Configuration Register for port B
  - Line 82-83: The member variable `INTFA` holds the Interrupt Flag Register for port A
  - Line 84-85: The member variable `INTFB` holds the Interrupt Flag Register for port B
  - Line 86-87: The member variable `INTCAPA` holds the Interrupt Captured Register for port A
  - Line 88-89: The member variable `INTCAPB` holds the Interrupt Captured Register for port B
  - Line 90-91: The member variable `GPIOA` holds the GPIO Port Register for port A
  - Line 92-93: The member variable `GPIOB` holds the GPIO Port Register for port B
  - Line 94-95: The member variable `OLATA` holds the Output Latch Register for port A
  - Line 96-97: The member variable `OLATB` holds the Output Latch Register for port B
  - Line 99-126: We define the constructor, which initializes the register values to their defaults
- Line 129-149: We declare the class `MemoryAccessStubMCP23017LEDs` which acts as the `MemoryAccess` class for fake MCP23017 access.
Note that it derives from `MemoryAccessStubI2C`
  - Line 133-134: The static member variable `m_pThis` contains the pointer to the singleton instance
  - Line 135-136: The member variable `m_registers` holds the register values
  - Line 137-138: The member variable `m_cycleStarted` holds a flag whether a read or write cycle has started
  - Line 139-140: The member variable `m_selectedRegister` holds the index of the selected register
  - Line 143: We declare the constructor
  - Line 145: We declare the method `ResetCycle()` to reset the read / write cycle
  - Line 146: We declare the static method `OnSendAddress()` as a address send callback
  - Line 147: We declare the static method `OnRecvData()` as a data receive callback
  - Line 148: We declare the static method `OnSendData()` as a data send callback

### MemoryAccessStubMCP23017LEDs.cpp {#TUTORIAL_22_I2C_FAKING_MCP23017___STEP_3_MEMORYACCESSSTUBMCP23017LEDSCPP}

We'll implement the MemoryAccess stub for MCP23017.

Create file `code/libraries/device/src/i2c/MemoryAccessStubMCP23017LEDs.cpp`

```cpp
File: code/libraries/device/src/i2c/MemoryAccessStubMCP23017LEDs.cpp
1: //------------------------------------------------------------------------------
2: // Copyright   : Copyright(c) 2025 Rene Barto
3: //
4: // File        : MemoryAccessStubMCP23017LEDs.cpp
5: //
6: // Namespace   : baremetal
7: //
8: // Class       : MemoryAccessStubMCP23017LEDs
9: //
10: // Description : MCP23017 memory access stub with LEDs on output pins, and controllable inputs on input pins
11: //
12: //------------------------------------------------------------------------------
13: //
14: // Baremetal - A C++ bare metal environment for embedded 64 bit ARM devices
15: //
16: // Intended support is for 64 bit code only, running on Raspberry Pi (3 or later)
17: //
18: // Permission is hereby granted, free of charge, to any person
19: // obtaining a copy of this software and associated documentation
20: // files(the "Software"), to deal in the Software without
21: // restriction, including without limitation the rights to use, copy,
22: // modify, merge, publish, distribute, sublicense, and /or sell copies
23: // of the Software, and to permit persons to whom the Software is
24: // furnished to do so, subject to the following conditions :
25: //
26: // The above copyright notice and this permission notice shall be
27: // included in all copies or substantial portions of the Software.
28: //
29: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
30: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
31: // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
32: // NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
33: // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
34: // WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
35: // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
36: // DEALINGS IN THE SOFTWARE.
37: //
38: //------------------------------------------------------------------------------
39:
40: #include "device/i2c/stubs/MemoryAccessStubMCP23017LEDs.h"
41:
42: #include "baremetal/Assert.h"
43: #include "baremetal/BCMRegisters.h"
44: #include "baremetal/Format.h"
45: #include "baremetal/Logger.h"
46: #include "baremetal/String.h"
47: #include "device/i2c/MCP23017.h"
48:
49: /// @file
50: /// MemoryAccessStubMCP23017LEDs
51:
52: /// @brief Define log name
53: LOG_MODULE("MemoryAccessStubMCP23017LEDs");
54:
55: using namespace baremetal;
56: using namespace device;
57:
58: /// @brief Singleton instance
59: MemoryAccessStubMCP23017LEDs* MemoryAccessStubMCP23017LEDs::m_pThis{};
60:
61: /// <summary>
62: /// MemoryAccessStubMCP23017LEDs constructor
63: /// </summary>
64: MemoryAccessStubMCP23017LEDs::MemoryAccessStubMCP23017LEDs()
65:     : m_registers{}
66:     , m_cycleStarted{}
67:     , m_selectedRegister{}
68: {
69:     m_pThis = this;
70:     SetSendAddressByteCallback(OnSendAddress);
71:     SetRecvDataByteCallback(OnRecvData);
72:     SetSendDataByteCallback(OnSendData);
73: }
74:
75: /// <summary>
76: /// Reset read or write cycle
77: /// </summary>
78: void MemoryAccessStubMCP23017LEDs::ResetCycle()
79: {
80:     m_cycleStarted = false;
81: }
82:
83: /// <summary>
84: /// Callback when I2C address is sent
85: /// </summary>
86: /// <param name="registers">I2C register storage, unused</param>
87: /// <param name="data">I2C address, unused</param>
88: /// <returns>True always</returns>
89: bool MemoryAccessStubMCP23017LEDs::OnSendAddress(I2CRegisters& /*registers*/, uint8 /*data*/)
90: {
91:     return true;
92: }
93:
94: /// <summary>
95: /// Callback when I2C byte is to be received
96: /// </summary>
97: /// <param name="registers">I2C Register storage for stub</param>
98: /// <param name="data">Byte requested</param>
99: /// <returns>True always</returns>
100: bool MemoryAccessStubMCP23017LEDs::OnRecvData(I2CRegisters& registers, uint8& data)
101: {
102:     uint8* registerAddress = &m_pThis->m_registers.IODIRA + m_pThis->m_selectedRegister;
103:     data = *registerAddress;
104:     LOG_DEBUG("Read register %02x: %02x", m_pThis->m_selectedRegister, data);
105:     switch (m_pThis->m_selectedRegister)
106:     {
107:     case IOCONA:
108:     case IOCONB:
109:         {
110:             String line;
111:             if (data & IOCON_BANK1)
112:                 line += "Bank 1 ";
113:             else
114:                 line += "Bank 0 ";
115:             if (data & IOCON_MIRROR)
116:                 line += "INT_MIRROR ";
117:             else
118:                 line += "           ";
119:             if (data & IOCON_SEQOP)
120:                 line += "SEQOP ";
121:             else
122:                 line += "      ";
123:             if (data & IOCON_DISSLW)
124:                 line += "DISSLW ";
125:             else
126:                 line += "       ";
127:             if (data & IOCON_HAEN)
128:                 line += "HAEN ";
129:             else
130:                 line += "HAEN ";
131:             if (data & IOCON_ODR)
132:                 line += "ODR ";
133:             else
134:                 line += "    ";
135:             if (data & IOCON_INTPOL)
136:                 line += "INTPOL H";
137:             else
138:                 line += "INTPOL L";
139:             LOG_INFO("IOCON: %s", line.c_str());
140:             break;
141:         }
142:     case IODIRA:
143:         {
144:             String line;
145:             uint8 bits = data;
146:             for (int i = 0; i < 8; ++i)
147:             {
148:                 line += (bits & 0x80 ? "I" : "O");
149:                 bits <<= 1;
150:             }
151:             LOG_INFO("IODIR A: %s", line.c_str());
152:             break;
153:         }
154:     case IODIRB:
155:         {
156:             String line;
157:             uint8 bits = data;
158:             for (int i = 0; i < 8; ++i)
159:             {
160:                 line += (bits & 0x80 ? "I" : "O");
161:                 bits <<= 1;
162:             }
163:             LOG_INFO("IODIR B: %s", line.c_str());
164:             break;
165:         }
166:     case GPIOA:
167:         {
168:             String line;
169:             uint8 gpio = data;
170:             for (int i = 0; i < 8; ++i)
171:             {
172:                 line += (gpio & 0x80 ? "X" : " ");
173:                 gpio <<= 1;
174:             }
175:             LOG_INFO("GPIO A: %s", line.c_str());
176:             break;
177:         }
178:     case GPIOB:
179:         {
180:             String line;
181:             uint8 gpio = data;
182:             for (int i = 0; i < 8; ++i)
183:             {
184:                 line += (gpio & 0x80 ? "X" : " ");
185:                 gpio <<= 1;
186:             }
187:             LOG_INFO("GPIO B: %s", line.c_str());
188:             break;
189:         }
190:     case GPINTENA:
191:         {
192:             String line;
193:             uint8 bits = data;
194:             for (int i = 0; i < 8; ++i)
195:             {
196:                 line += Format("Pin %d ", i);
197:                 line += (bits & 0x80 ? "X" : " ");
198:                 bits <<= 1;
199:             }
200:             LOG_INFO("GPINTEN A: %s", line.c_str());
201:             break;
202:         }
203:     case GPINTENB:
204:         {
205:             String line;
206:             uint8 bits = data;
207:             for (int i = 0; i < 8; ++i)
208:             {
209:                 line += Format("Pin %d ", i);
210:                 line += (bits & 0x80 ? "X" : " ");
211:                 bits <<= 1;
212:             }
213:             LOG_INFO("GPINTEN B: %s", line.c_str());
214:             break;
215:         }
216:     case INTCONA:
217:         {
218:             String line;
219:             uint8 bits = data;
220:             for (int i = 0; i < 8; ++i)
221:             {
222:                 line += Format("Pin %d ", i);
223:                 line += (bits & 0x80 ? "DEF " : "PRV ");
224:                 bits <<= 1;
225:             }
226:             LOG_INFO("INTCON A: %s", line.c_str());
227:             break;
228:         }
229:     case INTCONB:
230:         {
231:             String line;
232:             uint8 bits = data;
233:             for (int i = 0; i < 8; ++i)
234:             {
235:                 line += Format("Pin %d ", i);
236:                 line += (bits & 0x80 ? "DEF " : "PRV ");
237:                 bits <<= 1;
238:             }
239:             LOG_INFO("INTCON B: %s", line.c_str());
240:             break;
241:         }
242:     case DEFVALA:
243:         {
244:             String line;
245:             uint8 bits = data;
246:             for (int i = 0; i < 8; ++i)
247:             {
248:                 line += Format("Pin %d ", i);
249:                 line += (bits & 0x80 ? "1" : "0");
250:                 bits <<= 1;
251:             }
252:             LOG_INFO("DEFVAL A: %s", line.c_str());
253:             break;
254:         }
255:     case DEFVALB:
256:         {
257:             String line;
258:             uint8 bits = data;
259:             for (int i = 0; i < 8; ++i)
260:             {
261:                 line += Format("Pin %d ", i);
262:                 line += (bits & 0x80 ? "1" : "0");
263:                 bits <<= 1;
264:             }
265:             LOG_INFO("DEFVAL B: %s", line.c_str());
266:             break;
267:         }
268:     case IPOLA:
269:         {
270:             String line;
271:             uint8 bits = data;
272:             for (int i = 0; i < 8; ++i)
273:             {
274:                 line += Format("Pin %d ", i);
275:                 line += (bits & 0x80 ? "~" : " ");
276:                 bits <<= 1;
277:             }
278:             LOG_INFO("IPOL A: %s", line.c_str());
279:             break;
280:         }
281:     case IPOLB:
282:         {
283:             String line;
284:             uint8 bits = data;
285:             for (int i = 0; i < 8; ++i)
286:             {
287:                 line += Format("Pin %d ", i);
288:                 line += (bits & 0x80 ? "~" : " ");
289:                 bits <<= 1;
290:             }
291:             LOG_INFO("IPOL B: %s", line.c_str());
292:             break;
293:         }
294:     case GPPUA:
295:         {
296:             String line;
297:             uint8 bits = data;
298:             for (int i = 0; i < 8; ++i)
299:             {
300:                 line += Format("Pin %d ", i);
301:                 line += (bits & 0x80 ? "U" : "");
302:                 bits <<= 1;
303:             }
304:             LOG_INFO("GPPU A: %s", line.c_str());
305:             break;
306:         }
307:     case GPPUB:
308:         {
309:             String line;
310:             uint8 bits = data;
311:             for (int i = 0; i < 8; ++i)
312:             {
313:                 line += Format("Pin %d ", i);
314:                 line += (bits & 0x80 ? "U" : "");
315:                 bits <<= 1;
316:             }
317:             LOG_INFO("GPPU B: %s", line.c_str());
318:             break;
319:         }
320:     case INTFA:
321:         {
322:             String line;
323:             uint8 bits = data;
324:             for (int i = 0; i < 8; ++i)
325:             {
326:                 line += Format("Pin %d ", i);
327:                 line += (bits & 0x80 ? "X" : "");
328:                 bits <<= 1;
329:             }
330:             LOG_INFO("INTF A: %s", line.c_str());
331:             break;
332:         }
333:     case INTFB:
334:         {
335:             String line;
336:             uint8 bits = data;
337:             for (int i = 0; i < 8; ++i)
338:             {
339:                 line += Format("Pin %d ", i);
340:                 line += (bits & 0x80 ? "X" : "");
341:                 bits <<= 1;
342:             }
343:             LOG_INFO("INTF B: %s", line.c_str());
344:             break;
345:         }
346:     case INTCAPA:
347:         {
348:             String line;
349:             uint8 bits = data;
350:             for (int i = 0; i < 8; ++i)
351:             {
352:                 line += Format("Pin %d ", i);
353:                 line += (bits & 0x80 ? "1" : "0");
354:                 bits <<= 1;
355:             }
356:             LOG_INFO("INTCAP A: %s", line.c_str());
357:             break;
358:         }
359:     case INTCAPB:
360:         {
361:             String line;
362:             uint8 bits = data;
363:             for (int i = 0; i < 8; ++i)
364:             {
365:                 line += Format("Pin %d ", i);
366:                 line += (bits & 0x80 ? "1" : "0");
367:                 bits <<= 1;
368:             }
369:             LOG_INFO("INTCAP B: %s", line.c_str());
370:             break;
371:         }
372:     case OLATA:
373:         {
374:             String line;
375:             uint8 bits = data;
376:             for (int i = 0; i < 8; ++i)
377:             {
378:                 line += Format("Pin %d ", i);
379:                 line += (bits & 0x80 ? "1" : "0");
380:                 bits <<= 1;
381:             }
382:             LOG_INFO("OLAT A: %s", line.c_str());
383:             break;
384:         }
385:     case OLATB:
386:         {
387:             String line;
388:             uint8 bits = data;
389:             for (int i = 0; i < 8; ++i)
390:             {
391:                 line += Format("Pin %d ", i);
392:                 line += (bits & 0x80 ? "1" : "0");
393:                 bits <<= 1;
394:             }
395:             LOG_INFO("OLAT B: %s", line.c_str());
396:             break;
397:         }
398:     }
399:     m_pThis->ResetCycle();
400:
401:     return true;
402: }
403:
404: /// <summary>
405: /// Callback when I2C byte is sent
406: /// </summary>
407: /// <param name="registers">I2C Register storage for stub</param>
408: /// <param name="data">Byte sent</param>
409: /// <returns>True always</returns>
410: bool MemoryAccessStubMCP23017LEDs::OnSendData(I2CRegisters& registers, uint8 data)
411: {
412:     if (!m_pThis->m_cycleStarted)
413:     {
414:         m_pThis->m_selectedRegister = data;
415:         m_pThis->m_cycleStarted = true;
416:     }
417:     else
418:     {
419:         uint8* registerAddress = &m_pThis->m_registers.IODIRA + m_pThis->m_selectedRegister;
420:         *registerAddress = data;
421:         LOG_DEBUG("Write register %02x: %02x", m_pThis->m_selectedRegister, data);
422:         switch (m_pThis->m_selectedRegister)
423:         {
424:         case IOCONA:
425:         case IOCONB:
426:             {
427:                 String line;
428:                 if (data & IOCON_BANK1)
429:                     line += "Bank 1 ";
430:                 else
431:                     line += "Bank 0 ";
432:                 if (data & IOCON_MIRROR)
433:                     line += "INT_MIRROR ";
434:                 else
435:                     line += "           ";
436:                 if (data & IOCON_SEQOP)
437:                     line += "SEQOP ";
438:                 else
439:                     line += "      ";
440:                 if (data & IOCON_DISSLW)
441:                     line += "DISSLW ";
442:                 else
443:                     line += "       ";
444:                 if (data & IOCON_HAEN)
445:                     line += "HAEN ";
446:                 else
447:                     line += "HAEN ";
448:                 if (data & IOCON_ODR)
449:                     line += "ODR ";
450:                 else
451:                     line += "    ";
452:                 if (data & IOCON_INTPOL)
453:                     line += "INTPOL H";
454:                 else
455:                     line += "INTPOL L";
456:                 LOG_INFO("IOCON: %s", line.c_str());
457:                 break;
458:             }
459:         case IODIRA:
460:             {
461:                 String line;
462:                 uint8 bits = data;
463:                 for (int i = 0; i < 8; ++i)
464:                 {
465:                     line += (bits & 0x80 ? "I" : "O");
466:                     bits <<= 1;
467:                 }
468:                 LOG_INFO("IODIR A: %s", line.c_str());
469:                 break;
470:             }
471:         case IODIRB:
472:             {
473:                 String line;
474:                 uint8 bits = data;
475:                 for (int i = 0; i < 8; ++i)
476:                 {
477:                     line += (bits & 0x80 ? "I" : "O");
478:                     bits <<= 1;
479:                 }
480:                 LOG_INFO("IODIR B: %s", line.c_str());
481:                 break;
482:             }
483:         case GPIOA:
484:             {
485:                 String line;
486:                 uint8 gpio = data;
487:                 for (int i = 0; i < 8; ++i)
488:                 {
489:                     line += (gpio & 0x80 ? "X" : " ");
490:                     gpio <<= 1;
491:                 }
492:                 LOG_INFO("GPIO A: %s", line.c_str());
493:                 break;
494:             }
495:         case GPIOB:
496:             {
497:                 String line;
498:                 uint8 gpio = data;
499:                 for (int i = 0; i < 8; ++i)
500:                 {
501:                     line += (gpio & 0x80 ? "X" : " ");
502:                     gpio <<= 1;
503:                 }
504:                 LOG_INFO("GPIO B: %s", line.c_str());
505:                 break;
506:             }
507:         case GPINTENA:
508:             {
509:                 String line;
510:                 uint8 bits = data;
511:                 for (int i = 0; i < 8; ++i)
512:                 {
513:                     line += Format("Pin %d ", i);
514:                     line += (bits & 0x80 ? "X" : " ");
515:                     bits <<= 1;
516:                 }
517:                 LOG_INFO("GPINTEN A: %s", line.c_str());
518:                 break;
519:             }
520:         case GPINTENB:
521:             {
522:                 String line;
523:                 uint8 bits = data;
524:                 for (int i = 0; i < 8; ++i)
525:                 {
526:                     line += Format("Pin %d ", i);
527:                     line += (bits & 0x80 ? "X" : " ");
528:                     bits <<= 1;
529:                 }
530:                 LOG_INFO("GPINTEN B: %s", line.c_str());
531:                 break;
532:             }
533:         case INTCONA:
534:             {
535:                 String line;
536:                 uint8 bits = data;
537:                 for (int i = 0; i < 8; ++i)
538:                 {
539:                     line += Format("Pin %d ", i);
540:                     line += (bits & 0x80 ? "DEF " : "PRV ");
541:                     bits <<= 1;
542:                 }
543:                 LOG_INFO("INTCON A: %s", line.c_str());
544:                 break;
545:             }
546:         case INTCONB:
547:             {
548:                 String line;
549:                 uint8 bits = data;
550:                 for (int i = 0; i < 8; ++i)
551:                 {
552:                     line += Format("Pin %d ", i);
553:                     line += (bits & 0x80 ? "DEF " : "PRV ");
554:                     bits <<= 1;
555:                 }
556:                 LOG_INFO("INTCON B: %s", line.c_str());
557:                 break;
558:             }
559:         case DEFVALA:
560:             {
561:                 String line;
562:                 uint8 bits = data;
563:                 for (int i = 0; i < 8; ++i)
564:                 {
565:                     line += Format("Pin %d ", i);
566:                     line += (bits & 0x80 ? "1" : "0");
567:                     bits <<= 1;
568:                 }
569:                 LOG_INFO("DEFVAL A: %s", line.c_str());
570:                 break;
571:             }
572:         case DEFVALB:
573:             {
574:                 String line;
575:                 uint8 bits = data;
576:                 for (int i = 0; i < 8; ++i)
577:                 {
578:                     line += Format("Pin %d ", i);
579:                     line += (bits & 0x80 ? "1" : "0");
580:                     bits <<= 1;
581:                 }
582:                 LOG_INFO("DEFVAL B: %s", line.c_str());
583:                 break;
584:             }
585:         case IPOLA:
586:             {
587:                 String line;
588:                 uint8 bits = data;
589:                 for (int i = 0; i < 8; ++i)
590:                 {
591:                     line += Format("Pin %d ", i);
592:                     line += (bits & 0x80 ? "~" : " ");
593:                     bits <<= 1;
594:                 }
595:                 LOG_INFO("IPOL A: %s", line.c_str());
596:                 break;
597:             }
598:         case IPOLB:
599:             {
600:                 String line;
601:                 uint8 bits = data;
602:                 for (int i = 0; i < 8; ++i)
603:                 {
604:                     line += Format("Pin %d ", i);
605:                     line += (bits & 0x80 ? "~" : " ");
606:                     bits <<= 1;
607:                 }
608:                 LOG_INFO("IPOL B: %s", line.c_str());
609:                 break;
610:             }
611:         case GPPUA:
612:             {
613:                 String line;
614:                 uint8 bits = data;
615:                 for (int i = 0; i < 8; ++i)
616:                 {
617:                     line += Format("Pin %d ", i);
618:                     line += (bits & 0x80 ? "U" : "");
619:                     bits <<= 1;
620:                 }
621:                 LOG_INFO("GPPU A: %s", line.c_str());
622:                 break;
623:             }
624:         case GPPUB:
625:             {
626:                 String line;
627:                 uint8 bits = data;
628:                 for (int i = 0; i < 8; ++i)
629:                 {
630:                     line += Format("Pin %d ", i);
631:                     line += (bits & 0x80 ? "U" : "");
632:                     bits <<= 1;
633:                 }
634:                 LOG_INFO("GPPU B: %s", line.c_str());
635:                 break;
636:             }
637:         case OLATA:
638:             {
639:                 String line;
640:                 uint8 bits = data;
641:                 for (int i = 0; i < 8; ++i)
642:                 {
643:                     line += Format("Pin %d ", i);
644:                     line += (bits & 0x80 ? "1" : "0");
645:                     bits <<= 1;
646:                 }
647:                 LOG_INFO("OLAT A: %s", line.c_str());
648:                 break;
649:             }
650:         case OLATB:
651:             {
652:                 String line;
653:                 uint8 bits = data;
654:                 for (int i = 0; i < 8; ++i)
655:                 {
656:                     line += Format("Pin %d ", i);
657:                     line += (bits & 0x80 ? "1" : "0");
658:                     bits <<= 1;
659:                 }
660:                 LOG_INFO("OLAT B: %s", line.c_str());
661:                 break;
662:             }
663:         }
664:         m_pThis->ResetCycle();
665:     }
666:     return true;
667: }
```

- Line 58-59: We define static instance variable
- Line 61-73: We implement the constructor
- Line 75-81: We implement the method `ResetCycle()`
- Line 83-92: We implement the method `OnSendAddress()`, which does nothing
- Line 94-402: We implement the method `OnRecvData()`
  - Line 102: We calculate the pointer to the selected register value
  - Line 103: We retrieve the register value
  - Line 107-141: If one of the IOCON registers is read, we print the values for the respective bits
  - Line 142-153: If the IODIRA register is read, we print the pin directions for port A
  - Line 154-165: If the IODIRB register is read, we print the pin directions for port B
  - Line 166-177: If the GPIOA register is read, we print the pin values for port A
  - Line 178-189: If the GPIOB register is read, we print the pin values for port B
  - Line 190-202: If the GPINTENA register is read, we print the pin interrupt enable status for port A
  - Line 203-215: If the GPINTENB register is read, we print the pin interrupt enable status for port B
  - Line 216-228: If the INTCONA register is read, we print the pin interrupt comparison setting (compare to default or compare to previous) for port A
  - Line 229-241: If the INTCONB register is read, we print the pin interrupt comparison setting (compare to default or compare to previous) for port B
  - Line 242-254: If the DEFVALA register is read, we print the pin interrupt comparison default value for port A
  - Line 255-267: If the DEFVALB register is read, we print the pin interrupt comparison default value for port B
  - Line 268-280: If the IPOLA register is read, we print the pin polarity setting (same logic or inverted logic) for port A
  - Line 281-293: If the IPOLB register is read, we print the pin polarity setting (same logic or inverted logic) for port B
  - Line 294-306: If the GPPUA register is read, we print the pin pull up settings for port A
  - Line 307-319: If the GPPUB register is read, we print the pin pull up settings for port B
  - Line 320-332: If the INTFA register is read, we print the pin interrupt flags for port A
  - Line 333-345: If the INTFB register is read, we print the pin interrupt flags for port A
  - Line 346-358: If the INTCAPA register is read, we print the pin value at the time of the last interrupt flags for port A
  - Line 359-371: If the INTCAPB register is read, we print the pin value at the time of the last interrupt flags for port B
  - Line 372-384: If the OLATA register is read, we print the pin output latch value for port A
  - Line 385-398: If the OLATA register is read, we print the pin output latch value for port A
  - Line 399: We reset the read cycle
- Line 404-667: We implement the method `OnSendData()`
  - Line 412-416: If the read / write cycle has not started yet, we save the selected register (this is the first byte sent) and start the cycle
  - Line 419: In case the cycle is started, this is a write cycle.
We calculate the pointer to the selected register value
  - Line 420: We set the register value
  - Line 424-458: If one of the IOCON registers is written, we print the values for the respective bits
  - Line 459-470: If the IODIRA register is written, we print the pin directions for port A
  - Line 471-482: If the IODIRB register is written, we print the pin directions for port B
  - Line 483-494: If the GPIOA register is written, we print the pin values for port A
  - Line 495-506: If the GPIOB register is written, we print the pin values for port B
  - Line 507-519: If the GPINTENA register is written, we print the pin interrupt enable status for port A
  - Line 520-532: If the GPINTENB register is written, we print the pin interrupt enable status for port B
  - Line 533-545: If the INTCONA register is written, we print the pin interrupt comparison setting (compare to default or compare to previous) for port A
  - Line 546-558: If the INTCONB register is written, we print the pin interrupt comparison setting (compare to default or compare to previous) for port B
  - Line 559-571: If the DEFVALA register is written, we print the pin interrupt comparison default value for port A
  - Line 572-584: If the DEFVALB register is written, we print the pin interrupt comparison default value for port B
  - Line 585-597: If the IPOLA register is written, we print the pin polarity setting (same logic or inverted logic) for port A
  - Line 598-610: If the IPOLB register is written, we print the pin polarity setting (same logic or inverted logic) for port B
  - Line 611-623: If the GPPUA register is written, we print the pin pull up settings for port A
  - Line 624-636: If the GPPUB register is written, we print the pin pull up settings for port B
  - Line 637-649: If the OLATA register is written, we print the pin output latch value for port A
  - Line 650-662: If the OLATB register is written, we print the pin output latch value for port A
  - Line 664: We reset the write cycle

### Update application code {#TUTORIAL_22_I2C_FAKING_MCP23017___STEP_3_UPDATE_APPLICATION_CODE}

Next let's use the new stub.
We'll initialize the MCP23017 chip, and the interact with it.

Update the file code/applications/demo/src/main.cpp.

```cpp
File: code/applications/demo/src/main.cpp
1: #include "baremetal/Format.h"
2: #include "baremetal/I2CMaster.h"
3: #include "baremetal/Logger.h"
4: #include "baremetal/PhysicalGPIOPin.h"
5: #include "baremetal/String.h"
6: #include "baremetal/System.h"
7: #include "baremetal/Timer.h"
8: #include "device/i2c/stubs/MemoryAccessStubMCP23017LEDs.h"
9: #include "device/i2c/MCP23017.h"
10:
11: LOG_MODULE("main");
12:
13: using namespace baremetal;
14: using namespace device;
15:
16: int main()
17: {
18:     GetLogger().SetLogLevel(LogSeverity::Info);
19:
20:     MemoryAccessStubMCP23017LEDs fakeMemoryAccess;
21:
22:     uint8 busIndex = 1;
23:     fakeMemoryAccess.SetBus(busIndex);
24:
25:     uint8 address{ 0x20 };
26:     MCP23017 expander(fakeMemoryAccess);
27:
28:     if (!expander.Initialize(busIndex, address))
29:     {
30:         LOG_INFO("Cannot initialize expander");
31:     }
32:
33:     expander.GetPortAValue();
34:     expander.SetPortADirections(MCP23017PinDirection::Out);
35:     expander.SetPortBDirections(MCP23017PinDirection::Out);
36:     expander.SetPortAValue(0x55);
37:     expander.SetPortBValue(0xAA);
38:     Timer::WaitMilliSeconds(500);
39:     expander.SetPortAValue(0xAA);
40:     expander.SetPortBValue(0x55);
41:     Timer::WaitMilliSeconds(500);
42:     expander.SetPortAValue(0x00);
43:     expander.SetPortBValue(0x00);
44:
45:     LOG_INFO("Rebooting");
46:
47:     return static_cast<int>(ReturnCode::ExitReboot);
48: }
```

- Line 21: We instantiate the stub for the MCP23017 device
- Line 24: We set up the I2C bus for the device
- Line 27: We instantiate a the MCP23017 expander, and inject the stub
- Line 29: We initialize the expander to the same bus, and address 0x20
- Line 34: We read the pin values for port A
- Line 35-36: We set the direction for all pins to output
- Line 37-38: We set the pins values for port A to 0x55 and for port B to 0xAA
- Line 39: We wait for half a second
- Line 40-41: We set the pins values for port A to 0xAA and for port B to 0x55, so the inverse of before
- Line 42: We wait for half a second
- Line 43-44: We set the pin value for all pins to 0 (off)

### Configuring, building and debugging : Use I2C stub {#TUTORIAL_22_I2C_FAKING_MCP23017___STEP_3_CONFIGURING_BUILDING_AND_DEBUGGING__USE_I2C_STUB}

We can now configure and build our code, and test.
Notice that the setup of the GPIO pins is logged by the stub.

```text
1: Setting up UART0
2: Info   0.00:00:00.000 Baremetal 0.0.1 started on Raspberry Pi 4 Model B (AArch64) using BCM2711 SoC (Logger:93)
3: Info   0.00:00:00.010 Starting up (System:213)
4: Info   0.00:00:00.020 Initialize 20 (MCP23017:79)
5: Info   0.00:00:00.020 Initialize bus 1, mode 0, config 0 (I2CMaster:166)
6: Info   0.00:00:00.030 Set clock 100000 (I2CMaster:207)
7: Info   0.00:00:00.030 Set up bus 1, config 0, base address FE804000 (I2CMaster:190)
8: Info   0.00:00:00.040 IOCON: Bank 0            SEQOP        HAEN ODR INTPOL L (MemoryAccessStubMCP23017LEDs:456)
9: Info   0.00:00:00.050 GPIO A:          (MemoryAccessStubMCP23017LEDs:175)
10: Info   0.00:00:00.050 GPPU A: Pin 0 Pin 1 Pin 2 Pin 3 Pin 4 Pin 5 Pin 6 Pin 7  (MemoryAccessStubMCP23017LEDs:621)
11: Info   0.00:00:00.060 IODIR A: OOOOOOOO (MemoryAccessStubMCP23017LEDs:468)
12: Info   0.00:00:00.060 GPPU B: Pin 0 Pin 1 Pin 2 Pin 3 Pin 4 Pin 5 Pin 6 Pin 7  (MemoryAccessStubMCP23017LEDs:634)
13: Info   0.00:00:00.070 IODIR B: OOOOOOOO (MemoryAccessStubMCP23017LEDs:480)
14: Info   0.00:00:00.070 GPIO A:  X X X X (MemoryAccessStubMCP23017LEDs:492)
15: Info   0.00:00:00.070 GPIO B: X X X X  (MemoryAccessStubMCP23017LEDs:504)
16: Info   0.00:00:00.580 GPIO A: X X X X  (MemoryAccessStubMCP23017LEDs:492)
17: Info   0.00:00:00.580 GPIO B:  X X X X (MemoryAccessStubMCP23017LEDs:504)
18: Info   0.00:00:01.080 GPIO A:          (MemoryAccessStubMCP23017LEDs:492)
19: Info   0.00:00:01.080 GPIO B:          (MemoryAccessStubMCP23017LEDs:504)
20: Info   0.00:00:01.090 Rebooting (main:45)
21: Info   0.00:00:01.090 GPPU A: Pin 0 UPin 1 UPin 2 UPin 3 UPin 4 UPin 5 UPin 6 UPin 7 U (MemoryAccessStubMCP23017LEDs:621)
22: Info   0.00:00:01.100 IODIR A: IIIIIIII (MemoryAccessStubMCP23017LEDs:468)
23: Info   0.00:00:01.100 GPPU B: Pin 0 UPin 1 UPin 2 UPin 3 UPin 4 UPin 5 UPin 6 UPin 7 U (MemoryAccessStubMCP23017LEDs:634)
24: Info   0.00:00:01.100 IODIR B: IIIIIIII (MemoryAccessStubMCP23017LEDs:480)
25: Info   0.00:00:01.110 Reboot (System:144)
```

You can see the IOCON register being configured, and then the ports being set to output.
Next you can see the values being written, and finally the ports being placed in input mode again.

## Scanning for actual device - Step 4 {#TUTORIAL_22_I2C_SCANNING_FOR_ACTUAL_DEVICE___STEP_4}

### Update application code {#TUTORIAL_22_I2C_SCANNING_FOR_ACTUAL_DEVICE___STEP_4_UPDATE_APPLICATION_CODE}

Now let's use the actual device, and see if we can find it.

Update the file code/applications/demo/src/main.cpp.

```cpp
File: code/applications/demo/src/main.cpp
1: #include "baremetal/Format.h"
2: #include "baremetal/I2CMaster.h"
3: #include "baremetal/Logger.h"
4: #include "baremetal/PhysicalGPIOPin.h"
5: #include "baremetal/String.h"
6: #include "baremetal/System.h"
7: #include "baremetal/Timer.h"
8: #include "device/i2c/MCP23017.h"
9:
10: LOG_MODULE("main");
11:
12: using namespace baremetal;
13: using namespace device;
14:
15: int main()
16: {
17:     GetLogger().SetLogLevel(LogSeverity::Debug);
18:
19:     uint8 busIndex = 1;
20:     uint8 address{ 0x20 };
21:     MCP23017 expander;
22:
23:     if (!expander.Initialize(busIndex, address))
24:     {
25:         LOG_INFO("Cannot initialize expander");
26:     }
27:
28:     expander.GetPortAValue();
29:     expander.SetPortADirections(MCP23017PinDirection::Out);
30:     expander.SetPortBDirections(MCP23017PinDirection::Out);
31:     expander.SetPortAValue(0x55);
32:     expander.SetPortBValue(0xAA);
33:     Timer::WaitMilliSeconds(500);
34:     expander.SetPortAValue(0xAA);
35:     expander.SetPortBValue(0x55);
36:     Timer::WaitMilliSeconds(500);
37:     expander.SetPortAValue(0x00);
38:     expander.SetPortBValue(0x00);
39:
40:     LOG_INFO("Rebooting");
41:
42:     return static_cast<int>(ReturnCode::ExitReboot);
43: }
```

### Configuring, building and debugging : Use I2C stub {#TUTORIAL_22_I2C_SCANNING_FOR_ACTUAL_DEVICE___STEP_4_CONFIGURING_BUILDING_AND_DEBUGGING__USE_I2C_STUB}

We can now configure and build our code, and test.
Notice that the setup of the GPIO pins is logged by the stub.

```text
File: Untitled-1
1: Setting up UART0
2: Info   0.00:00:00.030 Baremetal 0.0.1 started on Raspberry Pi 4 Model B (AArch64) using BCM2711 SoC (Logger:93)
3: Info   0.00:00:00.050 Starting up (System:213)
4: Info   0.00:00:00.070 Initialize 20 (MCP23017:79)
5: Info   0.00:00:00.090 Initialize bus 1, mode 0, config 0 (I2CMaster:166)
6: Debug  0.00:00:00.110 GetClockRate (RPIProperties.cpp:307)
7: Debug  0.00:00:00.120 Clock ID:   00000004 (RPIProperties.cpp:308)
8: Debug  0.00:00:00.140 Result: OK (RPIProperties.cpp:309)
9: Debug  0.00:00:00.160 Rate:       0FEEACA0 (RPIProperties.cpp:314)
10: Info   0.00:00:00.180 Set clock 100000 (I2CMaster:207)
11: Info   0.00:00:00.200 Set up bus 1, config 0, base address FE804000 (I2CMaster:190)
12: Debug  0.00:00:00.220 Write I2C Address, 20 (I2CMaster.cpp:625)
13: Debug  0.00:00:00.230 Write I2C Length, 00000002 (I2CMaster.cpp:635)
14: Debug  0.00:00:00.250 Write FIFO, data 0000000A (I2CMaster.cpp:829)
15: Debug  0.00:00:00.270 Write FIFO, data 0000002C (I2CMaster.cpp:829)
16: Debug  0.00:00:00.290 Write result = 2 (I2CMaster.cpp:398)
17: Debug  0.00:00:00.310 Write bytes to I2C 20 Register 0A: 2C, 2 bytes written (MCP23017:115)
18: Debug  0.00:00:00.330 Write I2C Address, 20 (I2CMaster.cpp:625)
19: Debug  0.00:00:00.350 Write I2C Length, 00000001 (I2CMaster.cpp:635)
20: Debug  0.00:00:00.370 Write FIFO, data 00000012 (I2CMaster.cpp:829)
21: Debug  0.00:00:00.390 Write I2C Length, 00000001 (I2CMaster.cpp:635)
22: Debug  0.00:00:00.410 Read bytes from I2C 20 Register 12: 00, -4100 bytes transferred (MCP23017:98)
23: Debug  0.00:00:00.440 Write I2C Address, 20 (I2CMaster.cpp:625)
24: Debug  0.00:00:00.450 Write I2C Length, 00000002 (I2CMaster.cpp:635)
25: Debug  0.00:00:00.470 Write FIFO, data 0000000C (I2CMaster.cpp:829)
26: Debug  0.00:00:00.490 Write FIFO, data 00000000 (I2CMaster.cpp:829)
27: Debug  0.00:00:00.510 Write result = 2 (I2CMaster.cpp:398)
28: Debug  0.00:00:00.530 Write bytes to I2C 20 Register 0C: 00, 2 bytes written (MCP23017:115)
29: Debug  0.00:00:00.550 Write I2C Address, 20 (I2CMaster.cpp:625)
30: Debug  0.00:00:00.560 Write I2C Length, 00000002 (I2CMaster.cpp:635)
31: Debug  0.00:00:00.580 Write FIFO, data 00000000 (I2CMaster.cpp:829)
32: Debug  0.00:00:00.600 Write FIFO, data 00000000 (I2CMaster.cpp:829)
33: Debug  0.00:00:00.620 Write result = 2 (I2CMaster.cpp:398)
34: Debug  0.00:00:00.640 Write bytes to I2C 20 Register 00: 00, 2 bytes written (MCP23017:115)
35: Debug  0.00:00:00.660 Write I2C Address, 20 (I2CMaster.cpp:625)
36: Debug  0.00:00:00.670 Write I2C Length, 00000002 (I2CMaster.cpp:635)
37: Debug  0.00:00:00.690 Write FIFO, data 0000000D (I2CMaster.cpp:829)
38: Debug  0.00:00:00.710 Write FIFO, data 00000000 (I2CMaster.cpp:829)
39: Debug  0.00:00:00.730 Write result = 2 (I2CMaster.cpp:398)
40: Debug  0.00:00:00.750 Write bytes to I2C 20 Register 0D: 00, 2 bytes written (MCP23017:115)
41: Debug  0.00:00:00.770 Write I2C Address, 20 (I2CMaster.cpp:625)
42: Debug  0.00:00:00.790 Write I2C Length, 00000002 (I2CMaster.cpp:635)
43: Debug  0.00:00:00.800 Write FIFO, data 00000001 (I2CMaster.cpp:829)
44: Debug  0.00:00:00.820 Write FIFO, data 00000000 (I2CMaster.cpp:829)
45: Debug  0.00:00:00.840 Write result = 2 (I2CMaster.cpp:398)
46: Debug  0.00:00:00.860 Write bytes to I2C 20 Register 01: 00, 2 bytes written (MCP23017:115)
47: Debug  0.00:00:00.880 Write I2C Address, 20 (I2CMaster.cpp:625)
48: Debug  0.00:00:00.900 Write I2C Length, 00000002 (I2CMaster.cpp:635)
49: Debug  0.00:00:00.910 Write FIFO, data 00000012 (I2CMaster.cpp:829)
50: Debug  0.00:00:00.930 Write FIFO, data 00000055 (I2CMaster.cpp:829)
51: Debug  0.00:00:00.950 Write result = 2 (I2CMaster.cpp:398)
52: Debug  0.00:00:00.970 Write bytes to I2C 20 Register 12: 55, 2 bytes written (MCP23017:115)
53: Debug  0.00:00:00.990 Write I2C Address, 20 (I2CMaster.cpp:625)
54: Debug  0.00:00:01.010 Write I2C Length, 00000002 (I2CMaster.cpp:635)
55: Debug  0.00:00:01.020 Write FIFO, data 00000013 (I2CMaster.cpp:829)
56: Debug  0.00:00:01.040 Write FIFO, data 000000AA (I2CMaster.cpp:829)
57: Debug  0.00:00:01.060 Write result = 2 (I2CMaster.cpp:398)
58: Debug  0.00:00:01.080 Write bytes to I2C 20 Register 13: AA, 2 bytes written (MCP23017:115)
59: Debug  0.00:00:01.600 Write I2C Address, 20 (I2CMaster.cpp:625)
60: Debug  0.00:00:01.620 Write I2C Length, 00000002 (I2CMaster.cpp:635)
61: Debug  0.00:00:01.640 Write FIFO, data 00000012 (I2CMaster.cpp:829)
62: Debug  0.00:00:01.650 Write FIFO, data 000000AA (I2CMaster.cpp:829)
63: Debug  0.00:00:01.670 Write result = 2 (I2CMaster.cpp:398)
64: Debug  0.00:00:01.690 Write bytes to I2C 20 Register 12: AA, 2 bytes written (MCP23017:115)
65: Debug  0.00:00:01.710 Write I2C Address, 20 (I2CMaster.cpp:625)
66: Debug  0.00:00:01.730 Write I2C Length, 00000002 (I2CMaster.cpp:635)
67: Debug  0.00:00:01.750 Write FIFO, data 00000013 (I2CMaster.cpp:829)
68: Debug  0.00:00:01.760 Write FIFO, data 00000055 (I2CMaster.cpp:829)
69: Debug  0.00:00:01.780 Write result = 2 (I2CMaster.cpp:398)
70: Debug  0.00:00:01.800 Write bytes to I2C 20 Register 13: 55, 2 bytes written (MCP23017:115)
71: Debug  0.00:00:02.320 Write I2C Address, 20 (I2CMaster.cpp:625)
72: Debug  0.00:00:02.340 Write I2C Length, 00000002 (I2CMaster.cpp:635)
73: Debug  0.00:00:02.360 Write FIFO, data 00000012 (I2CMaster.cpp:829)
74: Debug  0.00:00:02.380 Write FIFO, data 00000000 (I2CMaster.cpp:829)
75: Debug  0.00:00:02.390 Write result = 2 (I2CMaster.cpp:398)
76: Debug  0.00:00:02.410 Write bytes to I2C 20 Register 12: 00, 2 bytes written (MCP23017:115)
77: Debug  0.00:00:02.430 Write I2C Address, 20 (I2CMaster.cpp:625)
78: Debug  0.00:00:02.450 Write I2C Length, 00000002 (I2CMaster.cpp:635)
79: Debug  0.00:00:02.470 Write FIFO, data 00000013 (I2CMaster.cpp:829)
80: Debug  0.00:00:02.490 Write FIFO, data 00000000 (I2CMaster.cpp:829)
81: Debug  0.00:00:02.500 Write result = 2 (I2CMaster.cpp:398)
82: Debug  0.00:00:02.520 Write bytes to I2C 20 Register 13: 00, 2 bytes written (MCP23017:115)
83: Info   0.00:00:02.540 Rebooting (main:40)
84: Debug  0.00:00:02.560 Write I2C Address, 20 (I2CMaster.cpp:625)
85: Debug  0.00:00:02.580 Write I2C Length, 00000002 (I2CMaster.cpp:635)
86: Debug  0.00:00:02.600 Write FIFO, data 0000000C (I2CMaster.cpp:829)
87: Debug  0.00:00:02.630 Write FIFO, data 00000000 (I2CMaster.cpp:829)
88: Debug  0.00:00:02.650 Write result = 2 (I2CMaster.cpp:398)
89: Debug  0.00:00:02.670 Write bytes to I2C 20 Register 0C: 00, 2 bytes written (MCP23017:115)
90: Debug  0.00:00:02.690 Write I2C Address, 20 (I2CMaster.cpp:625)
91: Debug  0.00:00:02.720 Write I2C Length, 00000002 (I2CMaster.cpp:635)
92: Debug  0.00:00:02.740 Write FIFO, data 00000000 (I2CMaster.cpp:829)
93: Debug  0.00:00:02.760 Write FIFO, data 000000FF (I2CMaster.cpp:829)
94: Debug  0.00:00:02.780 Write result = 2 (I2CMaster.cpp:398)
95: Debug  0.00:00:02.800 Write bytes to I2C 20 Register 00: FF, 2 bytes written (MCP23017:115)
96: Debug  0.00:00:02.830 Write I2C Address, 20 (I2CMaster.cpp:625)
97: Debug  0.00:00:02.850 Write I2C Length, 00000002 (I2CMaster.cpp:635)
98: Debug  0.00:00:02.870 Write FIFO, data 0000000D (I2CMaster.cpp:829)
99: Debug  0.00:00:02.890 Write FIFO, data 00000000 (I2CMaster.cpp:829)
100: Debug  0.00:00:02.910 Write result = 2 (I2CMaster.cpp:398)
101: Debug  0.00:00:02.940 Write bytes to I2C 20 Register 0D: 00, 2 bytes written (MCP23017:115)
102: Debug  0.00:00:02.960 Write I2C Address, 20 (I2CMaster.cpp:625)
103: Debug  0.00:00:02.980 Write I2C Length, 00000002 (I2CMaster.cpp:635)
104: Debug  0.00:00:03.000 Write FIFO, data 00000001 (I2CMaster.cpp:829)
105: Debug  0.00:00:03.020 Write FIFO, data 000000FF (I2CMaster.cpp:829)
106: Debug  0.00:00:03.050 Write result = 2 (I2CMaster.cpp:398)
107: Debug  0.00:00:03.070 Write bytes to I2C 20 Register 01: FF, 2 bytes written (MCP23017:115)
108: Info   0.00:00:03.090 Reboot (System:144)
```

- Line 5-11: The I2C Master is initialized
- Line 12-17: The MCP23017 class `Initialize()` method writes 0x2C to the MCP123017 IOCON register
- Line 18-22: We read the MCP23017 GPIOA register.
This is done by first writing 1 byte (the register number), and then reading one byte
- Line 23-28: We write 0x00 to the MCP23017 GPPUA register.
This disables the pull up resistors for port A
- Line 29-34: We write 0x00 to the MCP23017 IODIRA register.
This sets all pins on port A to output
- Line 35-40: We write 0x00 to the MCP23017 GPPUB register.
This disables the pull up resistors for port B
- Line 41-46: We write 0x00 to the MCP23017 IODIRB register.
This sets all pins on port B to output
- Line 47-52: We write 0x55 to the MCP23017 GPIOA register.
This sets the pin values on port A.
This results in the first image below
- Line 53-58: We write 0xAA to the MCP23017 GPIOB register.
This sets the pin values on port B
- Line 59-64: We write 0xAA to the MCP23017 GPIOA register.
This sets the pin values on port A.
This results in the second image below
- Line 65-70: We write 0x55 to the MCP23017 GPIOB register.
This sets the pin values on port B
- Line 71-76: We write 0x00 to the MCP23017 GPIOA register.
This sets the pin values on port A.
This results in the third image below
- Line 77-82: We write 0x00 to the MCP23017 GPIOB register.
This sets the pin values on port B
- Line 84-89: We write 0x00 to the MCP23017 GPPUA register.
This disables the pull up resistors for port A
- Line 90-95: We write 0xFF to the MCP23017 IODIRA register.
This sets all pins on port A to input
- Line 96-101: We write 0x00 to the MCP23017 GPPUB register.
This disables the pull up resistors for port B
- Line 102-107: We write 0xFF to the MCP23017 IODIRB register.
This sets all pins on port B to input

<img src="images/Tutorial_21-MCP23017-1.jpg"  alt="I2C bus" width="600"/>

<img src="images/Tutorial_21-MCP23017-2.jpg"  alt="I2C bus" width="600"/>

<img src="images/Tutorial_21-MCP23017-3.jpg"  alt="I2C bus" width="600"/>


Next: [23-unit-test-infrastructure](23-unit-test-infrastructure.md)
